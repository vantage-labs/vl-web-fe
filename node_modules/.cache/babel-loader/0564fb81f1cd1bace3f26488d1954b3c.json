{"ast":null,"code":"\"use client\"; // packages/react/select/src/Select.tsx\n\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { clamp } from \"@radix-ui/number\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { useDirection } from \"@radix-ui/react-direction\";\nimport { DismissableLayer } from \"@radix-ui/react-dismissable-layer\";\nimport { useFocusGuards } from \"@radix-ui/react-focus-guards\";\nimport { FocusScope } from \"@radix-ui/react-focus-scope\";\nimport { useId } from \"@radix-ui/react-id\";\nimport * as PopperPrimitive from \"@radix-ui/react-popper\";\nimport { createPopperScope } from \"@radix-ui/react-popper\";\nimport { Portal as PortalPrimitive } from \"@radix-ui/react-portal\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { usePrevious } from \"@radix-ui/react-use-previous\";\nimport { VisuallyHidden } from \"@radix-ui/react-visually-hidden\";\nimport { hideOthers } from \"aria-hidden\";\nimport { RemoveScroll } from \"react-remove-scroll\";\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nvar OPEN_KEYS = [\" \", \"Enter\", \"ArrowUp\", \"ArrowDown\"];\nvar SELECTION_KEYS = [\" \", \"Enter\"];\nvar SELECT_NAME = \"Select\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(SELECT_NAME);\nvar [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [createCollectionScope, createPopperScope]);\nvar usePopperScope = createPopperScope();\nvar [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);\nvar [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);\n\nvar Select = props => {\n  const {\n    __scopeSelect,\n    children,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    value: valueProp,\n    defaultValue,\n    onValueChange,\n    dir,\n    name,\n    autoComplete,\n    disabled,\n    required,\n    form\n  } = props;\n  const popperScope = usePopperScope(__scopeSelect);\n  const [trigger, setTrigger] = React.useState(null);\n  const [valueNode, setValueNode] = React.useState(null);\n  const [valueNodeHasChildren, setValueNodeHasChildren] = React.useState(false);\n  const direction = useDirection(dir);\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange\n  });\n  const [value, setValue] = useControllableState({\n    prop: valueProp,\n    defaultProp: defaultValue,\n    onChange: onValueChange\n  });\n  const triggerPointerDownPosRef = React.useRef(null);\n  const isFormControl = trigger ? form || !!trigger.closest(\"form\") : true;\n  const [nativeOptionsSet, setNativeOptionsSet] = React.useState( /* @__PURE__ */new Set());\n  const nativeSelectKey = Array.from(nativeOptionsSet).map(option => option.props.value).join(\";\");\n  return /* @__PURE__ */jsx(PopperPrimitive.Root, { ...popperScope,\n    children: /* @__PURE__ */jsxs(SelectProvider, {\n      required,\n      scope: __scopeSelect,\n      trigger,\n      onTriggerChange: setTrigger,\n      valueNode,\n      onValueNodeChange: setValueNode,\n      valueNodeHasChildren,\n      onValueNodeHasChildrenChange: setValueNodeHasChildren,\n      contentId: useId(),\n      value,\n      onValueChange: setValue,\n      open,\n      onOpenChange: setOpen,\n      dir: direction,\n      triggerPointerDownPosRef,\n      disabled,\n      children: [/* @__PURE__ */jsx(Collection.Provider, {\n        scope: __scopeSelect,\n        children: /* @__PURE__ */jsx(SelectNativeOptionsProvider, {\n          scope: props.__scopeSelect,\n          onNativeOptionAdd: React.useCallback(option => {\n            setNativeOptionsSet(prev => new Set(prev).add(option));\n          }, []),\n          onNativeOptionRemove: React.useCallback(option => {\n            setNativeOptionsSet(prev => {\n              const optionsSet = new Set(prev);\n              optionsSet.delete(option);\n              return optionsSet;\n            });\n          }, []),\n          children\n        })\n      }), isFormControl ? /* @__PURE__ */jsxs(BubbleSelect, {\n        \"aria-hidden\": true,\n        required,\n        tabIndex: -1,\n        name,\n        autoComplete,\n        value,\n        onChange: event => setValue(event.target.value),\n        disabled,\n        form,\n        children: [value === void 0 ? /* @__PURE__ */jsx(\"option\", {\n          value: \"\"\n        }) : null, Array.from(nativeOptionsSet)]\n      }, nativeSelectKey) : null]\n    })\n  });\n};\n\nSelect.displayName = SELECT_NAME;\nvar TRIGGER_NAME = \"SelectTrigger\";\nvar SelectTrigger = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    disabled = false,\n    ...triggerProps\n  } = props;\n  const popperScope = usePopperScope(__scopeSelect);\n  const context = useSelectContext(TRIGGER_NAME, __scopeSelect);\n  const isDisabled = context.disabled || disabled;\n  const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);\n  const getItems = useCollection(__scopeSelect);\n  const pointerTypeRef = React.useRef(\"touch\");\n  const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch(search => {\n    const enabledItems = getItems().filter(item => !item.disabled);\n    const currentItem = enabledItems.find(item => item.value === context.value);\n    const nextItem = findNextItem(enabledItems, search, currentItem);\n\n    if (nextItem !== void 0) {\n      context.onValueChange(nextItem.value);\n    }\n  });\n\n  const handleOpen = pointerEvent => {\n    if (!isDisabled) {\n      context.onOpenChange(true);\n      resetTypeahead();\n    }\n\n    if (pointerEvent) {\n      context.triggerPointerDownPosRef.current = {\n        x: Math.round(pointerEvent.pageX),\n        y: Math.round(pointerEvent.pageY)\n      };\n    }\n  };\n\n  return /* @__PURE__ */jsx(PopperPrimitive.Anchor, {\n    asChild: true,\n    ...popperScope,\n    children: /* @__PURE__ */jsx(Primitive.button, {\n      type: \"button\",\n      role: \"combobox\",\n      \"aria-controls\": context.contentId,\n      \"aria-expanded\": context.open,\n      \"aria-required\": context.required,\n      \"aria-autocomplete\": \"none\",\n      dir: context.dir,\n      \"data-state\": context.open ? \"open\" : \"closed\",\n      disabled: isDisabled,\n      \"data-disabled\": isDisabled ? \"\" : void 0,\n      \"data-placeholder\": shouldShowPlaceholder(context.value) ? \"\" : void 0,\n      ...triggerProps,\n      ref: composedRefs,\n      onClick: composeEventHandlers(triggerProps.onClick, event => {\n        event.currentTarget.focus();\n\n        if (pointerTypeRef.current !== \"mouse\") {\n          handleOpen(event);\n        }\n      }),\n      onPointerDown: composeEventHandlers(triggerProps.onPointerDown, event => {\n        pointerTypeRef.current = event.pointerType;\n        const target = event.target;\n\n        if (target.hasPointerCapture(event.pointerId)) {\n          target.releasePointerCapture(event.pointerId);\n        }\n\n        if (event.button === 0 && event.ctrlKey === false && event.pointerType === \"mouse\") {\n          handleOpen(event);\n          event.preventDefault();\n        }\n      }),\n      onKeyDown: composeEventHandlers(triggerProps.onKeyDown, event => {\n        const isTypingAhead = searchRef.current !== \"\";\n        const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n        if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);\n        if (isTypingAhead && event.key === \" \") return;\n\n        if (OPEN_KEYS.includes(event.key)) {\n          handleOpen();\n          event.preventDefault();\n        }\n      })\n    })\n  });\n});\nSelectTrigger.displayName = TRIGGER_NAME;\nvar VALUE_NAME = \"SelectValue\";\nvar SelectValue = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    className,\n    style,\n    children,\n    placeholder = \"\",\n    ...valueProps\n  } = props;\n  const context = useSelectContext(VALUE_NAME, __scopeSelect);\n  const {\n    onValueNodeHasChildrenChange\n  } = context;\n  const hasChildren = children !== void 0;\n  const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);\n  useLayoutEffect(() => {\n    onValueNodeHasChildrenChange(hasChildren);\n  }, [onValueNodeHasChildrenChange, hasChildren]);\n  return /* @__PURE__ */jsx(Primitive.span, { ...valueProps,\n    ref: composedRefs,\n    style: {\n      pointerEvents: \"none\"\n    },\n    children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */jsx(Fragment, {\n      children: placeholder\n    }) : children\n  });\n});\nSelectValue.displayName = VALUE_NAME;\nvar ICON_NAME = \"SelectIcon\";\nvar SelectIcon = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    children,\n    ...iconProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.span, {\n    \"aria-hidden\": true,\n    ...iconProps,\n    ref: forwardedRef,\n    children: children || \"\\u25BC\"\n  });\n});\nSelectIcon.displayName = ICON_NAME;\nvar PORTAL_NAME = \"SelectPortal\";\n\nvar SelectPortal = props => {\n  return /* @__PURE__ */jsx(PortalPrimitive, {\n    asChild: true,\n    ...props\n  });\n};\n\nSelectPortal.displayName = PORTAL_NAME;\nvar CONTENT_NAME = \"SelectContent\";\nvar SelectContent = React.forwardRef((props, forwardedRef) => {\n  const context = useSelectContext(CONTENT_NAME, props.__scopeSelect);\n  const [fragment, setFragment] = React.useState();\n  useLayoutEffect(() => {\n    setFragment(new DocumentFragment());\n  }, []);\n\n  if (!context.open) {\n    const frag = fragment;\n    return frag ? ReactDOM.createPortal( /* @__PURE__ */jsx(SelectContentProvider, {\n      scope: props.__scopeSelect,\n      children: /* @__PURE__ */jsx(Collection.Slot, {\n        scope: props.__scopeSelect,\n        children: /* @__PURE__ */jsx(\"div\", {\n          children: props.children\n        })\n      })\n    }), frag) : null;\n  }\n\n  return /* @__PURE__ */jsx(SelectContentImpl, { ...props,\n    ref: forwardedRef\n  });\n});\nSelectContent.displayName = CONTENT_NAME;\nvar CONTENT_MARGIN = 10;\nvar [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME);\nvar CONTENT_IMPL_NAME = \"SelectContentImpl\";\nvar SelectContentImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    position = \"item-aligned\",\n    onCloseAutoFocus,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    //\n    // PopperContent props\n    side,\n    sideOffset,\n    align,\n    alignOffset,\n    arrowPadding,\n    collisionBoundary,\n    collisionPadding,\n    sticky,\n    hideWhenDetached,\n    avoidCollisions,\n    //\n    ...contentProps\n  } = props;\n  const context = useSelectContext(CONTENT_NAME, __scopeSelect);\n  const [content, setContent] = React.useState(null);\n  const [viewport, setViewport] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setContent(node));\n  const [selectedItem, setSelectedItem] = React.useState(null);\n  const [selectedItemText, setSelectedItemText] = React.useState(null);\n  const getItems = useCollection(__scopeSelect);\n  const [isPositioned, setIsPositioned] = React.useState(false);\n  const firstValidItemFoundRef = React.useRef(false);\n  React.useEffect(() => {\n    if (content) return hideOthers(content);\n  }, [content]);\n  useFocusGuards();\n  const focusFirst = React.useCallback(candidates => {\n    const [firstItem, ...restItems] = getItems().map(item => item.ref.current);\n    const [lastItem] = restItems.slice(-1);\n    const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n\n    for (const candidate of candidates) {\n      if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n      candidate?.scrollIntoView({\n        block: \"nearest\"\n      });\n      if (candidate === firstItem && viewport) viewport.scrollTop = 0;\n      if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;\n      candidate?.focus();\n      if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n    }\n  }, [getItems, viewport]);\n  const focusSelectedItem = React.useCallback(() => focusFirst([selectedItem, content]), [focusFirst, selectedItem, content]);\n  React.useEffect(() => {\n    if (isPositioned) {\n      focusSelectedItem();\n    }\n  }, [isPositioned, focusSelectedItem]);\n  const {\n    onOpenChange,\n    triggerPointerDownPosRef\n  } = context;\n  React.useEffect(() => {\n    if (content) {\n      let pointerMoveDelta = {\n        x: 0,\n        y: 0\n      };\n\n      const handlePointerMove = event => {\n        pointerMoveDelta = {\n          x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),\n          y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0))\n        };\n      };\n\n      const handlePointerUp = event => {\n        if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {\n          event.preventDefault();\n        } else {\n          if (!content.contains(event.target)) {\n            onOpenChange(false);\n          }\n        }\n\n        document.removeEventListener(\"pointermove\", handlePointerMove);\n        triggerPointerDownPosRef.current = null;\n      };\n\n      if (triggerPointerDownPosRef.current !== null) {\n        document.addEventListener(\"pointermove\", handlePointerMove);\n        document.addEventListener(\"pointerup\", handlePointerUp, {\n          capture: true,\n          once: true\n        });\n      }\n\n      return () => {\n        document.removeEventListener(\"pointermove\", handlePointerMove);\n        document.removeEventListener(\"pointerup\", handlePointerUp, {\n          capture: true\n        });\n      };\n    }\n  }, [content, onOpenChange, triggerPointerDownPosRef]);\n  React.useEffect(() => {\n    const close = () => onOpenChange(false);\n\n    window.addEventListener(\"blur\", close);\n    window.addEventListener(\"resize\", close);\n    return () => {\n      window.removeEventListener(\"blur\", close);\n      window.removeEventListener(\"resize\", close);\n    };\n  }, [onOpenChange]);\n  const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch(search => {\n    const enabledItems = getItems().filter(item => !item.disabled);\n    const currentItem = enabledItems.find(item => item.ref.current === document.activeElement);\n    const nextItem = findNextItem(enabledItems, search, currentItem);\n\n    if (nextItem) {\n      setTimeout(() => nextItem.ref.current.focus());\n    }\n  });\n  const itemRefCallback = React.useCallback((node, value, disabled) => {\n    const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;\n    const isSelectedItem = context.value !== void 0 && context.value === value;\n\n    if (isSelectedItem || isFirstValidItem) {\n      setSelectedItem(node);\n      if (isFirstValidItem) firstValidItemFoundRef.current = true;\n    }\n  }, [context.value]);\n  const handleItemLeave = React.useCallback(() => content?.focus(), [content]);\n  const itemTextRefCallback = React.useCallback((node, value, disabled) => {\n    const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;\n    const isSelectedItem = context.value !== void 0 && context.value === value;\n\n    if (isSelectedItem || isFirstValidItem) {\n      setSelectedItemText(node);\n    }\n  }, [context.value]);\n  const SelectPosition = position === \"popper\" ? SelectPopperPosition : SelectItemAlignedPosition;\n  const popperContentProps = SelectPosition === SelectPopperPosition ? {\n    side,\n    sideOffset,\n    align,\n    alignOffset,\n    arrowPadding,\n    collisionBoundary,\n    collisionPadding,\n    sticky,\n    hideWhenDetached,\n    avoidCollisions\n  } : {};\n  return /* @__PURE__ */jsx(SelectContentProvider, {\n    scope: __scopeSelect,\n    content,\n    viewport,\n    onViewportChange: setViewport,\n    itemRefCallback,\n    selectedItem,\n    onItemLeave: handleItemLeave,\n    itemTextRefCallback,\n    focusSelectedItem,\n    selectedItemText,\n    position,\n    isPositioned,\n    searchRef,\n    children: /* @__PURE__ */jsx(RemoveScroll, {\n      as: Slot,\n      allowPinchZoom: true,\n      children: /* @__PURE__ */jsx(FocusScope, {\n        asChild: true,\n        trapped: context.open,\n        onMountAutoFocus: event => {\n          event.preventDefault();\n        },\n        onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, event => {\n          context.trigger?.focus({\n            preventScroll: true\n          });\n          event.preventDefault();\n        }),\n        children: /* @__PURE__ */jsx(DismissableLayer, {\n          asChild: true,\n          disableOutsidePointerEvents: true,\n          onEscapeKeyDown,\n          onPointerDownOutside,\n          onFocusOutside: event => event.preventDefault(),\n          onDismiss: () => context.onOpenChange(false),\n          children: /* @__PURE__ */jsx(SelectPosition, {\n            role: \"listbox\",\n            id: context.contentId,\n            \"data-state\": context.open ? \"open\" : \"closed\",\n            dir: context.dir,\n            onContextMenu: event => event.preventDefault(),\n            ...contentProps,\n            ...popperContentProps,\n            onPlaced: () => setIsPositioned(true),\n            ref: composedRefs,\n            style: {\n              // flex layout so we can place the scroll buttons properly\n              display: \"flex\",\n              flexDirection: \"column\",\n              // reset the outline by default as the content MAY get focused\n              outline: \"none\",\n              ...contentProps.style\n            },\n            onKeyDown: composeEventHandlers(contentProps.onKeyDown, event => {\n              const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n              if (event.key === \"Tab\") event.preventDefault();\n              if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);\n\n              if ([\"ArrowUp\", \"ArrowDown\", \"Home\", \"End\"].includes(event.key)) {\n                const items = getItems().filter(item => !item.disabled);\n                let candidateNodes = items.map(item => item.ref.current);\n\n                if ([\"ArrowUp\", \"End\"].includes(event.key)) {\n                  candidateNodes = candidateNodes.slice().reverse();\n                }\n\n                if ([\"ArrowUp\", \"ArrowDown\"].includes(event.key)) {\n                  const currentElement = event.target;\n                  const currentIndex = candidateNodes.indexOf(currentElement);\n                  candidateNodes = candidateNodes.slice(currentIndex + 1);\n                }\n\n                setTimeout(() => focusFirst(candidateNodes));\n                event.preventDefault();\n              }\n            })\n          })\n        })\n      })\n    })\n  });\n});\nSelectContentImpl.displayName = CONTENT_IMPL_NAME;\nvar ITEM_ALIGNED_POSITION_NAME = \"SelectItemAlignedPosition\";\nvar SelectItemAlignedPosition = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    onPlaced,\n    ...popperProps\n  } = props;\n  const context = useSelectContext(CONTENT_NAME, __scopeSelect);\n  const contentContext = useSelectContentContext(CONTENT_NAME, __scopeSelect);\n  const [contentWrapper, setContentWrapper] = React.useState(null);\n  const [content, setContent] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setContent(node));\n  const getItems = useCollection(__scopeSelect);\n  const shouldExpandOnScrollRef = React.useRef(false);\n  const shouldRepositionRef = React.useRef(true);\n  const {\n    viewport,\n    selectedItem,\n    selectedItemText,\n    focusSelectedItem\n  } = contentContext;\n  const position = React.useCallback(() => {\n    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {\n      const triggerRect = context.trigger.getBoundingClientRect();\n      const contentRect = content.getBoundingClientRect();\n      const valueNodeRect = context.valueNode.getBoundingClientRect();\n      const itemTextRect = selectedItemText.getBoundingClientRect();\n\n      if (context.dir !== \"rtl\") {\n        const itemTextOffset = itemTextRect.left - contentRect.left;\n        const left = valueNodeRect.left - itemTextOffset;\n        const leftDelta = triggerRect.left - left;\n        const minContentWidth = triggerRect.width + leftDelta;\n        const contentWidth = Math.max(minContentWidth, contentRect.width);\n        const rightEdge = window.innerWidth - CONTENT_MARGIN;\n        const clampedLeft = clamp(left, [CONTENT_MARGIN, // Prevents the content from going off the starting edge of the\n        // viewport. It may still go off the ending edge, but this can be\n        // controlled by the user since they may want to manage overflow in a\n        // specific way.\n        // https://github.com/radix-ui/primitives/issues/2049\n        Math.max(CONTENT_MARGIN, rightEdge - contentWidth)]);\n        contentWrapper.style.minWidth = minContentWidth + \"px\";\n        contentWrapper.style.left = clampedLeft + \"px\";\n      } else {\n        const itemTextOffset = contentRect.right - itemTextRect.right;\n        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;\n        const rightDelta = window.innerWidth - triggerRect.right - right;\n        const minContentWidth = triggerRect.width + rightDelta;\n        const contentWidth = Math.max(minContentWidth, contentRect.width);\n        const leftEdge = window.innerWidth - CONTENT_MARGIN;\n        const clampedRight = clamp(right, [CONTENT_MARGIN, Math.max(CONTENT_MARGIN, leftEdge - contentWidth)]);\n        contentWrapper.style.minWidth = minContentWidth + \"px\";\n        contentWrapper.style.right = clampedRight + \"px\";\n      }\n\n      const items = getItems();\n      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;\n      const itemsHeight = viewport.scrollHeight;\n      const contentStyles = window.getComputedStyle(content);\n      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);\n      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);\n      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);\n      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);\n      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;\n      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);\n      const viewportStyles = window.getComputedStyle(viewport);\n      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);\n      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);\n      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;\n      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;\n      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;\n      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;\n      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;\n      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;\n      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;\n\n      if (willAlignWithoutTopOverflow) {\n        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;\n        contentWrapper.style.bottom = \"0px\";\n        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;\n        const clampedTriggerMiddleToBottomEdge = Math.max(triggerMiddleToBottomEdge, selectedItemHalfHeight + ( // viewport might have padding bottom, include it to avoid a scrollable viewport\n        isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth);\n        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;\n        contentWrapper.style.height = height + \"px\";\n      } else {\n        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;\n        contentWrapper.style.top = \"0px\";\n        const clampedTopEdgeToTriggerMiddle = Math.max(topEdgeToTriggerMiddle, contentBorderTopWidth + viewport.offsetTop + ( // viewport might have padding top, include it to avoid a scrollable viewport\n        isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight);\n        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;\n        contentWrapper.style.height = height + \"px\";\n        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;\n      }\n\n      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;\n      contentWrapper.style.minHeight = minContentHeight + \"px\";\n      contentWrapper.style.maxHeight = availableHeight + \"px\";\n      onPlaced?.();\n      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);\n    }\n  }, [getItems, context.trigger, context.valueNode, contentWrapper, content, viewport, selectedItem, selectedItemText, context.dir, onPlaced]);\n  useLayoutEffect(() => position(), [position]);\n  const [contentZIndex, setContentZIndex] = React.useState();\n  useLayoutEffect(() => {\n    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n  }, [content]);\n  const handleScrollButtonChange = React.useCallback(node => {\n    if (node && shouldRepositionRef.current === true) {\n      position();\n      focusSelectedItem?.();\n      shouldRepositionRef.current = false;\n    }\n  }, [position, focusSelectedItem]);\n  return /* @__PURE__ */jsx(SelectViewportProvider, {\n    scope: __scopeSelect,\n    contentWrapper,\n    shouldExpandOnScrollRef,\n    onScrollButtonChange: handleScrollButtonChange,\n    children: /* @__PURE__ */jsx(\"div\", {\n      ref: setContentWrapper,\n      style: {\n        display: \"flex\",\n        flexDirection: \"column\",\n        position: \"fixed\",\n        zIndex: contentZIndex\n      },\n      children: /* @__PURE__ */jsx(Primitive.div, { ...popperProps,\n        ref: composedRefs,\n        style: {\n          // When we get the height of the content, it includes borders. If we were to set\n          // the height without having `boxSizing: 'border-box'` it would be too big.\n          boxSizing: \"border-box\",\n          // We need to ensure the content doesn't get taller than the wrapper\n          maxHeight: \"100%\",\n          ...popperProps.style\n        }\n      })\n    })\n  });\n});\nSelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;\nvar POPPER_POSITION_NAME = \"SelectPopperPosition\";\nvar SelectPopperPosition = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    align = \"start\",\n    collisionPadding = CONTENT_MARGIN,\n    ...popperProps\n  } = props;\n  const popperScope = usePopperScope(__scopeSelect);\n  return /* @__PURE__ */jsx(PopperPrimitive.Content, { ...popperScope,\n    ...popperProps,\n    ref: forwardedRef,\n    align,\n    collisionPadding,\n    style: {\n      // Ensure border-box for floating-ui calculations\n      boxSizing: \"border-box\",\n      ...popperProps.style,\n      // re-namespace exposed content custom properties\n      ...{\n        \"--radix-select-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n        \"--radix-select-content-available-width\": \"var(--radix-popper-available-width)\",\n        \"--radix-select-content-available-height\": \"var(--radix-popper-available-height)\",\n        \"--radix-select-trigger-width\": \"var(--radix-popper-anchor-width)\",\n        \"--radix-select-trigger-height\": \"var(--radix-popper-anchor-height)\"\n      }\n    }\n  });\n});\nSelectPopperPosition.displayName = POPPER_POSITION_NAME;\nvar [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME, {});\nvar VIEWPORT_NAME = \"SelectViewport\";\nvar SelectViewport = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    nonce,\n    ...viewportProps\n  } = props;\n  const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);\n  const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);\n  const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);\n  const prevScrollTopRef = React.useRef(0);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(\"style\", {\n      dangerouslySetInnerHTML: {\n        __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`\n      },\n      nonce\n    }), /* @__PURE__ */jsx(Collection.Slot, {\n      scope: __scopeSelect,\n      children: /* @__PURE__ */jsx(Primitive.div, {\n        \"data-radix-select-viewport\": \"\",\n        role: \"presentation\",\n        ...viewportProps,\n        ref: composedRefs,\n        style: {\n          // we use position: 'relative' here on the `viewport` so that when we call\n          // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n          // (independent of the scrollUpButton).\n          position: \"relative\",\n          flex: 1,\n          // Viewport should only be scrollable in the vertical direction.\n          // This won't work in vertical writing modes, so we'll need to\n          // revisit this if/when that is supported\n          // https://developer.chrome.com/blog/vertical-form-controls\n          overflow: \"hidden auto\",\n          ...viewportProps.style\n        },\n        onScroll: composeEventHandlers(viewportProps.onScroll, event => {\n          const viewport = event.currentTarget;\n          const {\n            contentWrapper,\n            shouldExpandOnScrollRef\n          } = viewportContext;\n\n          if (shouldExpandOnScrollRef?.current && contentWrapper) {\n            const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);\n\n            if (scrolledBy > 0) {\n              const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;\n              const cssMinHeight = parseFloat(contentWrapper.style.minHeight);\n              const cssHeight = parseFloat(contentWrapper.style.height);\n              const prevHeight = Math.max(cssMinHeight, cssHeight);\n\n              if (prevHeight < availableHeight) {\n                const nextHeight = prevHeight + scrolledBy;\n                const clampedNextHeight = Math.min(availableHeight, nextHeight);\n                const heightDiff = nextHeight - clampedNextHeight;\n                contentWrapper.style.height = clampedNextHeight + \"px\";\n\n                if (contentWrapper.style.bottom === \"0px\") {\n                  viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;\n                  contentWrapper.style.justifyContent = \"flex-end\";\n                }\n              }\n            }\n          }\n\n          prevScrollTopRef.current = viewport.scrollTop;\n        })\n      })\n    })]\n  });\n});\nSelectViewport.displayName = VIEWPORT_NAME;\nvar GROUP_NAME = \"SelectGroup\";\nvar [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);\nvar SelectGroup = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    ...groupProps\n  } = props;\n  const groupId = useId();\n  return /* @__PURE__ */jsx(SelectGroupContextProvider, {\n    scope: __scopeSelect,\n    id: groupId,\n    children: /* @__PURE__ */jsx(Primitive.div, {\n      role: \"group\",\n      \"aria-labelledby\": groupId,\n      ...groupProps,\n      ref: forwardedRef\n    })\n  });\n});\nSelectGroup.displayName = GROUP_NAME;\nvar LABEL_NAME = \"SelectLabel\";\nvar SelectLabel = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    ...labelProps\n  } = props;\n  const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);\n  return /* @__PURE__ */jsx(Primitive.div, {\n    id: groupContext.id,\n    ...labelProps,\n    ref: forwardedRef\n  });\n});\nSelectLabel.displayName = LABEL_NAME;\nvar ITEM_NAME = \"SelectItem\";\nvar [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);\nvar SelectItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    value,\n    disabled = false,\n    textValue: textValueProp,\n    ...itemProps\n  } = props;\n  const context = useSelectContext(ITEM_NAME, __scopeSelect);\n  const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);\n  const isSelected = context.value === value;\n  const [textValue, setTextValue] = React.useState(textValueProp ?? \"\");\n  const [isFocused, setIsFocused] = React.useState(false);\n  const composedRefs = useComposedRefs(forwardedRef, node => contentContext.itemRefCallback?.(node, value, disabled));\n  const textId = useId();\n  const pointerTypeRef = React.useRef(\"touch\");\n\n  const handleSelect = () => {\n    if (!disabled) {\n      context.onValueChange(value);\n      context.onOpenChange(false);\n    }\n  };\n\n  if (value === \"\") {\n    throw new Error(\"A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.\");\n  }\n\n  return /* @__PURE__ */jsx(SelectItemContextProvider, {\n    scope: __scopeSelect,\n    value,\n    disabled,\n    textId,\n    isSelected,\n    onItemTextChange: React.useCallback(node => {\n      setTextValue(prevTextValue => prevTextValue || (node?.textContent ?? \"\").trim());\n    }, []),\n    children: /* @__PURE__ */jsx(Collection.ItemSlot, {\n      scope: __scopeSelect,\n      value,\n      disabled,\n      textValue,\n      children: /* @__PURE__ */jsx(Primitive.div, {\n        role: \"option\",\n        \"aria-labelledby\": textId,\n        \"data-highlighted\": isFocused ? \"\" : void 0,\n        \"aria-selected\": isSelected && isFocused,\n        \"data-state\": isSelected ? \"checked\" : \"unchecked\",\n        \"aria-disabled\": disabled || void 0,\n        \"data-disabled\": disabled ? \"\" : void 0,\n        tabIndex: disabled ? void 0 : -1,\n        ...itemProps,\n        ref: composedRefs,\n        onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),\n        onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),\n        onClick: composeEventHandlers(itemProps.onClick, () => {\n          if (pointerTypeRef.current !== \"mouse\") handleSelect();\n        }),\n        onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {\n          if (pointerTypeRef.current === \"mouse\") handleSelect();\n        }),\n        onPointerDown: composeEventHandlers(itemProps.onPointerDown, event => {\n          pointerTypeRef.current = event.pointerType;\n        }),\n        onPointerMove: composeEventHandlers(itemProps.onPointerMove, event => {\n          pointerTypeRef.current = event.pointerType;\n\n          if (disabled) {\n            contentContext.onItemLeave?.();\n          } else if (pointerTypeRef.current === \"mouse\") {\n            event.currentTarget.focus({\n              preventScroll: true\n            });\n          }\n        }),\n        onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, event => {\n          if (event.currentTarget === document.activeElement) {\n            contentContext.onItemLeave?.();\n          }\n        }),\n        onKeyDown: composeEventHandlers(itemProps.onKeyDown, event => {\n          const isTypingAhead = contentContext.searchRef?.current !== \"\";\n          if (isTypingAhead && event.key === \" \") return;\n          if (SELECTION_KEYS.includes(event.key)) handleSelect();\n          if (event.key === \" \") event.preventDefault();\n        })\n      })\n    })\n  });\n});\nSelectItem.displayName = ITEM_NAME;\nvar ITEM_TEXT_NAME = \"SelectItemText\";\nvar SelectItemText = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    className,\n    style,\n    ...itemTextProps\n  } = props;\n  const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);\n  const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);\n  const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);\n  const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);\n  const [itemTextNode, setItemTextNode] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setItemTextNode(node), itemContext.onItemTextChange, node => contentContext.itemTextRefCallback?.(node, itemContext.value, itemContext.disabled));\n  const textContent = itemTextNode?.textContent;\n  const nativeOption = React.useMemo(() => /* @__PURE__ */jsx(\"option\", {\n    value: itemContext.value,\n    disabled: itemContext.disabled,\n    children: textContent\n  }, itemContext.value), [itemContext.disabled, itemContext.value, textContent]);\n  const {\n    onNativeOptionAdd,\n    onNativeOptionRemove\n  } = nativeOptionsContext;\n  useLayoutEffect(() => {\n    onNativeOptionAdd(nativeOption);\n    return () => onNativeOptionRemove(nativeOption);\n  }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(Primitive.span, {\n      id: itemContext.textId,\n      ...itemTextProps,\n      ref: composedRefs\n    }), itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? ReactDOM.createPortal(itemTextProps.children, context.valueNode) : null]\n  });\n});\nSelectItemText.displayName = ITEM_TEXT_NAME;\nvar ITEM_INDICATOR_NAME = \"SelectItemIndicator\";\nvar SelectItemIndicator = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    ...itemIndicatorProps\n  } = props;\n  const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);\n  return itemContext.isSelected ? /* @__PURE__ */jsx(Primitive.span, {\n    \"aria-hidden\": true,\n    ...itemIndicatorProps,\n    ref: forwardedRef\n  }) : null;\n});\nSelectItemIndicator.displayName = ITEM_INDICATOR_NAME;\nvar SCROLL_UP_BUTTON_NAME = \"SelectScrollUpButton\";\nvar SelectScrollUpButton = React.forwardRef((props, forwardedRef) => {\n  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);\n  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);\n  const [canScrollUp, setCanScrollUp] = React.useState(false);\n  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);\n  useLayoutEffect(() => {\n    if (contentContext.viewport && contentContext.isPositioned) {\n      let handleScroll2 = function () {\n        const canScrollUp2 = viewport.scrollTop > 0;\n        setCanScrollUp(canScrollUp2);\n      };\n\n      var handleScroll = handleScroll2;\n      const viewport = contentContext.viewport;\n      handleScroll2();\n      viewport.addEventListener(\"scroll\", handleScroll2);\n      return () => viewport.removeEventListener(\"scroll\", handleScroll2);\n    }\n  }, [contentContext.viewport, contentContext.isPositioned]);\n  return canScrollUp ? /* @__PURE__ */jsx(SelectScrollButtonImpl, { ...props,\n    ref: composedRefs,\n    onAutoScroll: () => {\n      const {\n        viewport,\n        selectedItem\n      } = contentContext;\n\n      if (viewport && selectedItem) {\n        viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;\n      }\n    }\n  }) : null;\n});\nSelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;\nvar SCROLL_DOWN_BUTTON_NAME = \"SelectScrollDownButton\";\nvar SelectScrollDownButton = React.forwardRef((props, forwardedRef) => {\n  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);\n  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);\n  const [canScrollDown, setCanScrollDown] = React.useState(false);\n  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);\n  useLayoutEffect(() => {\n    if (contentContext.viewport && contentContext.isPositioned) {\n      let handleScroll2 = function () {\n        const maxScroll = viewport.scrollHeight - viewport.clientHeight;\n        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;\n        setCanScrollDown(canScrollDown2);\n      };\n\n      var handleScroll = handleScroll2;\n      const viewport = contentContext.viewport;\n      handleScroll2();\n      viewport.addEventListener(\"scroll\", handleScroll2);\n      return () => viewport.removeEventListener(\"scroll\", handleScroll2);\n    }\n  }, [contentContext.viewport, contentContext.isPositioned]);\n  return canScrollDown ? /* @__PURE__ */jsx(SelectScrollButtonImpl, { ...props,\n    ref: composedRefs,\n    onAutoScroll: () => {\n      const {\n        viewport,\n        selectedItem\n      } = contentContext;\n\n      if (viewport && selectedItem) {\n        viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;\n      }\n    }\n  }) : null;\n});\nSelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;\nvar SelectScrollButtonImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    onAutoScroll,\n    ...scrollIndicatorProps\n  } = props;\n  const contentContext = useSelectContentContext(\"SelectScrollButton\", __scopeSelect);\n  const autoScrollTimerRef = React.useRef(null);\n  const getItems = useCollection(__scopeSelect);\n  const clearAutoScrollTimer = React.useCallback(() => {\n    if (autoScrollTimerRef.current !== null) {\n      window.clearInterval(autoScrollTimerRef.current);\n      autoScrollTimerRef.current = null;\n    }\n  }, []);\n  React.useEffect(() => {\n    return () => clearAutoScrollTimer();\n  }, [clearAutoScrollTimer]);\n  useLayoutEffect(() => {\n    const activeItem = getItems().find(item => item.ref.current === document.activeElement);\n    activeItem?.ref.current?.scrollIntoView({\n      block: \"nearest\"\n    });\n  }, [getItems]);\n  return /* @__PURE__ */jsx(Primitive.div, {\n    \"aria-hidden\": true,\n    ...scrollIndicatorProps,\n    ref: forwardedRef,\n    style: {\n      flexShrink: 0,\n      ...scrollIndicatorProps.style\n    },\n    onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {\n      if (autoScrollTimerRef.current === null) {\n        autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);\n      }\n    }),\n    onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {\n      contentContext.onItemLeave?.();\n\n      if (autoScrollTimerRef.current === null) {\n        autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);\n      }\n    }),\n    onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {\n      clearAutoScrollTimer();\n    })\n  });\n});\nvar SEPARATOR_NAME = \"SelectSeparator\";\nvar SelectSeparator = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    ...separatorProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    \"aria-hidden\": true,\n    ...separatorProps,\n    ref: forwardedRef\n  });\n});\nSelectSeparator.displayName = SEPARATOR_NAME;\nvar ARROW_NAME = \"SelectArrow\";\nvar SelectArrow = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSelect,\n    ...arrowProps\n  } = props;\n  const popperScope = usePopperScope(__scopeSelect);\n  const context = useSelectContext(ARROW_NAME, __scopeSelect);\n  const contentContext = useSelectContentContext(ARROW_NAME, __scopeSelect);\n  return context.open && contentContext.position === \"popper\" ? /* @__PURE__ */jsx(PopperPrimitive.Arrow, { ...popperScope,\n    ...arrowProps,\n    ref: forwardedRef\n  }) : null;\n});\nSelectArrow.displayName = ARROW_NAME;\n\nfunction shouldShowPlaceholder(value) {\n  return value === \"\" || value === void 0;\n}\n\nvar BubbleSelect = React.forwardRef((props, forwardedRef) => {\n  const {\n    value,\n    ...selectProps\n  } = props;\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const prevValue = usePrevious(value);\n  React.useEffect(() => {\n    const select = ref.current;\n    const selectProto = window.HTMLSelectElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(selectProto, \"value\");\n    const setValue = descriptor.set;\n\n    if (prevValue !== value && setValue) {\n      const event = new Event(\"change\", {\n        bubbles: true\n      });\n      setValue.call(select, value);\n      select.dispatchEvent(event);\n    }\n  }, [prevValue, value]);\n  return /* @__PURE__ */jsx(VisuallyHidden, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(\"select\", { ...selectProps,\n      ref: composedRefs,\n      defaultValue: value\n    })\n  });\n});\nBubbleSelect.displayName = \"BubbleSelect\";\n\nfunction useTypeaheadSearch(onSearchChange) {\n  const handleSearchChange = useCallbackRef(onSearchChange);\n  const searchRef = React.useRef(\"\");\n  const timerRef = React.useRef(0);\n  const handleTypeaheadSearch = React.useCallback(key => {\n    const search = searchRef.current + key;\n    handleSearchChange(search);\n\n    (function updateSearch(value) {\n      searchRef.current = value;\n      window.clearTimeout(timerRef.current);\n      if (value !== \"\") timerRef.current = window.setTimeout(() => updateSearch(\"\"), 1e3);\n    })(search);\n  }, [handleSearchChange]);\n  const resetTypeahead = React.useCallback(() => {\n    searchRef.current = \"\";\n    window.clearTimeout(timerRef.current);\n  }, []);\n  React.useEffect(() => {\n    return () => window.clearTimeout(timerRef.current);\n  }, []);\n  return [searchRef, handleTypeaheadSearch, resetTypeahead];\n}\n\nfunction findNextItem(items, search, currentItem) {\n  const isRepeated = search.length > 1 && Array.from(search).every(char => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;\n  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));\n  const excludeCurrentItem = normalizedSearch.length === 1;\n  if (excludeCurrentItem) wrappedItems = wrappedItems.filter(v => v !== currentItem);\n  const nextItem = wrappedItems.find(item => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase()));\n  return nextItem !== currentItem ? nextItem : void 0;\n}\n\nfunction wrapArray(array, startIndex) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nvar Root2 = Select;\nvar Trigger = SelectTrigger;\nvar Value = SelectValue;\nvar Icon = SelectIcon;\nvar Portal = SelectPortal;\nvar Content2 = SelectContent;\nvar Viewport = SelectViewport;\nvar Group = SelectGroup;\nvar Label = SelectLabel;\nvar Item = SelectItem;\nvar ItemText = SelectItemText;\nvar ItemIndicator = SelectItemIndicator;\nvar ScrollUpButton = SelectScrollUpButton;\nvar ScrollDownButton = SelectScrollDownButton;\nvar Separator = SelectSeparator;\nvar Arrow2 = SelectArrow;\nexport { Arrow2 as Arrow, Content2 as Content, Group, Icon, Item, ItemIndicator, ItemText, Label, Portal, Root2 as Root, ScrollDownButton, ScrollUpButton, Select, SelectArrow, SelectContent, SelectGroup, SelectIcon, SelectItem, SelectItemIndicator, SelectItemText, SelectLabel, SelectPortal, SelectScrollDownButton, SelectScrollUpButton, SelectSeparator, SelectTrigger, SelectValue, SelectViewport, Separator, Trigger, Value, Viewport, createSelectScope };","map":{"version":3,"mappings":"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","names":["React","ReactDOM","clamp","composeEventHandlers","createCollection","useComposedRefs","createContextScope","useDirection","DismissableLayer","useFocusGuards","FocusScope","useId","PopperPrimitive","createPopperScope","Portal","PortalPrimitive","Primitive","Slot","useCallbackRef","useControllableState","useLayoutEffect","usePrevious","VisuallyHidden","hideOthers","RemoveScroll","Fragment","jsxs","OPEN_KEYS","SELECTION_KEYS","SELECT_NAME","Collection","useCollection","createCollectionScope","createSelectContext","createSelectScope","usePopperScope","SelectProvider","useSelectContext","SelectNativeOptionsProvider","useSelectNativeOptionsContext","Select","props","__scopeSelect","children","open","openProp","defaultOpen","onOpenChange","value","valueProp","defaultValue","onValueChange","dir","name","autoComplete","disabled","required","form","popperScope","trigger","setTrigger","valueNode","setValueNode","valueNodeHasChildren","setValueNodeHasChildren","direction","setOpen","prop","defaultProp","onChange","setValue","triggerPointerDownPosRef","isFormControl","closest","nativeOptionsSet","setNativeOptionsSet","Set","nativeSelectKey","Array","from","map","option","join","scope","onTriggerChange","onValueNodeChange","onValueNodeHasChildrenChange","contentId","Provider","onNativeOptionAdd","prev","add","onNativeOptionRemove","optionsSet","delete","BubbleSelect","tabIndex","event","target","displayName","TRIGGER_NAME","SelectTrigger","forwardedRef","triggerProps","context","isDisabled","composedRefs","getItems","pointerTypeRef","searchRef","handleTypeaheadSearch","resetTypeahead","useTypeaheadSearch","search","enabledItems","filter","item","currentItem","find","nextItem","findNextItem","handleOpen","pointerEvent","current","x","Math","round","pageX","y","pageY","asChild","button","type","role","shouldShowPlaceholder","ref","onClick","currentTarget","focus","onPointerDown","pointerType","hasPointerCapture","pointerId","releasePointerCapture","ctrlKey","preventDefault","onKeyDown","isTypingAhead","isModifierKey","altKey","metaKey","key","length","includes","VALUE_NAME","SelectValue","className","style","placeholder","valueProps","hasChildren","span","pointerEvents","ICON_NAME","SelectIcon","iconProps","PORTAL_NAME","SelectPortal","CONTENT_NAME","SelectContent","fragment","setFragment","DocumentFragment","frag","SelectContentProvider","SelectContentImpl","CONTENT_MARGIN","useSelectContentContext","CONTENT_IMPL_NAME","position","onCloseAutoFocus","onEscapeKeyDown","onPointerDownOutside","side","sideOffset","align","alignOffset","arrowPadding","collisionBoundary","collisionPadding","sticky","hideWhenDetached","avoidCollisions","contentProps","content","setContent","viewport","setViewport","node","selectedItem","setSelectedItem","selectedItemText","setSelectedItemText","isPositioned","setIsPositioned","firstValidItemFoundRef","focusFirst","candidates","firstItem","restItems","lastItem","slice","PREVIOUSLY_FOCUSED_ELEMENT","document","activeElement","candidate","scrollIntoView","block","scrollTop","scrollHeight","focusSelectedItem","pointerMoveDelta","handlePointerMove","abs","handlePointerUp","contains","removeEventListener","addEventListener","capture","once","close","window","setTimeout","itemRefCallback","isFirstValidItem","isSelectedItem","handleItemLeave","itemTextRefCallback","SelectPosition","SelectPopperPosition","SelectItemAlignedPosition","popperContentProps","onViewportChange","onItemLeave","as","allowPinchZoom","trapped","onMountAutoFocus","onUnmountAutoFocus","preventScroll","disableOutsidePointerEvents","onFocusOutside","onDismiss","id","onContextMenu","onPlaced","display","flexDirection","outline","items","candidateNodes","reverse","currentElement","currentIndex","indexOf","ITEM_ALIGNED_POSITION_NAME","popperProps","contentContext","contentWrapper","setContentWrapper","shouldExpandOnScrollRef","shouldRepositionRef","triggerRect","getBoundingClientRect","contentRect","valueNodeRect","itemTextRect","itemTextOffset","left","leftDelta","minContentWidth","width","contentWidth","max","rightEdge","innerWidth","clampedLeft","minWidth","right","rightDelta","leftEdge","clampedRight","availableHeight","innerHeight","itemsHeight","contentStyles","getComputedStyle","contentBorderTopWidth","parseInt","borderTopWidth","contentPaddingTop","paddingTop","contentBorderBottomWidth","borderBottomWidth","contentPaddingBottom","paddingBottom","fullContentHeight","minContentHeight","min","offsetHeight","viewportStyles","viewportPaddingTop","viewportPaddingBottom","topEdgeToTriggerMiddle","top","height","triggerMiddleToBottomEdge","selectedItemHalfHeight","itemOffsetMiddle","offsetTop","contentTopToItemMiddle","itemMiddleToContentBottom","willAlignWithoutTopOverflow","isLastItem","bottom","viewportOffsetBottom","clientHeight","clampedTriggerMiddleToBottomEdge","isFirstItem","clampedTopEdgeToTriggerMiddle","margin","minHeight","maxHeight","requestAnimationFrame","contentZIndex","setContentZIndex","zIndex","handleScrollButtonChange","SelectViewportProvider","onScrollButtonChange","div","boxSizing","POPPER_POSITION_NAME","useSelectViewportContext","VIEWPORT_NAME","SelectViewport","nonce","viewportProps","viewportContext","prevScrollTopRef","dangerouslySetInnerHTML","__html","flex","overflow","onScroll","scrolledBy","cssMinHeight","parseFloat","cssHeight","prevHeight","nextHeight","clampedNextHeight","heightDiff","justifyContent","GROUP_NAME","SelectGroupContextProvider","useSelectGroupContext","SelectGroup","groupProps","groupId","LABEL_NAME","SelectLabel","labelProps","groupContext","ITEM_NAME","SelectItemContextProvider","useSelectItemContext","SelectItem","textValue","textValueProp","itemProps","isSelected","setTextValue","isFocused","setIsFocused","textId","handleSelect","Error","onItemTextChange","prevTextValue","textContent","trim","ItemSlot","onFocus","onBlur","onPointerUp","onPointerMove","onPointerLeave","ITEM_TEXT_NAME","SelectItemText","itemTextProps","itemContext","nativeOptionsContext","itemTextNode","setItemTextNode","nativeOption","ITEM_INDICATOR_NAME","SelectItemIndicator","itemIndicatorProps","SCROLL_UP_BUTTON_NAME","SelectScrollUpButton","canScrollUp","setCanScrollUp","handleScroll","SelectScrollButtonImpl","onAutoScroll","SCROLL_DOWN_BUTTON_NAME","SelectScrollDownButton","canScrollDown","setCanScrollDown","maxScroll","ceil","scrollIndicatorProps","autoScrollTimerRef","clearAutoScrollTimer","clearInterval","activeItem","flexShrink","setInterval","SEPARATOR_NAME","SelectSeparator","separatorProps","ARROW_NAME","SelectArrow","arrowProps","selectProps","prevValue","select","selectProto","HTMLSelectElement","prototype","descriptor","Object","getOwnPropertyDescriptor","set","Event","bubbles","call","dispatchEvent","onSearchChange","handleSearchChange","timerRef","updateSearch","clearTimeout","isRepeated","every","char","normalizedSearch","currentItemIndex","wrappedItems","wrapArray","excludeCurrentItem","v","toLowerCase","startsWith","array","startIndex","_","index","Root","Trigger","Value","Icon","Content","Viewport","Group","Label","Item","ItemText","ItemIndicator","ScrollUpButton","ScrollDownButton","Separator","Arrow"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-select/src/Select.tsx"],"sourcesContent":["import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { clamp } from '@radix-ui/number';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { useId } from '@radix-ui/react-id';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { Slot } from '@radix-ui/react-slot';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\nimport { hideOthers } from 'aria-hidden';\nimport { RemoveScroll } from 'react-remove-scroll';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst OPEN_KEYS = [' ', 'Enter', 'ArrowUp', 'ArrowDown'];\nconst SELECTION_KEYS = [' ', 'Enter'];\n\n/* -------------------------------------------------------------------------------------------------\n * Select\n * -----------------------------------------------------------------------------------------------*/\n\nconst SELECT_NAME = 'Select';\n\ntype ItemData = { value: string; disabled: boolean; textValue: string };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  SelectItemElement,\n  ItemData\n>(SELECT_NAME);\n\ntype ScopedProps<P> = P & { __scopeSelect?: Scope };\nconst [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [\n  createCollectionScope,\n  createPopperScope,\n]);\nconst usePopperScope = createPopperScope();\n\ntype SelectContextValue = {\n  trigger: SelectTriggerElement | null;\n  onTriggerChange(node: SelectTriggerElement | null): void;\n  valueNode: SelectValueElement | null;\n  onValueNodeChange(node: SelectValueElement): void;\n  valueNodeHasChildren: boolean;\n  onValueNodeHasChildrenChange(hasChildren: boolean): void;\n  contentId: string;\n  value?: string;\n  onValueChange(value: string): void;\n  open: boolean;\n  required?: boolean;\n  onOpenChange(open: boolean): void;\n  dir: SelectProps['dir'];\n  triggerPointerDownPosRef: React.MutableRefObject<{ x: number; y: number } | null>;\n  disabled?: boolean;\n};\n\nconst [SelectProvider, useSelectContext] = createSelectContext<SelectContextValue>(SELECT_NAME);\n\ntype NativeOption = React.ReactElement<React.ComponentProps<'option'>>;\n\ntype SelectNativeOptionsContextValue = {\n  onNativeOptionAdd(option: NativeOption): void;\n  onNativeOptionRemove(option: NativeOption): void;\n};\nconst [SelectNativeOptionsProvider, useSelectNativeOptionsContext] =\n  createSelectContext<SelectNativeOptionsContextValue>(SELECT_NAME);\n\ninterface SelectProps {\n  children?: React.ReactNode;\n  value?: string;\n  defaultValue?: string;\n  onValueChange?(value: string): void;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  dir?: Direction;\n  name?: string;\n  autoComplete?: string;\n  disabled?: boolean;\n  required?: boolean;\n  form?: string;\n}\n\nconst Select: React.FC<SelectProps> = (props: ScopedProps<SelectProps>) => {\n  const {\n    __scopeSelect,\n    children,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    value: valueProp,\n    defaultValue,\n    onValueChange,\n    dir,\n    name,\n    autoComplete,\n    disabled,\n    required,\n    form,\n  } = props;\n  const popperScope = usePopperScope(__scopeSelect);\n  const [trigger, setTrigger] = React.useState<SelectTriggerElement | null>(null);\n  const [valueNode, setValueNode] = React.useState<SelectValueElement | null>(null);\n  const [valueNodeHasChildren, setValueNodeHasChildren] = React.useState(false);\n  const direction = useDirection(dir);\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange,\n  });\n  const [value, setValue] = useControllableState({\n    prop: valueProp,\n    defaultProp: defaultValue,\n    onChange: onValueChange,\n  });\n  const triggerPointerDownPosRef = React.useRef<{ x: number; y: number } | null>(null);\n\n  // We set this to true by default so that events bubble to forms without JS (SSR)\n  const isFormControl = trigger ? form || !!trigger.closest('form') : true;\n  const [nativeOptionsSet, setNativeOptionsSet] = React.useState(new Set<NativeOption>());\n\n  // The native `select` only associates the correct default value if the corresponding\n  // `option` is rendered as a child **at the same time** as itself.\n  // Because it might take a few renders for our items to gather the information to build\n  // the native `option`(s), we generate a key on the `select` to make sure React re-builds it\n  // each time the options change.\n  const nativeSelectKey = Array.from(nativeOptionsSet)\n    .map((option) => option.props.value)\n    .join(';');\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <SelectProvider\n        required={required}\n        scope={__scopeSelect}\n        trigger={trigger}\n        onTriggerChange={setTrigger}\n        valueNode={valueNode}\n        onValueNodeChange={setValueNode}\n        valueNodeHasChildren={valueNodeHasChildren}\n        onValueNodeHasChildrenChange={setValueNodeHasChildren}\n        contentId={useId()}\n        value={value}\n        onValueChange={setValue}\n        open={open}\n        onOpenChange={setOpen}\n        dir={direction}\n        triggerPointerDownPosRef={triggerPointerDownPosRef}\n        disabled={disabled}\n      >\n        <Collection.Provider scope={__scopeSelect}>\n          <SelectNativeOptionsProvider\n            scope={props.__scopeSelect}\n            onNativeOptionAdd={React.useCallback((option) => {\n              setNativeOptionsSet((prev) => new Set(prev).add(option));\n            }, [])}\n            onNativeOptionRemove={React.useCallback((option) => {\n              setNativeOptionsSet((prev) => {\n                const optionsSet = new Set(prev);\n                optionsSet.delete(option);\n                return optionsSet;\n              });\n            }, [])}\n          >\n            {children}\n          </SelectNativeOptionsProvider>\n        </Collection.Provider>\n\n        {isFormControl ? (\n          <BubbleSelect\n            key={nativeSelectKey}\n            aria-hidden\n            required={required}\n            tabIndex={-1}\n            name={name}\n            autoComplete={autoComplete}\n            value={value}\n            // enable form autofill\n            onChange={(event) => setValue(event.target.value)}\n            disabled={disabled}\n            form={form}\n          >\n            {value === undefined ? <option value=\"\" /> : null}\n            {Array.from(nativeOptionsSet)}\n          </BubbleSelect>\n        ) : null}\n      </SelectProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nSelect.displayName = SELECT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'SelectTrigger';\n\ntype SelectTriggerElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface SelectTriggerProps extends PrimitiveButtonProps {}\n\nconst SelectTrigger = React.forwardRef<SelectTriggerElement, SelectTriggerProps>(\n  (props: ScopedProps<SelectTriggerProps>, forwardedRef) => {\n    const { __scopeSelect, disabled = false, ...triggerProps } = props;\n    const popperScope = usePopperScope(__scopeSelect);\n    const context = useSelectContext(TRIGGER_NAME, __scopeSelect);\n    const isDisabled = context.disabled || disabled;\n    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);\n    const getItems = useCollection(__scopeSelect);\n    const pointerTypeRef = React.useRef<React.PointerEvent['pointerType']>('touch');\n\n    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {\n      const enabledItems = getItems().filter((item) => !item.disabled);\n      const currentItem = enabledItems.find((item) => item.value === context.value);\n      const nextItem = findNextItem(enabledItems, search, currentItem);\n      if (nextItem !== undefined) {\n        context.onValueChange(nextItem.value);\n      }\n    });\n\n    const handleOpen = (pointerEvent?: React.MouseEvent | React.PointerEvent) => {\n      if (!isDisabled) {\n        context.onOpenChange(true);\n        // reset typeahead when we open\n        resetTypeahead();\n      }\n\n      if (pointerEvent) {\n        context.triggerPointerDownPosRef.current = {\n          x: Math.round(pointerEvent.pageX),\n          y: Math.round(pointerEvent.pageY),\n        };\n      }\n    };\n\n    return (\n      <PopperPrimitive.Anchor asChild {...popperScope}>\n        <Primitive.button\n          type=\"button\"\n          role=\"combobox\"\n          aria-controls={context.contentId}\n          aria-expanded={context.open}\n          aria-required={context.required}\n          aria-autocomplete=\"none\"\n          dir={context.dir}\n          data-state={context.open ? 'open' : 'closed'}\n          disabled={isDisabled}\n          data-disabled={isDisabled ? '' : undefined}\n          data-placeholder={shouldShowPlaceholder(context.value) ? '' : undefined}\n          {...triggerProps}\n          ref={composedRefs}\n          // Enable compatibility with native label or custom `Label` \"click\" for Safari:\n          onClick={composeEventHandlers(triggerProps.onClick, (event) => {\n            // Whilst browsers generally have no issue focusing the trigger when clicking\n            // on a label, Safari seems to struggle with the fact that there's no `onClick`.\n            // We force `focus` in this case. Note: this doesn't create any other side-effect\n            // because we are preventing default in `onPointerDown` so effectively\n            // this only runs for a label \"click\"\n            event.currentTarget.focus();\n\n            // Open on click when using a touch or pen device\n            if (pointerTypeRef.current !== 'mouse') {\n              handleOpen(event);\n            }\n          })}\n          onPointerDown={composeEventHandlers(triggerProps.onPointerDown, (event) => {\n            pointerTypeRef.current = event.pointerType;\n\n            // prevent implicit pointer capture\n            // https://www.w3.org/TR/pointerevents3/#implicit-pointer-capture\n            const target = event.target as HTMLElement;\n            if (target.hasPointerCapture(event.pointerId)) {\n              target.releasePointerCapture(event.pointerId);\n            }\n\n            // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)\n            // but not when the control key is pressed (avoiding MacOS right click); also not for touch\n            // devices because that would open the menu on scroll. (pen devices behave as touch on iOS).\n            if (event.button === 0 && event.ctrlKey === false && event.pointerType === 'mouse') {\n              handleOpen(event);\n              // prevent trigger from stealing focus from the active item after opening.\n              event.preventDefault();\n            }\n          })}\n          onKeyDown={composeEventHandlers(triggerProps.onKeyDown, (event) => {\n            const isTypingAhead = searchRef.current !== '';\n            const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n            if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);\n            if (isTypingAhead && event.key === ' ') return;\n            if (OPEN_KEYS.includes(event.key)) {\n              handleOpen();\n              event.preventDefault();\n            }\n          })}\n        />\n      </PopperPrimitive.Anchor>\n    );\n  }\n);\n\nSelectTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectValue\n * -----------------------------------------------------------------------------------------------*/\n\nconst VALUE_NAME = 'SelectValue';\n\ntype SelectValueElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface SelectValueProps extends Omit<PrimitiveSpanProps, 'placeholder'> {\n  placeholder?: React.ReactNode;\n}\n\nconst SelectValue = React.forwardRef<SelectValueElement, SelectValueProps>(\n  (props: ScopedProps<SelectValueProps>, forwardedRef) => {\n    // We ignore `className` and `style` as this part shouldn't be styled.\n    const { __scopeSelect, className, style, children, placeholder = '', ...valueProps } = props;\n    const context = useSelectContext(VALUE_NAME, __scopeSelect);\n    const { onValueNodeHasChildrenChange } = context;\n    const hasChildren = children !== undefined;\n    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);\n\n    useLayoutEffect(() => {\n      onValueNodeHasChildrenChange(hasChildren);\n    }, [onValueNodeHasChildrenChange, hasChildren]);\n\n    return (\n      <Primitive.span\n        {...valueProps}\n        ref={composedRefs}\n        // we don't want events from the portalled `SelectValue` children to bubble\n        // through the item they came from\n        style={{ pointerEvents: 'none' }}\n      >\n        {shouldShowPlaceholder(context.value) ? <>{placeholder}</> : children}\n      </Primitive.span>\n    );\n  }\n);\n\nSelectValue.displayName = VALUE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectIcon\n * -----------------------------------------------------------------------------------------------*/\n\nconst ICON_NAME = 'SelectIcon';\n\ntype SelectIconElement = React.ElementRef<typeof Primitive.span>;\ninterface SelectIconProps extends PrimitiveSpanProps {}\n\nconst SelectIcon = React.forwardRef<SelectIconElement, SelectIconProps>(\n  (props: ScopedProps<SelectIconProps>, forwardedRef) => {\n    const { __scopeSelect, children, ...iconProps } = props;\n    return (\n      <Primitive.span aria-hidden {...iconProps} ref={forwardedRef}>\n        {children || ''}\n      </Primitive.span>\n    );\n  }\n);\n\nSelectIcon.displayName = ICON_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'SelectPortal';\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface SelectPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n}\n\nconst SelectPortal: React.FC<SelectPortalProps> = (props: ScopedProps<SelectPortalProps>) => {\n  return <PortalPrimitive asChild {...props} />;\n};\n\nSelectPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'SelectContent';\n\ntype SelectContentElement = SelectContentImplElement;\ninterface SelectContentProps extends SelectContentImplProps {}\n\nconst SelectContent = React.forwardRef<SelectContentElement, SelectContentProps>(\n  (props: ScopedProps<SelectContentProps>, forwardedRef) => {\n    const context = useSelectContext(CONTENT_NAME, props.__scopeSelect);\n    const [fragment, setFragment] = React.useState<DocumentFragment>();\n\n    // setting the fragment in `useLayoutEffect` as `DocumentFragment` doesn't exist on the server\n    useLayoutEffect(() => {\n      setFragment(new DocumentFragment());\n    }, []);\n\n    if (!context.open) {\n      const frag = fragment as Element | undefined;\n      return frag\n        ? ReactDOM.createPortal(\n            <SelectContentProvider scope={props.__scopeSelect}>\n              <Collection.Slot scope={props.__scopeSelect}>\n                <div>{props.children}</div>\n              </Collection.Slot>\n            </SelectContentProvider>,\n            frag\n          )\n        : null;\n    }\n\n    return <SelectContentImpl {...props} ref={forwardedRef} />;\n  }\n);\n\nSelectContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectContentImpl\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_MARGIN = 10;\n\ntype SelectContentContextValue = {\n  content?: SelectContentElement | null;\n  viewport?: SelectViewportElement | null;\n  onViewportChange?: (node: SelectViewportElement | null) => void;\n  itemRefCallback?: (node: SelectItemElement | null, value: string, disabled: boolean) => void;\n  selectedItem?: SelectItemElement | null;\n  onItemLeave?: () => void;\n  itemTextRefCallback?: (\n    node: SelectItemTextElement | null,\n    value: string,\n    disabled: boolean\n  ) => void;\n  focusSelectedItem?: () => void;\n  selectedItemText?: SelectItemTextElement | null;\n  position?: SelectContentProps['position'];\n  isPositioned?: boolean;\n  searchRef?: React.RefObject<string>;\n};\n\nconst [SelectContentProvider, useSelectContentContext] =\n  createSelectContext<SelectContentContextValue>(CONTENT_NAME);\n\nconst CONTENT_IMPL_NAME = 'SelectContentImpl';\n\ntype SelectContentImplElement = SelectPopperPositionElement | SelectItemAlignedPositionElement;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype FocusScopeProps = React.ComponentPropsWithoutRef<typeof FocusScope>;\n\ntype SelectPopperPrivateProps = { onPlaced?: PopperContentProps['onPlaced'] };\n\ninterface SelectContentImplProps\n  extends Omit<SelectPopperPositionProps, keyof SelectPopperPrivateProps>,\n    Omit<SelectItemAlignedPositionProps, keyof SelectPopperPrivateProps> {\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n\n  position?: 'item-aligned' | 'popper';\n}\n\nconst SelectContentImpl = React.forwardRef<SelectContentImplElement, SelectContentImplProps>(\n  (props: ScopedProps<SelectContentImplProps>, forwardedRef) => {\n    const {\n      __scopeSelect,\n      position = 'item-aligned',\n      onCloseAutoFocus,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      //\n      // PopperContent props\n      side,\n      sideOffset,\n      align,\n      alignOffset,\n      arrowPadding,\n      collisionBoundary,\n      collisionPadding,\n      sticky,\n      hideWhenDetached,\n      avoidCollisions,\n      //\n      ...contentProps\n    } = props;\n    const context = useSelectContext(CONTENT_NAME, __scopeSelect);\n    const [content, setContent] = React.useState<SelectContentImplElement | null>(null);\n    const [viewport, setViewport] = React.useState<SelectViewportElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n    const [selectedItem, setSelectedItem] = React.useState<SelectItemElement | null>(null);\n    const [selectedItemText, setSelectedItemText] = React.useState<SelectItemTextElement | null>(\n      null\n    );\n    const getItems = useCollection(__scopeSelect);\n    const [isPositioned, setIsPositioned] = React.useState(false);\n    const firstValidItemFoundRef = React.useRef(false);\n\n    // aria-hide everything except the content (better supported equivalent to setting aria-modal)\n    React.useEffect(() => {\n      if (content) return hideOthers(content);\n    }, [content]);\n\n    // Make sure the whole tree has focus guards as our `Select` may be\n    // the last element in the DOM (because of the `Portal`)\n    useFocusGuards();\n\n    const focusFirst = React.useCallback(\n      (candidates: Array<HTMLElement | null>) => {\n        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);\n        const [lastItem] = restItems.slice(-1);\n\n        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n        for (const candidate of candidates) {\n          // if focus is already where we want to go, we don't want to keep going through the candidates\n          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n          candidate?.scrollIntoView({ block: 'nearest' });\n          // viewport might have padding so scroll to its edges when focusing first/last items.\n          if (candidate === firstItem && viewport) viewport.scrollTop = 0;\n          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;\n          candidate?.focus();\n          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n        }\n      },\n      [getItems, viewport]\n    );\n\n    const focusSelectedItem = React.useCallback(\n      () => focusFirst([selectedItem, content]),\n      [focusFirst, selectedItem, content]\n    );\n\n    // Since this is not dependent on layout, we want to ensure this runs at the same time as\n    // other effects across components. Hence why we don't call `focusSelectedItem` inside `position`.\n    React.useEffect(() => {\n      if (isPositioned) {\n        focusSelectedItem();\n      }\n    }, [isPositioned, focusSelectedItem]);\n\n    // prevent selecting items on `pointerup` in some cases after opening from `pointerdown`\n    // and close on `pointerup` outside.\n    const { onOpenChange, triggerPointerDownPosRef } = context;\n    React.useEffect(() => {\n      if (content) {\n        let pointerMoveDelta = { x: 0, y: 0 };\n\n        const handlePointerMove = (event: PointerEvent) => {\n          pointerMoveDelta = {\n            x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),\n            y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0)),\n          };\n        };\n        const handlePointerUp = (event: PointerEvent) => {\n          // If the pointer hasn't moved by a certain threshold then we prevent selecting item on `pointerup`.\n          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {\n            event.preventDefault();\n          } else {\n            // otherwise, if the event was outside the content, close.\n            if (!content.contains(event.target as HTMLElement)) {\n              onOpenChange(false);\n            }\n          }\n          document.removeEventListener('pointermove', handlePointerMove);\n          triggerPointerDownPosRef.current = null;\n        };\n\n        if (triggerPointerDownPosRef.current !== null) {\n          document.addEventListener('pointermove', handlePointerMove);\n          document.addEventListener('pointerup', handlePointerUp, { capture: true, once: true });\n        }\n\n        return () => {\n          document.removeEventListener('pointermove', handlePointerMove);\n          document.removeEventListener('pointerup', handlePointerUp, { capture: true });\n        };\n      }\n    }, [content, onOpenChange, triggerPointerDownPosRef]);\n\n    React.useEffect(() => {\n      const close = () => onOpenChange(false);\n      window.addEventListener('blur', close);\n      window.addEventListener('resize', close);\n      return () => {\n        window.removeEventListener('blur', close);\n        window.removeEventListener('resize', close);\n      };\n    }, [onOpenChange]);\n\n    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {\n      const enabledItems = getItems().filter((item) => !item.disabled);\n      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);\n      const nextItem = findNextItem(enabledItems, search, currentItem);\n      if (nextItem) {\n        /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */\n        setTimeout(() => (nextItem.ref.current as HTMLElement).focus());\n      }\n    });\n\n    const itemRefCallback = React.useCallback(\n      (node: SelectItemElement | null, value: string, disabled: boolean) => {\n        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;\n        const isSelectedItem = context.value !== undefined && context.value === value;\n        if (isSelectedItem || isFirstValidItem) {\n          setSelectedItem(node);\n          if (isFirstValidItem) firstValidItemFoundRef.current = true;\n        }\n      },\n      [context.value]\n    );\n    const handleItemLeave = React.useCallback(() => content?.focus(), [content]);\n    const itemTextRefCallback = React.useCallback(\n      (node: SelectItemTextElement | null, value: string, disabled: boolean) => {\n        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;\n        const isSelectedItem = context.value !== undefined && context.value === value;\n        if (isSelectedItem || isFirstValidItem) {\n          setSelectedItemText(node);\n        }\n      },\n      [context.value]\n    );\n\n    const SelectPosition = position === 'popper' ? SelectPopperPosition : SelectItemAlignedPosition;\n\n    // Silently ignore props that are not supported by `SelectItemAlignedPosition`\n    const popperContentProps =\n      SelectPosition === SelectPopperPosition\n        ? {\n            side,\n            sideOffset,\n            align,\n            alignOffset,\n            arrowPadding,\n            collisionBoundary,\n            collisionPadding,\n            sticky,\n            hideWhenDetached,\n            avoidCollisions,\n          }\n        : {};\n\n    return (\n      <SelectContentProvider\n        scope={__scopeSelect}\n        content={content}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        itemRefCallback={itemRefCallback}\n        selectedItem={selectedItem}\n        onItemLeave={handleItemLeave}\n        itemTextRefCallback={itemTextRefCallback}\n        focusSelectedItem={focusSelectedItem}\n        selectedItemText={selectedItemText}\n        position={position}\n        isPositioned={isPositioned}\n        searchRef={searchRef}\n      >\n        <RemoveScroll as={Slot} allowPinchZoom>\n          <FocusScope\n            asChild\n            // we make sure we're not trapping once it's been closed\n            // (closed !== unmounted when animating out)\n            trapped={context.open}\n            onMountAutoFocus={(event) => {\n              // we prevent open autofocus because we manually focus the selected item\n              event.preventDefault();\n            }}\n            onUnmountAutoFocus={composeEventHandlers(onCloseAutoFocus, (event) => {\n              context.trigger?.focus({ preventScroll: true });\n              event.preventDefault();\n            })}\n          >\n            <DismissableLayer\n              asChild\n              disableOutsidePointerEvents\n              onEscapeKeyDown={onEscapeKeyDown}\n              onPointerDownOutside={onPointerDownOutside}\n              // When focus is trapped, a focusout event may still happen.\n              // We make sure we don't trigger our `onDismiss` in such case.\n              onFocusOutside={(event) => event.preventDefault()}\n              onDismiss={() => context.onOpenChange(false)}\n            >\n              <SelectPosition\n                role=\"listbox\"\n                id={context.contentId}\n                data-state={context.open ? 'open' : 'closed'}\n                dir={context.dir}\n                onContextMenu={(event) => event.preventDefault()}\n                {...contentProps}\n                {...popperContentProps}\n                onPlaced={() => setIsPositioned(true)}\n                ref={composedRefs}\n                style={{\n                  // flex layout so we can place the scroll buttons properly\n                  display: 'flex',\n                  flexDirection: 'column',\n                  // reset the outline by default as the content MAY get focused\n                  outline: 'none',\n                  ...contentProps.style,\n                }}\n                onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                  const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n\n                  // select should not be navigated using tab key so we prevent it\n                  if (event.key === 'Tab') event.preventDefault();\n\n                  if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);\n\n                  if (['ArrowUp', 'ArrowDown', 'Home', 'End'].includes(event.key)) {\n                    const items = getItems().filter((item) => !item.disabled);\n                    let candidateNodes = items.map((item) => item.ref.current!);\n\n                    if (['ArrowUp', 'End'].includes(event.key)) {\n                      candidateNodes = candidateNodes.slice().reverse();\n                    }\n                    if (['ArrowUp', 'ArrowDown'].includes(event.key)) {\n                      const currentElement = event.target as SelectItemElement;\n                      const currentIndex = candidateNodes.indexOf(currentElement);\n                      candidateNodes = candidateNodes.slice(currentIndex + 1);\n                    }\n\n                    /**\n                     * Imperative focus during keydown is risky so we prevent React's batching updates\n                     * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n                     */\n                    setTimeout(() => focusFirst(candidateNodes));\n\n                    event.preventDefault();\n                  }\n                })}\n              />\n            </DismissableLayer>\n          </FocusScope>\n        </RemoveScroll>\n      </SelectContentProvider>\n    );\n  }\n);\n\nSelectContentImpl.displayName = CONTENT_IMPL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectItemAlignedPosition\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_ALIGNED_POSITION_NAME = 'SelectItemAlignedPosition';\n\ntype SelectItemAlignedPositionElement = React.ElementRef<typeof Primitive.div>;\ninterface SelectItemAlignedPositionProps extends PrimitiveDivProps, SelectPopperPrivateProps {}\n\nconst SelectItemAlignedPosition = React.forwardRef<\n  SelectItemAlignedPositionElement,\n  SelectItemAlignedPositionProps\n>((props: ScopedProps<SelectItemAlignedPositionProps>, forwardedRef) => {\n  const { __scopeSelect, onPlaced, ...popperProps } = props;\n  const context = useSelectContext(CONTENT_NAME, __scopeSelect);\n  const contentContext = useSelectContentContext(CONTENT_NAME, __scopeSelect);\n  const [contentWrapper, setContentWrapper] = React.useState<HTMLDivElement | null>(null);\n  const [content, setContent] = React.useState<SelectItemAlignedPositionElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n  const getItems = useCollection(__scopeSelect);\n  const shouldExpandOnScrollRef = React.useRef(false);\n  const shouldRepositionRef = React.useRef(true);\n\n  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;\n  const position = React.useCallback(() => {\n    if (\n      context.trigger &&\n      context.valueNode &&\n      contentWrapper &&\n      content &&\n      viewport &&\n      selectedItem &&\n      selectedItemText\n    ) {\n      const triggerRect = context.trigger.getBoundingClientRect();\n\n      // -----------------------------------------------------------------------------------------\n      //  Horizontal positioning\n      // -----------------------------------------------------------------------------------------\n      const contentRect = content.getBoundingClientRect();\n      const valueNodeRect = context.valueNode.getBoundingClientRect();\n      const itemTextRect = selectedItemText.getBoundingClientRect();\n\n      if (context.dir !== 'rtl') {\n        const itemTextOffset = itemTextRect.left - contentRect.left;\n        const left = valueNodeRect.left - itemTextOffset;\n        const leftDelta = triggerRect.left - left;\n        const minContentWidth = triggerRect.width + leftDelta;\n        const contentWidth = Math.max(minContentWidth, contentRect.width);\n        const rightEdge = window.innerWidth - CONTENT_MARGIN;\n        const clampedLeft = clamp(left, [\n          CONTENT_MARGIN,\n          // Prevents the content from going off the starting edge of the\n          // viewport. It may still go off the ending edge, but this can be\n          // controlled by the user since they may want to manage overflow in a\n          // specific way.\n          // https://github.com/radix-ui/primitives/issues/2049\n          Math.max(CONTENT_MARGIN, rightEdge - contentWidth),\n        ]);\n\n        contentWrapper.style.minWidth = minContentWidth + 'px';\n        contentWrapper.style.left = clampedLeft + 'px';\n      } else {\n        const itemTextOffset = contentRect.right - itemTextRect.right;\n        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;\n        const rightDelta = window.innerWidth - triggerRect.right - right;\n        const minContentWidth = triggerRect.width + rightDelta;\n        const contentWidth = Math.max(minContentWidth, contentRect.width);\n        const leftEdge = window.innerWidth - CONTENT_MARGIN;\n        const clampedRight = clamp(right, [\n          CONTENT_MARGIN,\n          Math.max(CONTENT_MARGIN, leftEdge - contentWidth),\n        ]);\n\n        contentWrapper.style.minWidth = minContentWidth + 'px';\n        contentWrapper.style.right = clampedRight + 'px';\n      }\n\n      // -----------------------------------------------------------------------------------------\n      // Vertical positioning\n      // -----------------------------------------------------------------------------------------\n      const items = getItems();\n      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;\n      const itemsHeight = viewport.scrollHeight;\n\n      const contentStyles = window.getComputedStyle(content);\n      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);\n      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);\n      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);\n      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);\n      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth; // prettier-ignore\n      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);\n\n      const viewportStyles = window.getComputedStyle(viewport);\n      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);\n      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);\n\n      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;\n      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;\n\n      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;\n      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;\n      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;\n      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;\n\n      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;\n\n      if (willAlignWithoutTopOverflow) {\n        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;\n        contentWrapper.style.bottom = 0 + 'px';\n        const viewportOffsetBottom =\n          content.clientHeight - viewport.offsetTop - viewport.offsetHeight;\n        const clampedTriggerMiddleToBottomEdge = Math.max(\n          triggerMiddleToBottomEdge,\n          selectedItemHalfHeight +\n            // viewport might have padding bottom, include it to avoid a scrollable viewport\n            (isLastItem ? viewportPaddingBottom : 0) +\n            viewportOffsetBottom +\n            contentBorderBottomWidth\n        );\n        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;\n        contentWrapper.style.height = height + 'px';\n      } else {\n        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;\n        contentWrapper.style.top = 0 + 'px';\n        const clampedTopEdgeToTriggerMiddle = Math.max(\n          topEdgeToTriggerMiddle,\n          contentBorderTopWidth +\n            viewport.offsetTop +\n            // viewport might have padding top, include it to avoid a scrollable viewport\n            (isFirstItem ? viewportPaddingTop : 0) +\n            selectedItemHalfHeight\n        );\n        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;\n        contentWrapper.style.height = height + 'px';\n        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;\n      }\n\n      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;\n      contentWrapper.style.minHeight = minContentHeight + 'px';\n      contentWrapper.style.maxHeight = availableHeight + 'px';\n      // -----------------------------------------------------------------------------------------\n\n      onPlaced?.();\n\n      // we don't want the initial scroll position adjustment to trigger \"expand on scroll\"\n      // so we explicitly turn it on only after they've registered.\n      requestAnimationFrame(() => (shouldExpandOnScrollRef.current = true));\n    }\n  }, [\n    getItems,\n    context.trigger,\n    context.valueNode,\n    contentWrapper,\n    content,\n    viewport,\n    selectedItem,\n    selectedItemText,\n    context.dir,\n    onPlaced,\n  ]);\n\n  useLayoutEffect(() => position(), [position]);\n\n  // copy z-index from content to wrapper\n  const [contentZIndex, setContentZIndex] = React.useState<string>();\n  useLayoutEffect(() => {\n    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n  }, [content]);\n\n  // When the viewport becomes scrollable at the top, the scroll up button will mount.\n  // Because it is part of the normal flow, it will push down the viewport, thus throwing our\n  // trigger => selectedItem alignment off by the amount the viewport was pushed down.\n  // We wait for this to happen and then re-run the positining logic one more time to account for it.\n  const handleScrollButtonChange = React.useCallback(\n    (node: SelectScrollButtonImplElement | null) => {\n      if (node && shouldRepositionRef.current === true) {\n        position();\n        focusSelectedItem?.();\n        shouldRepositionRef.current = false;\n      }\n    },\n    [position, focusSelectedItem]\n  );\n\n  return (\n    <SelectViewportProvider\n      scope={__scopeSelect}\n      contentWrapper={contentWrapper}\n      shouldExpandOnScrollRef={shouldExpandOnScrollRef}\n      onScrollButtonChange={handleScrollButtonChange}\n    >\n      <div\n        ref={setContentWrapper}\n        style={{\n          display: 'flex',\n          flexDirection: 'column',\n          position: 'fixed',\n          zIndex: contentZIndex,\n        }}\n      >\n        <Primitive.div\n          {...popperProps}\n          ref={composedRefs}\n          style={{\n            // When we get the height of the content, it includes borders. If we were to set\n            // the height without having `boxSizing: 'border-box'` it would be too big.\n            boxSizing: 'border-box',\n            // We need to ensure the content doesn't get taller than the wrapper\n            maxHeight: '100%',\n            ...popperProps.style,\n          }}\n        />\n      </div>\n    </SelectViewportProvider>\n  );\n});\n\nSelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectPopperPosition\n * -----------------------------------------------------------------------------------------------*/\n\nconst POPPER_POSITION_NAME = 'SelectPopperPosition';\n\ntype SelectPopperPositionElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype PopperContentProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ninterface SelectPopperPositionProps extends PopperContentProps, SelectPopperPrivateProps {}\n\nconst SelectPopperPosition = React.forwardRef<\n  SelectPopperPositionElement,\n  SelectPopperPositionProps\n>((props: ScopedProps<SelectPopperPositionProps>, forwardedRef) => {\n  const {\n    __scopeSelect,\n    align = 'start',\n    collisionPadding = CONTENT_MARGIN,\n    ...popperProps\n  } = props;\n  const popperScope = usePopperScope(__scopeSelect);\n\n  return (\n    <PopperPrimitive.Content\n      {...popperScope}\n      {...popperProps}\n      ref={forwardedRef}\n      align={align}\n      collisionPadding={collisionPadding}\n      style={{\n        // Ensure border-box for floating-ui calculations\n        boxSizing: 'border-box',\n        ...popperProps.style,\n        // re-namespace exposed content custom properties\n        ...{\n          '--radix-select-content-transform-origin': 'var(--radix-popper-transform-origin)',\n          '--radix-select-content-available-width': 'var(--radix-popper-available-width)',\n          '--radix-select-content-available-height': 'var(--radix-popper-available-height)',\n          '--radix-select-trigger-width': 'var(--radix-popper-anchor-width)',\n          '--radix-select-trigger-height': 'var(--radix-popper-anchor-height)',\n        },\n      }}\n    />\n  );\n});\n\nSelectPopperPosition.displayName = POPPER_POSITION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectViewport\n * -----------------------------------------------------------------------------------------------*/\n\ntype SelectViewportContextValue = {\n  contentWrapper?: HTMLDivElement | null;\n  shouldExpandOnScrollRef?: React.RefObject<boolean>;\n  onScrollButtonChange?: (node: SelectScrollButtonImplElement | null) => void;\n};\n\nconst [SelectViewportProvider, useSelectViewportContext] =\n  createSelectContext<SelectViewportContextValue>(CONTENT_NAME, {});\n\nconst VIEWPORT_NAME = 'SelectViewport';\n\ntype SelectViewportElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface SelectViewportProps extends PrimitiveDivProps {\n  nonce?: string;\n}\n\nconst SelectViewport = React.forwardRef<SelectViewportElement, SelectViewportProps>(\n  (props: ScopedProps<SelectViewportProps>, forwardedRef) => {\n    const { __scopeSelect, nonce, ...viewportProps } = props;\n    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);\n    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);\n    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);\n    const prevScrollTopRef = React.useRef(0);\n    return (\n      <>\n        {/* Hide scrollbars cross-browser and enable momentum scroll for touch devices */}\n        <style\n          dangerouslySetInnerHTML={{\n            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`,\n          }}\n          nonce={nonce}\n        />\n        <Collection.Slot scope={__scopeSelect}>\n          <Primitive.div\n            data-radix-select-viewport=\"\"\n            role=\"presentation\"\n            {...viewportProps}\n            ref={composedRefs}\n            style={{\n              // we use position: 'relative' here on the `viewport` so that when we call\n              // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n              // (independent of the scrollUpButton).\n              position: 'relative',\n              flex: 1,\n              // Viewport should only be scrollable in the vertical direction.\n              // This won't work in vertical writing modes, so we'll need to\n              // revisit this if/when that is supported\n              // https://developer.chrome.com/blog/vertical-form-controls\n              overflow: 'hidden auto',\n              ...viewportProps.style,\n            }}\n            onScroll={composeEventHandlers(viewportProps.onScroll, (event) => {\n              const viewport = event.currentTarget;\n              const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;\n              if (shouldExpandOnScrollRef?.current && contentWrapper) {\n                const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);\n                if (scrolledBy > 0) {\n                  const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;\n                  const cssMinHeight = parseFloat(contentWrapper.style.minHeight);\n                  const cssHeight = parseFloat(contentWrapper.style.height);\n                  const prevHeight = Math.max(cssMinHeight, cssHeight);\n\n                  if (prevHeight < availableHeight) {\n                    const nextHeight = prevHeight + scrolledBy;\n                    const clampedNextHeight = Math.min(availableHeight, nextHeight);\n                    const heightDiff = nextHeight - clampedNextHeight;\n\n                    contentWrapper.style.height = clampedNextHeight + 'px';\n                    if (contentWrapper.style.bottom === '0px') {\n                      viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;\n                      // ensure the content stays pinned to the bottom\n                      contentWrapper.style.justifyContent = 'flex-end';\n                    }\n                  }\n                }\n              }\n              prevScrollTopRef.current = viewport.scrollTop;\n            })}\n          />\n        </Collection.Slot>\n      </>\n    );\n  }\n);\n\nSelectViewport.displayName = VIEWPORT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'SelectGroup';\n\ntype SelectGroupContextValue = { id: string };\n\nconst [SelectGroupContextProvider, useSelectGroupContext] =\n  createSelectContext<SelectGroupContextValue>(GROUP_NAME);\n\ntype SelectGroupElement = React.ElementRef<typeof Primitive.div>;\ninterface SelectGroupProps extends PrimitiveDivProps {}\n\nconst SelectGroup = React.forwardRef<SelectGroupElement, SelectGroupProps>(\n  (props: ScopedProps<SelectGroupProps>, forwardedRef) => {\n    const { __scopeSelect, ...groupProps } = props;\n    const groupId = useId();\n    return (\n      <SelectGroupContextProvider scope={__scopeSelect} id={groupId}>\n        <Primitive.div role=\"group\" aria-labelledby={groupId} {...groupProps} ref={forwardedRef} />\n      </SelectGroupContextProvider>\n    );\n  }\n);\n\nSelectGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'SelectLabel';\n\ntype SelectLabelElement = React.ElementRef<typeof Primitive.div>;\ninterface SelectLabelProps extends PrimitiveDivProps {}\n\nconst SelectLabel = React.forwardRef<SelectLabelElement, SelectLabelProps>(\n  (props: ScopedProps<SelectLabelProps>, forwardedRef) => {\n    const { __scopeSelect, ...labelProps } = props;\n    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);\n    return <Primitive.div id={groupContext.id} {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nSelectLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'SelectItem';\n\ntype SelectItemContextValue = {\n  value: string;\n  disabled: boolean;\n  textId: string;\n  isSelected: boolean;\n  onItemTextChange(node: SelectItemTextElement | null): void;\n};\n\nconst [SelectItemContextProvider, useSelectItemContext] =\n  createSelectContext<SelectItemContextValue>(ITEM_NAME);\n\ntype SelectItemElement = React.ElementRef<typeof Primitive.div>;\ninterface SelectItemProps extends PrimitiveDivProps {\n  value: string;\n  disabled?: boolean;\n  textValue?: string;\n}\n\nconst SelectItem = React.forwardRef<SelectItemElement, SelectItemProps>(\n  (props: ScopedProps<SelectItemProps>, forwardedRef) => {\n    const {\n      __scopeSelect,\n      value,\n      disabled = false,\n      textValue: textValueProp,\n      ...itemProps\n    } = props;\n    const context = useSelectContext(ITEM_NAME, __scopeSelect);\n    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);\n    const isSelected = context.value === value;\n    const [textValue, setTextValue] = React.useState(textValueProp ?? '');\n    const [isFocused, setIsFocused] = React.useState(false);\n    const composedRefs = useComposedRefs(forwardedRef, (node) =>\n      contentContext.itemRefCallback?.(node, value, disabled)\n    );\n    const textId = useId();\n    const pointerTypeRef = React.useRef<React.PointerEvent['pointerType']>('touch');\n\n    const handleSelect = () => {\n      if (!disabled) {\n        context.onValueChange(value);\n        context.onOpenChange(false);\n      }\n    };\n\n    if (value === '') {\n      throw new Error(\n        'A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.'\n      );\n    }\n\n    return (\n      <SelectItemContextProvider\n        scope={__scopeSelect}\n        value={value}\n        disabled={disabled}\n        textId={textId}\n        isSelected={isSelected}\n        onItemTextChange={React.useCallback((node) => {\n          setTextValue((prevTextValue) => prevTextValue || (node?.textContent ?? '').trim());\n        }, [])}\n      >\n        <Collection.ItemSlot\n          scope={__scopeSelect}\n          value={value}\n          disabled={disabled}\n          textValue={textValue}\n        >\n          <Primitive.div\n            role=\"option\"\n            aria-labelledby={textId}\n            data-highlighted={isFocused ? '' : undefined}\n            // `isFocused` caveat fixes stuttering in VoiceOver\n            aria-selected={isSelected && isFocused}\n            data-state={isSelected ? 'checked' : 'unchecked'}\n            aria-disabled={disabled || undefined}\n            data-disabled={disabled ? '' : undefined}\n            tabIndex={disabled ? undefined : -1}\n            {...itemProps}\n            ref={composedRefs}\n            onFocus={composeEventHandlers(itemProps.onFocus, () => setIsFocused(true))}\n            onBlur={composeEventHandlers(itemProps.onBlur, () => setIsFocused(false))}\n            onClick={composeEventHandlers(itemProps.onClick, () => {\n              // Open on click when using a touch or pen device\n              if (pointerTypeRef.current !== 'mouse') handleSelect();\n            })}\n            onPointerUp={composeEventHandlers(itemProps.onPointerUp, () => {\n              // Using a mouse you should be able to do pointer down, move through\n              // the list, and release the pointer over the item to select it.\n              if (pointerTypeRef.current === 'mouse') handleSelect();\n            })}\n            onPointerDown={composeEventHandlers(itemProps.onPointerDown, (event) => {\n              pointerTypeRef.current = event.pointerType;\n            })}\n            onPointerMove={composeEventHandlers(itemProps.onPointerMove, (event) => {\n              // Remember pointer type when sliding over to this item from another one\n              pointerTypeRef.current = event.pointerType;\n              if (disabled) {\n                contentContext.onItemLeave?.();\n              } else if (pointerTypeRef.current === 'mouse') {\n                // even though safari doesn't support this option, it's acceptable\n                // as it only means it might scroll a few pixels when using the pointer.\n                event.currentTarget.focus({ preventScroll: true });\n              }\n            })}\n            onPointerLeave={composeEventHandlers(itemProps.onPointerLeave, (event) => {\n              if (event.currentTarget === document.activeElement) {\n                contentContext.onItemLeave?.();\n              }\n            })}\n            onKeyDown={composeEventHandlers(itemProps.onKeyDown, (event) => {\n              const isTypingAhead = contentContext.searchRef?.current !== '';\n              if (isTypingAhead && event.key === ' ') return;\n              if (SELECTION_KEYS.includes(event.key)) handleSelect();\n              // prevent page scroll if using the space key to select an item\n              if (event.key === ' ') event.preventDefault();\n            })}\n          />\n        </Collection.ItemSlot>\n      </SelectItemContextProvider>\n    );\n  }\n);\n\nSelectItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectItemText\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_TEXT_NAME = 'SelectItemText';\n\ntype SelectItemTextElement = React.ElementRef<typeof Primitive.span>;\ninterface SelectItemTextProps extends PrimitiveSpanProps {}\n\nconst SelectItemText = React.forwardRef<SelectItemTextElement, SelectItemTextProps>(\n  (props: ScopedProps<SelectItemTextProps>, forwardedRef) => {\n    // We ignore `className` and `style` as this part shouldn't be styled.\n    const { __scopeSelect, className, style, ...itemTextProps } = props;\n    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);\n    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);\n    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);\n    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);\n    const [itemTextNode, setItemTextNode] = React.useState<SelectItemTextElement | null>(null);\n    const composedRefs = useComposedRefs(\n      forwardedRef,\n      (node) => setItemTextNode(node),\n      itemContext.onItemTextChange,\n      (node) => contentContext.itemTextRefCallback?.(node, itemContext.value, itemContext.disabled)\n    );\n\n    const textContent = itemTextNode?.textContent;\n    const nativeOption = React.useMemo(\n      () => (\n        <option key={itemContext.value} value={itemContext.value} disabled={itemContext.disabled}>\n          {textContent}\n        </option>\n      ),\n      [itemContext.disabled, itemContext.value, textContent]\n    );\n\n    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;\n    useLayoutEffect(() => {\n      onNativeOptionAdd(nativeOption);\n      return () => onNativeOptionRemove(nativeOption);\n    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);\n\n    return (\n      <>\n        <Primitive.span id={itemContext.textId} {...itemTextProps} ref={composedRefs} />\n\n        {/* Portal the select item text into the trigger value node */}\n        {itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren\n          ? ReactDOM.createPortal(itemTextProps.children, context.valueNode)\n          : null}\n      </>\n    );\n  }\n);\n\nSelectItemText.displayName = ITEM_TEXT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'SelectItemIndicator';\n\ntype SelectItemIndicatorElement = React.ElementRef<typeof Primitive.span>;\ninterface SelectItemIndicatorProps extends PrimitiveSpanProps {}\n\nconst SelectItemIndicator = React.forwardRef<SelectItemIndicatorElement, SelectItemIndicatorProps>(\n  (props: ScopedProps<SelectItemIndicatorProps>, forwardedRef) => {\n    const { __scopeSelect, ...itemIndicatorProps } = props;\n    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);\n    return itemContext.isSelected ? (\n      <Primitive.span aria-hidden {...itemIndicatorProps} ref={forwardedRef} />\n    ) : null;\n  }\n);\n\nSelectItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectScrollUpButton\n * -----------------------------------------------------------------------------------------------*/\n\nconst SCROLL_UP_BUTTON_NAME = 'SelectScrollUpButton';\n\ntype SelectScrollUpButtonElement = SelectScrollButtonImplElement;\ninterface SelectScrollUpButtonProps extends Omit<SelectScrollButtonImplProps, 'onAutoScroll'> {}\n\nconst SelectScrollUpButton = React.forwardRef<\n  SelectScrollUpButtonElement,\n  SelectScrollUpButtonProps\n>((props: ScopedProps<SelectScrollUpButtonProps>, forwardedRef) => {\n  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);\n  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);\n  const [canScrollUp, setCanScrollUp] = React.useState(false);\n  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);\n\n  useLayoutEffect(() => {\n    if (contentContext.viewport && contentContext.isPositioned) {\n      const viewport = contentContext.viewport;\n      function handleScroll() {\n        const canScrollUp = viewport.scrollTop > 0;\n        setCanScrollUp(canScrollUp);\n      }\n      handleScroll();\n      viewport.addEventListener('scroll', handleScroll);\n      return () => viewport.removeEventListener('scroll', handleScroll);\n    }\n  }, [contentContext.viewport, contentContext.isPositioned]);\n\n  return canScrollUp ? (\n    <SelectScrollButtonImpl\n      {...props}\n      ref={composedRefs}\n      onAutoScroll={() => {\n        const { viewport, selectedItem } = contentContext;\n        if (viewport && selectedItem) {\n          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;\n        }\n      }}\n    />\n  ) : null;\n});\n\nSelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectScrollDownButton\n * -----------------------------------------------------------------------------------------------*/\n\nconst SCROLL_DOWN_BUTTON_NAME = 'SelectScrollDownButton';\n\ntype SelectScrollDownButtonElement = SelectScrollButtonImplElement;\ninterface SelectScrollDownButtonProps extends Omit<SelectScrollButtonImplProps, 'onAutoScroll'> {}\n\nconst SelectScrollDownButton = React.forwardRef<\n  SelectScrollDownButtonElement,\n  SelectScrollDownButtonProps\n>((props: ScopedProps<SelectScrollDownButtonProps>, forwardedRef) => {\n  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);\n  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);\n  const [canScrollDown, setCanScrollDown] = React.useState(false);\n  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);\n\n  useLayoutEffect(() => {\n    if (contentContext.viewport && contentContext.isPositioned) {\n      const viewport = contentContext.viewport;\n      function handleScroll() {\n        const maxScroll = viewport.scrollHeight - viewport.clientHeight;\n        // we use Math.ceil here because if the UI is zoomed-in\n        // `scrollTop` is not always reported as an integer\n        const canScrollDown = Math.ceil(viewport.scrollTop) < maxScroll;\n        setCanScrollDown(canScrollDown);\n      }\n      handleScroll();\n      viewport.addEventListener('scroll', handleScroll);\n      return () => viewport.removeEventListener('scroll', handleScroll);\n    }\n  }, [contentContext.viewport, contentContext.isPositioned]);\n\n  return canScrollDown ? (\n    <SelectScrollButtonImpl\n      {...props}\n      ref={composedRefs}\n      onAutoScroll={() => {\n        const { viewport, selectedItem } = contentContext;\n        if (viewport && selectedItem) {\n          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;\n        }\n      }}\n    />\n  ) : null;\n});\n\nSelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;\n\ntype SelectScrollButtonImplElement = React.ElementRef<typeof Primitive.div>;\ninterface SelectScrollButtonImplProps extends PrimitiveDivProps {\n  onAutoScroll(): void;\n}\n\nconst SelectScrollButtonImpl = React.forwardRef<\n  SelectScrollButtonImplElement,\n  SelectScrollButtonImplProps\n>((props: ScopedProps<SelectScrollButtonImplProps>, forwardedRef) => {\n  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;\n  const contentContext = useSelectContentContext('SelectScrollButton', __scopeSelect);\n  const autoScrollTimerRef = React.useRef<number | null>(null);\n  const getItems = useCollection(__scopeSelect);\n\n  const clearAutoScrollTimer = React.useCallback(() => {\n    if (autoScrollTimerRef.current !== null) {\n      window.clearInterval(autoScrollTimerRef.current);\n      autoScrollTimerRef.current = null;\n    }\n  }, []);\n\n  React.useEffect(() => {\n    return () => clearAutoScrollTimer();\n  }, [clearAutoScrollTimer]);\n\n  // When the viewport becomes scrollable on either side, the relevant scroll button will mount.\n  // Because it is part of the normal flow, it will push down (top button) or shrink (bottom button)\n  // the viewport, potentially causing the active item to now be partially out of view.\n  // We re-run the `scrollIntoView` logic to make sure it stays within the viewport.\n  useLayoutEffect(() => {\n    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);\n    activeItem?.ref.current?.scrollIntoView({ block: 'nearest' });\n  }, [getItems]);\n\n  return (\n    <Primitive.div\n      aria-hidden\n      {...scrollIndicatorProps}\n      ref={forwardedRef}\n      style={{ flexShrink: 0, ...scrollIndicatorProps.style }}\n      onPointerDown={composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {\n        if (autoScrollTimerRef.current === null) {\n          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);\n        }\n      })}\n      onPointerMove={composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {\n        contentContext.onItemLeave?.();\n        if (autoScrollTimerRef.current === null) {\n          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);\n        }\n      })}\n      onPointerLeave={composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {\n        clearAutoScrollTimer();\n      })}\n    />\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * SelectSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'SelectSeparator';\n\ntype SelectSeparatorElement = React.ElementRef<typeof Primitive.div>;\ninterface SelectSeparatorProps extends PrimitiveDivProps {}\n\nconst SelectSeparator = React.forwardRef<SelectSeparatorElement, SelectSeparatorProps>(\n  (props: ScopedProps<SelectSeparatorProps>, forwardedRef) => {\n    const { __scopeSelect, ...separatorProps } = props;\n    return <Primitive.div aria-hidden {...separatorProps} ref={forwardedRef} />;\n  }\n);\n\nSelectSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'SelectArrow';\n\ntype SelectArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface SelectArrowProps extends PopperArrowProps {}\n\nconst SelectArrow = React.forwardRef<SelectArrowElement, SelectArrowProps>(\n  (props: ScopedProps<SelectArrowProps>, forwardedRef) => {\n    const { __scopeSelect, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeSelect);\n    const context = useSelectContext(ARROW_NAME, __scopeSelect);\n    const contentContext = useSelectContentContext(ARROW_NAME, __scopeSelect);\n    return context.open && contentContext.position === 'popper' ? (\n      <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />\n    ) : null;\n  }\n);\n\nSelectArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction shouldShowPlaceholder(value?: string) {\n  return value === '' || value === undefined;\n}\n\nconst BubbleSelect = React.forwardRef<HTMLSelectElement, React.ComponentPropsWithoutRef<'select'>>(\n  (props, forwardedRef) => {\n    const { value, ...selectProps } = props;\n    const ref = React.useRef<HTMLSelectElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const prevValue = usePrevious(value);\n\n    // Bubble value change to parents (e.g form change event)\n    React.useEffect(() => {\n      const select = ref.current!;\n      const selectProto = window.HTMLSelectElement.prototype;\n      const descriptor = Object.getOwnPropertyDescriptor(\n        selectProto,\n        'value'\n      ) as PropertyDescriptor;\n      const setValue = descriptor.set;\n      if (prevValue !== value && setValue) {\n        const event = new Event('change', { bubbles: true });\n        setValue.call(select, value);\n        select.dispatchEvent(event);\n      }\n    }, [prevValue, value]);\n\n    /**\n     * We purposefully use a `select` here to support form autofill as much\n     * as possible.\n     *\n     * We purposefully do not add the `value` attribute here to allow the value\n     * to be set programmatically and bubble to any parent form `onChange` event.\n     * Adding the `value` will cause React to consider the programmatic\n     * dispatch a duplicate and it will get swallowed.\n     *\n     * We use `VisuallyHidden` rather than `display: \"none\"` because Safari autofill\n     * won't work otherwise.\n     */\n    return (\n      <VisuallyHidden asChild>\n        <select {...selectProps} ref={composedRefs} defaultValue={value} />\n      </VisuallyHidden>\n    );\n  }\n);\n\nBubbleSelect.displayName = 'BubbleSelect';\n\nfunction useTypeaheadSearch(onSearchChange: (search: string) => void) {\n  const handleSearchChange = useCallbackRef(onSearchChange);\n  const searchRef = React.useRef('');\n  const timerRef = React.useRef(0);\n\n  const handleTypeaheadSearch = React.useCallback(\n    (key: string) => {\n      const search = searchRef.current + key;\n      handleSearchChange(search);\n\n      (function updateSearch(value: string) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        // Reset `searchRef` 1 second after it was last updated\n        if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1000);\n      })(search);\n    },\n    [handleSearchChange]\n  );\n\n  const resetTypeahead = React.useCallback(() => {\n    searchRef.current = '';\n    window.clearTimeout(timerRef.current);\n  }, []);\n\n  React.useEffect(() => {\n    return () => window.clearTimeout(timerRef.current);\n  }, []);\n\n  return [searchRef, handleTypeaheadSearch, resetTypeahead] as const;\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in a list of items,\n * the search and the current item, and returns the next item (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through items starting with that character)\n *\n * We also reorder the items by wrapping the array around the current item.\n * This is so we always look forward from the current item, and picking the first\n * item will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current item from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current item still matches.\n */\nfunction findNextItem<T extends { textValue: string }>(\n  items: T[],\n  search: string,\n  currentItem?: T\n) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;\n  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));\n  const excludeCurrentItem = normalizedSearch.length === 1;\n  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);\n  const nextItem = wrappedItems.find((item) =>\n    item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextItem !== currentItem ? nextItem : undefined;\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nconst Root = Select;\nconst Trigger = SelectTrigger;\nconst Value = SelectValue;\nconst Icon = SelectIcon;\nconst Portal = SelectPortal;\nconst Content = SelectContent;\nconst Viewport = SelectViewport;\nconst Group = SelectGroup;\nconst Label = SelectLabel;\nconst Item = SelectItem;\nconst ItemText = SelectItemText;\nconst ItemIndicator = SelectItemIndicator;\nconst ScrollUpButton = SelectScrollUpButton;\nconst ScrollDownButton = SelectScrollDownButton;\nconst Separator = SelectSeparator;\nconst Arrow = SelectArrow;\n\nexport {\n  createSelectScope,\n  //\n  Select,\n  SelectTrigger,\n  SelectValue,\n  SelectIcon,\n  SelectPortal,\n  SelectContent,\n  SelectViewport,\n  SelectGroup,\n  SelectLabel,\n  SelectItem,\n  SelectItemText,\n  SelectItemIndicator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n  SelectSeparator,\n  SelectArrow,\n  //\n  Root,\n  Trigger,\n  Value,\n  Icon,\n  Portal,\n  Content,\n  Viewport,\n  Group,\n  Label,\n  Item,\n  ItemText,\n  ItemIndicator,\n  ScrollUpButton,\n  ScrollDownButton,\n  Separator,\n  Arrow,\n};\nexport type {\n  SelectProps,\n  SelectTriggerProps,\n  SelectValueProps,\n  SelectIconProps,\n  SelectPortalProps,\n  SelectContentProps,\n  SelectViewportProps,\n  SelectGroupProps,\n  SelectLabelProps,\n  SelectItemProps,\n  SelectItemTextProps,\n  SelectItemIndicatorProps,\n  SelectScrollUpButtonProps,\n  SelectScrollDownButtonProps,\n  SelectSeparatorProps,\n  SelectArrowProps,\n};\n"]},"metadata":{},"sourceType":"module"}