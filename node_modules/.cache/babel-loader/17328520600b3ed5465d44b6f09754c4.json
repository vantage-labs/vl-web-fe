{"ast":null,"code":"import _toConsumableArray from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _slicedToArray from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { removeNonTranslationalTransform } from '../dom/utils/unit-conversion.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\nvar toResolve = new Set();\nvar isScheduled = false;\nvar anyNeedsMeasurement = false;\n\nfunction measureAllKeyframes() {\n  if (anyNeedsMeasurement) {\n    var resolversToMeasure = Array.from(toResolve).filter(function (resolver) {\n      return resolver.needsMeasurement;\n    });\n    var elementsToMeasure = new Set(resolversToMeasure.map(function (resolver) {\n      return resolver.element;\n    }));\n    var transformsToRestore = new Map();\n    /**\n     * Write pass\n     * If we're measuring elements we want to remove bounding box-changing transforms.\n     */\n\n    elementsToMeasure.forEach(function (element) {\n      var removedTransforms = removeNonTranslationalTransform(element);\n      if (!removedTransforms.length) return;\n      transformsToRestore.set(element, removedTransforms);\n      element.render();\n    }); // Read\n\n    resolversToMeasure.forEach(function (resolver) {\n      return resolver.measureInitialState();\n    }); // Write\n\n    elementsToMeasure.forEach(function (element) {\n      element.render();\n      var restore = transformsToRestore.get(element);\n\n      if (restore) {\n        restore.forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              key = _ref2[0],\n              value = _ref2[1];\n\n          var _a;\n\n          (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\n        });\n      }\n    }); // Read\n\n    resolversToMeasure.forEach(function (resolver) {\n      return resolver.measureEndState();\n    }); // Write\n\n    resolversToMeasure.forEach(function (resolver) {\n      if (resolver.suspendedScrollY !== undefined) {\n        window.scrollTo(0, resolver.suspendedScrollY);\n      }\n    });\n  }\n\n  anyNeedsMeasurement = false;\n  isScheduled = false;\n  toResolve.forEach(function (resolver) {\n    return resolver.complete();\n  });\n  toResolve.clear();\n}\n\nfunction readAllKeyframes() {\n  toResolve.forEach(function (resolver) {\n    resolver.readKeyframes();\n\n    if (resolver.needsMeasurement) {\n      anyNeedsMeasurement = true;\n    }\n  });\n}\n\nfunction flushKeyframeResolvers() {\n  readAllKeyframes();\n  measureAllKeyframes();\n}\n\nvar KeyframeResolver = /*#__PURE__*/function () {\n  function KeyframeResolver(unresolvedKeyframes, onComplete, name, motionValue, element) {\n    var isAsync = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    _classCallCheck(this, KeyframeResolver);\n\n    /**\n     * Track whether this resolver has completed. Once complete, it never\n     * needs to attempt keyframe resolution again.\n     */\n    this.isComplete = false;\n    /**\n     * Track whether this resolver is async. If it is, it'll be added to the\n     * resolver queue and flushed in the next frame. Resolvers that aren't going\n     * to trigger read/write thrashing don't need to be async.\n     */\n\n    this.isAsync = false;\n    /**\n     * Track whether this resolver needs to perform a measurement\n     * to resolve its keyframes.\n     */\n\n    this.needsMeasurement = false;\n    /**\n     * Track whether this resolver is currently scheduled to resolve\n     * to allow it to be cancelled and resumed externally.\n     */\n\n    this.isScheduled = false;\n    this.unresolvedKeyframes = _toConsumableArray(unresolvedKeyframes);\n    this.onComplete = onComplete;\n    this.name = name;\n    this.motionValue = motionValue;\n    this.element = element;\n    this.isAsync = isAsync;\n  }\n\n  _createClass(KeyframeResolver, [{\n    key: \"scheduleResolve\",\n    value: function scheduleResolve() {\n      this.isScheduled = true;\n\n      if (this.isAsync) {\n        toResolve.add(this);\n\n        if (!isScheduled) {\n          isScheduled = true;\n          frame.read(readAllKeyframes);\n          frame.resolveKeyframes(measureAllKeyframes);\n        }\n      } else {\n        this.readKeyframes();\n        this.complete();\n      }\n    }\n  }, {\n    key: \"readKeyframes\",\n    value: function readKeyframes() {\n      var unresolvedKeyframes = this.unresolvedKeyframes,\n          name = this.name,\n          element = this.element,\n          motionValue = this.motionValue;\n      /**\n       * If a keyframe is null, we hydrate it either by reading it from\n       * the instance, or propagating from previous keyframes.\n       */\n\n      for (var i = 0; i < unresolvedKeyframes.length; i++) {\n        if (unresolvedKeyframes[i] === null) {\n          /**\n           * If the first keyframe is null, we need to find its value by sampling the element\n           */\n          if (i === 0) {\n            var currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\n            var finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n\n            if (currentValue !== undefined) {\n              unresolvedKeyframes[0] = currentValue;\n            } else if (element && name) {\n              var valueAsRead = element.readValue(name, finalKeyframe);\n\n              if (valueAsRead !== undefined && valueAsRead !== null) {\n                unresolvedKeyframes[0] = valueAsRead;\n              }\n            }\n\n            if (unresolvedKeyframes[0] === undefined) {\n              unresolvedKeyframes[0] = finalKeyframe;\n            }\n\n            if (motionValue && currentValue === undefined) {\n              motionValue.set(unresolvedKeyframes[0]);\n            }\n          } else {\n            unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\n          }\n        }\n      }\n    }\n  }, {\n    key: \"setFinalKeyframe\",\n    value: function setFinalKeyframe() {}\n  }, {\n    key: \"measureInitialState\",\n    value: function measureInitialState() {}\n  }, {\n    key: \"renderEndStyles\",\n    value: function renderEndStyles() {}\n  }, {\n    key: \"measureEndState\",\n    value: function measureEndState() {}\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      this.isComplete = true;\n      this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\n      toResolve.delete(this);\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (!this.isComplete) {\n        this.isScheduled = false;\n        toResolve.delete(this);\n      }\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (!this.isComplete) this.scheduleResolve();\n    }\n  }]);\n\n  return KeyframeResolver;\n}();\n\nexport { KeyframeResolver, flushKeyframeResolvers };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/render/utils/KeyframesResolver.mjs"],"names":["removeNonTranslationalTransform","frame","toResolve","Set","isScheduled","anyNeedsMeasurement","measureAllKeyframes","resolversToMeasure","Array","from","filter","resolver","needsMeasurement","elementsToMeasure","map","element","transformsToRestore","Map","forEach","removedTransforms","length","set","render","measureInitialState","restore","get","key","value","_a","getValue","measureEndState","suspendedScrollY","undefined","window","scrollTo","complete","clear","readAllKeyframes","readKeyframes","flushKeyframeResolvers","KeyframeResolver","unresolvedKeyframes","onComplete","name","motionValue","isAsync","isComplete","add","read","resolveKeyframes","i","currentValue","finalKeyframe","valueAsRead","readValue","delete","scheduleResolve"],"mappings":"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","sourcesContent":["import { removeNonTranslationalTransform } from '../dom/utils/unit-conversion.mjs';\nimport { frame } from '../../frameloop/frame.mjs';\n\nconst toResolve = new Set();\nlet isScheduled = false;\nlet anyNeedsMeasurement = false;\nfunction measureAllKeyframes() {\n    if (anyNeedsMeasurement) {\n        const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);\n        const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));\n        const transformsToRestore = new Map();\n        /**\n         * Write pass\n         * If we're measuring elements we want to remove bounding box-changing transforms.\n         */\n        elementsToMeasure.forEach((element) => {\n            const removedTransforms = removeNonTranslationalTransform(element);\n            if (!removedTransforms.length)\n                return;\n            transformsToRestore.set(element, removedTransforms);\n            element.render();\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureInitialState());\n        // Write\n        elementsToMeasure.forEach((element) => {\n            element.render();\n            const restore = transformsToRestore.get(element);\n            if (restore) {\n                restore.forEach(([key, value]) => {\n                    var _a;\n                    (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);\n                });\n            }\n        });\n        // Read\n        resolversToMeasure.forEach((resolver) => resolver.measureEndState());\n        // Write\n        resolversToMeasure.forEach((resolver) => {\n            if (resolver.suspendedScrollY !== undefined) {\n                window.scrollTo(0, resolver.suspendedScrollY);\n            }\n        });\n    }\n    anyNeedsMeasurement = false;\n    isScheduled = false;\n    toResolve.forEach((resolver) => resolver.complete());\n    toResolve.clear();\n}\nfunction readAllKeyframes() {\n    toResolve.forEach((resolver) => {\n        resolver.readKeyframes();\n        if (resolver.needsMeasurement) {\n            anyNeedsMeasurement = true;\n        }\n    });\n}\nfunction flushKeyframeResolvers() {\n    readAllKeyframes();\n    measureAllKeyframes();\n}\nclass KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {\n        /**\n         * Track whether this resolver has completed. Once complete, it never\n         * needs to attempt keyframe resolution again.\n         */\n        this.isComplete = false;\n        /**\n         * Track whether this resolver is async. If it is, it'll be added to the\n         * resolver queue and flushed in the next frame. Resolvers that aren't going\n         * to trigger read/write thrashing don't need to be async.\n         */\n        this.isAsync = false;\n        /**\n         * Track whether this resolver needs to perform a measurement\n         * to resolve its keyframes.\n         */\n        this.needsMeasurement = false;\n        /**\n         * Track whether this resolver is currently scheduled to resolve\n         * to allow it to be cancelled and resumed externally.\n         */\n        this.isScheduled = false;\n        this.unresolvedKeyframes = [...unresolvedKeyframes];\n        this.onComplete = onComplete;\n        this.name = name;\n        this.motionValue = motionValue;\n        this.element = element;\n        this.isAsync = isAsync;\n    }\n    scheduleResolve() {\n        this.isScheduled = true;\n        if (this.isAsync) {\n            toResolve.add(this);\n            if (!isScheduled) {\n                isScheduled = true;\n                frame.read(readAllKeyframes);\n                frame.resolveKeyframes(measureAllKeyframes);\n            }\n        }\n        else {\n            this.readKeyframes();\n            this.complete();\n        }\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, name, element, motionValue } = this;\n        /**\n         * If a keyframe is null, we hydrate it either by reading it from\n         * the instance, or propagating from previous keyframes.\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (unresolvedKeyframes[i] === null) {\n                /**\n                 * If the first keyframe is null, we need to find its value by sampling the element\n                 */\n                if (i === 0) {\n                    const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();\n                    const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n                    if (currentValue !== undefined) {\n                        unresolvedKeyframes[0] = currentValue;\n                    }\n                    else if (element && name) {\n                        const valueAsRead = element.readValue(name, finalKeyframe);\n                        if (valueAsRead !== undefined && valueAsRead !== null) {\n                            unresolvedKeyframes[0] = valueAsRead;\n                        }\n                    }\n                    if (unresolvedKeyframes[0] === undefined) {\n                        unresolvedKeyframes[0] = finalKeyframe;\n                    }\n                    if (motionValue && currentValue === undefined) {\n                        motionValue.set(unresolvedKeyframes[0]);\n                    }\n                }\n                else {\n                    unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];\n                }\n            }\n        }\n    }\n    setFinalKeyframe() { }\n    measureInitialState() { }\n    renderEndStyles() { }\n    measureEndState() { }\n    complete() {\n        this.isComplete = true;\n        this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);\n        toResolve.delete(this);\n    }\n    cancel() {\n        if (!this.isComplete) {\n            this.isScheduled = false;\n            toResolve.delete(this);\n        }\n    }\n    resume() {\n        if (!this.isComplete)\n            this.scheduleResolve();\n    }\n}\n\nexport { KeyframeResolver, flushKeyframeResolvers };\n"]},"metadata":{},"sourceType":"module"}