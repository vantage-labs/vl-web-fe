{"ast":null,"code":"\"use client\"; // packages/react/popper/src/Popper.tsx\n\nimport * as React from \"react\";\nimport { useFloating, autoUpdate, offset, shift, limitShift, hide, arrow as floatingUIarrow, flip, size } from \"@floating-ui/react-dom\";\nimport * as ArrowPrimitive from \"@radix-ui/react-arrow\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { useSize } from \"@radix-ui/react-use-size\";\nimport { jsx } from \"react/jsx-runtime\";\nvar SIDE_OPTIONS = [\"top\", \"right\", \"bottom\", \"left\"];\nvar ALIGN_OPTIONS = [\"start\", \"center\", \"end\"];\nvar POPPER_NAME = \"Popper\";\nvar [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\nvar [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);\n\nvar Popper = props => {\n  const {\n    __scopePopper,\n    children\n  } = props;\n  const [anchor, setAnchor] = React.useState(null);\n  return /* @__PURE__ */jsx(PopperProvider, {\n    scope: __scopePopper,\n    anchor,\n    onAnchorChange: setAnchor,\n    children\n  });\n};\n\nPopper.displayName = POPPER_NAME;\nvar ANCHOR_NAME = \"PopperAnchor\";\nvar PopperAnchor = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopePopper,\n    virtualRef,\n    ...anchorProps\n  } = props;\n  const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  React.useEffect(() => {\n    context.onAnchorChange(virtualRef?.current || ref.current);\n  });\n  return virtualRef ? null : /* @__PURE__ */jsx(Primitive.div, { ...anchorProps,\n    ref: composedRefs\n  });\n});\nPopperAnchor.displayName = ANCHOR_NAME;\nvar CONTENT_NAME = \"PopperContent\";\nvar [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME);\nvar PopperContent = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopePopper,\n    side = \"bottom\",\n    sideOffset = 0,\n    align = \"center\",\n    alignOffset = 0,\n    arrowPadding = 0,\n    avoidCollisions = true,\n    collisionBoundary = [],\n    collisionPadding: collisionPaddingProp = 0,\n    sticky = \"partial\",\n    hideWhenDetached = false,\n    updatePositionStrategy = \"optimized\",\n    onPlaced,\n    ...contentProps\n  } = props;\n  const context = usePopperContext(CONTENT_NAME, __scopePopper);\n  const [content, setContent] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setContent(node));\n  const [arrow, setArrow] = React.useState(null);\n  const arrowSize = useSize(arrow);\n  const arrowWidth = arrowSize?.width ?? 0;\n  const arrowHeight = arrowSize?.height ?? 0;\n  const desiredPlacement = side + (align !== \"center\" ? \"-\" + align : \"\");\n  const collisionPadding = typeof collisionPaddingProp === \"number\" ? collisionPaddingProp : {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...collisionPaddingProp\n  };\n  const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n  const hasExplicitBoundaries = boundary.length > 0;\n  const detectOverflowOptions = {\n    padding: collisionPadding,\n    boundary: boundary.filter(isNotNull),\n    // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n    altBoundary: hasExplicitBoundaries\n  };\n  const {\n    refs,\n    floatingStyles,\n    placement,\n    isPositioned,\n    middlewareData\n  } = useFloating({\n    // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n    strategy: \"fixed\",\n    placement: desiredPlacement,\n    whileElementsMounted: function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      const cleanup = autoUpdate(...args, {\n        animationFrame: updatePositionStrategy === \"always\"\n      });\n      return cleanup;\n    },\n    elements: {\n      reference: context.anchor\n    },\n    middleware: [offset({\n      mainAxis: sideOffset + arrowHeight,\n      alignmentAxis: alignOffset\n    }), avoidCollisions && shift({\n      mainAxis: true,\n      crossAxis: false,\n      limiter: sticky === \"partial\" ? limitShift() : void 0,\n      ...detectOverflowOptions\n    }), avoidCollisions && flip({ ...detectOverflowOptions\n    }), size({ ...detectOverflowOptions,\n      apply: _ref => {\n        let {\n          elements,\n          rects,\n          availableWidth,\n          availableHeight\n        } = _ref;\n        const {\n          width: anchorWidth,\n          height: anchorHeight\n        } = rects.reference;\n        const contentStyle = elements.floating.style;\n        contentStyle.setProperty(\"--radix-popper-available-width\", `${availableWidth}px`);\n        contentStyle.setProperty(\"--radix-popper-available-height\", `${availableHeight}px`);\n        contentStyle.setProperty(\"--radix-popper-anchor-width\", `${anchorWidth}px`);\n        contentStyle.setProperty(\"--radix-popper-anchor-height\", `${anchorHeight}px`);\n      }\n    }), arrow && floatingUIarrow({\n      element: arrow,\n      padding: arrowPadding\n    }), transformOrigin({\n      arrowWidth,\n      arrowHeight\n    }), hideWhenDetached && hide({\n      strategy: \"referenceHidden\",\n      ...detectOverflowOptions\n    })]\n  });\n  const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n  const handlePlaced = useCallbackRef(onPlaced);\n  useLayoutEffect(() => {\n    if (isPositioned) {\n      handlePlaced?.();\n    }\n  }, [isPositioned, handlePlaced]);\n  const arrowX = middlewareData.arrow?.x;\n  const arrowY = middlewareData.arrow?.y;\n  const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n  const [contentZIndex, setContentZIndex] = React.useState();\n  useLayoutEffect(() => {\n    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n  }, [content]);\n  return /* @__PURE__ */jsx(\"div\", {\n    ref: refs.setFloating,\n    \"data-radix-popper-content-wrapper\": \"\",\n    style: { ...floatingStyles,\n      transform: isPositioned ? floatingStyles.transform : \"translate(0, -200%)\",\n      // keep off the page when measuring\n      minWidth: \"max-content\",\n      zIndex: contentZIndex,\n      [\"--radix-popper-transform-origin\"]: [middlewareData.transformOrigin?.x, middlewareData.transformOrigin?.y].join(\" \"),\n      // hide the content if using the hide middleware and should be hidden\n      // set visibility to hidden and disable pointer events so the UI behaves\n      // as if the PopperContent isn't there at all\n      ...(middlewareData.hide?.referenceHidden && {\n        visibility: \"hidden\",\n        pointerEvents: \"none\"\n      })\n    },\n    dir: props.dir,\n    children: /* @__PURE__ */jsx(PopperContentProvider, {\n      scope: __scopePopper,\n      placedSide,\n      onArrowChange: setArrow,\n      arrowX,\n      arrowY,\n      shouldHideArrow: cannotCenterArrow,\n      children: /* @__PURE__ */jsx(Primitive.div, {\n        \"data-side\": placedSide,\n        \"data-align\": placedAlign,\n        ...contentProps,\n        ref: composedRefs,\n        style: { ...contentProps.style,\n          // if the PopperContent hasn't been placed yet (not all measurements done)\n          // we prevent animations so that users's animation don't kick in too early referring wrong sides\n          animation: !isPositioned ? \"none\" : void 0\n        }\n      })\n    })\n  });\n});\nPopperContent.displayName = CONTENT_NAME;\nvar ARROW_NAME = \"PopperArrow\";\nvar OPPOSITE_SIDE = {\n  top: \"bottom\",\n  right: \"left\",\n  bottom: \"top\",\n  left: \"right\"\n};\nvar PopperArrow = React.forwardRef(function PopperArrow2(props, forwardedRef) {\n  const {\n    __scopePopper,\n    ...arrowProps\n  } = props;\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n  return (// we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n\n    /* @__PURE__ */\n    jsx(\"span\", {\n      ref: contentContext.onArrowChange,\n      style: {\n        position: \"absolute\",\n        left: contentContext.arrowX,\n        top: contentContext.arrowY,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: \"\",\n          right: \"0 0\",\n          bottom: \"center 0\",\n          left: \"100% 0\"\n        }[contentContext.placedSide],\n        transform: {\n          top: \"translateY(100%)\",\n          right: \"translateY(50%) rotate(90deg) translateX(-50%)\",\n          bottom: `rotate(180deg)`,\n          left: \"translateY(50%) rotate(-90deg) translateX(50%)\"\n        }[contentContext.placedSide],\n        visibility: contentContext.shouldHideArrow ? \"hidden\" : void 0\n      },\n      children: /* @__PURE__ */jsx(ArrowPrimitive.Root, { ...arrowProps,\n        ref: forwardedRef,\n        style: { ...arrowProps.style,\n          // ensures the element can be measured correctly (mostly for if SVG)\n          display: \"block\"\n        }\n      })\n    })\n  );\n});\nPopperArrow.displayName = ARROW_NAME;\n\nfunction isNotNull(value) {\n  return value !== null;\n}\n\nvar transformOrigin = options => ({\n  name: \"transformOrigin\",\n  options,\n\n  fn(data) {\n    const {\n      placement,\n      rects,\n      middlewareData\n    } = data;\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = {\n      start: \"0%\",\n      center: \"50%\",\n      end: \"100%\"\n    }[placedAlign];\n    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;\n    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;\n    let x = \"\";\n    let y = \"\";\n\n    if (placedSide === \"bottom\") {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${-arrowHeight}px`;\n    } else if (placedSide === \"top\") {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${rects.floating.height + arrowHeight}px`;\n    } else if (placedSide === \"right\") {\n      x = `${-arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    } else if (placedSide === \"left\") {\n      x = `${rects.floating.width + arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    }\n\n    return {\n      data: {\n        x,\n        y\n      }\n    };\n  }\n\n});\n\nfunction getSideAndAlignFromPlacement(placement) {\n  const [side, align = \"center\"] = placement.split(\"-\");\n  return [side, align];\n}\n\nvar Root2 = Popper;\nvar Anchor = PopperAnchor;\nvar Content = PopperContent;\nvar Arrow = PopperArrow;\nexport { ALIGN_OPTIONS, Anchor, Arrow, Content, Popper, PopperAnchor, PopperArrow, PopperContent, Root2 as Root, SIDE_OPTIONS, createPopperScope };","map":{"version":3,"mappings":"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","names":["React","useFloating","autoUpdate","offset","shift","limitShift","hide","arrow","floatingUIarrow","flip","size","ArrowPrimitive","useComposedRefs","createContextScope","Primitive","useCallbackRef","useLayoutEffect","useSize","SIDE_OPTIONS","ALIGN_OPTIONS","POPPER_NAME","createPopperContext","createPopperScope","PopperProvider","usePopperContext","Popper","props","__scopePopper","children","anchor","setAnchor","scope","onAnchorChange","displayName","ANCHOR_NAME","PopperAnchor","forwardedRef","virtualRef","anchorProps","context","ref","composedRefs","current","div","CONTENT_NAME","PopperContentProvider","useContentContext","PopperContent","side","sideOffset","align","alignOffset","arrowPadding","avoidCollisions","collisionBoundary","collisionPadding","collisionPaddingProp","sticky","hideWhenDetached","updatePositionStrategy","onPlaced","contentProps","content","setContent","node","setArrow","arrowSize","arrowWidth","width","arrowHeight","height","desiredPlacement","top","right","bottom","left","boundary","Array","isArray","hasExplicitBoundaries","length","detectOverflowOptions","padding","filter","isNotNull","altBoundary","refs","floatingStyles","placement","isPositioned","middlewareData","strategy","whileElementsMounted","args","cleanup","animationFrame","elements","reference","middleware","mainAxis","alignmentAxis","crossAxis","limiter","apply","rects","availableWidth","availableHeight","anchorWidth","anchorHeight","contentStyle","floating","style","setProperty","element","transformOrigin","placedSide","placedAlign","getSideAndAlignFromPlacement","handlePlaced","arrowX","x","arrowY","y","cannotCenterArrow","centerOffset","contentZIndex","setContentZIndex","window","getComputedStyle","zIndex","setFloating","transform","minWidth","join","referenceHidden","visibility","pointerEvents","dir","onArrowChange","shouldHideArrow","animation","ARROW_NAME","OPPOSITE_SIDE","PopperArrow","arrowProps","contentContext","baseSide","jsx","position","display","value","options","name","fn","data","isArrowHidden","noArrowAlign","start","center","end","arrowXCenter","arrowYCenter","split","Root","Anchor","Content","Arrow"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-popper/src/Popper.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  useFloating,\n  autoUpdate,\n  offset,\n  shift,\n  limitShift,\n  hide,\n  arrow as floatingUIarrow,\n  flip,\n  size,\n} from '@floating-ui/react-dom';\nimport * as ArrowPrimitive from '@radix-ui/react-arrow';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useSize } from '@radix-ui/react-use-size';\n\nimport type { Placement, Middleware } from '@floating-ui/react-dom';\nimport type { Scope } from '@radix-ui/react-context';\nimport type { Measurable } from '@radix-ui/rect';\n\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const;\nconst ALIGN_OPTIONS = ['start', 'center', 'end'] as const;\n\ntype Side = (typeof SIDE_OPTIONS)[number];\ntype Align = (typeof ALIGN_OPTIONS)[number];\n\n/* -------------------------------------------------------------------------------------------------\n * Popper\n * -----------------------------------------------------------------------------------------------*/\n\nconst POPPER_NAME = 'Popper';\n\ntype ScopedProps<P> = P & { __scopePopper?: Scope };\nconst [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\n\ntype PopperContextValue = {\n  anchor: Measurable | null;\n  onAnchorChange(anchor: Measurable | null): void;\n};\nconst [PopperProvider, usePopperContext] = createPopperContext<PopperContextValue>(POPPER_NAME);\n\ninterface PopperProps {\n  children?: React.ReactNode;\n}\nconst Popper: React.FC<PopperProps> = (props: ScopedProps<PopperProps>) => {\n  const { __scopePopper, children } = props;\n  const [anchor, setAnchor] = React.useState<Measurable | null>(null);\n  return (\n    <PopperProvider scope={__scopePopper} anchor={anchor} onAnchorChange={setAnchor}>\n      {children}\n    </PopperProvider>\n  );\n};\n\nPopper.displayName = POPPER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'PopperAnchor';\n\ntype PopperAnchorElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PopperAnchorProps extends PrimitiveDivProps {\n  virtualRef?: React.RefObject<Measurable>;\n}\n\nconst PopperAnchor = React.forwardRef<PopperAnchorElement, PopperAnchorProps>(\n  (props: ScopedProps<PopperAnchorProps>, forwardedRef) => {\n    const { __scopePopper, virtualRef, ...anchorProps } = props;\n    const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n    const ref = React.useRef<PopperAnchorElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    React.useEffect(() => {\n      // Consumer can anchor the popper to something that isn't\n      // a DOM node e.g. pointer position, so we override the\n      // `anchorRef` with their virtual ref in this case.\n      context.onAnchorChange(virtualRef?.current || ref.current);\n    });\n\n    return virtualRef ? null : <Primitive.div {...anchorProps} ref={composedRefs} />;\n  }\n);\n\nPopperAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'PopperContent';\n\ntype PopperContentContextValue = {\n  placedSide: Side;\n  onArrowChange(arrow: HTMLSpanElement | null): void;\n  arrowX?: number;\n  arrowY?: number;\n  shouldHideArrow: boolean;\n};\n\nconst [PopperContentProvider, useContentContext] =\n  createPopperContext<PopperContentContextValue>(CONTENT_NAME);\n\ntype Boundary = Element | null;\n\ntype PopperContentElement = React.ElementRef<typeof Primitive.div>;\ninterface PopperContentProps extends PrimitiveDivProps {\n  side?: Side;\n  sideOffset?: number;\n  align?: Align;\n  alignOffset?: number;\n  arrowPadding?: number;\n  avoidCollisions?: boolean;\n  collisionBoundary?: Boundary | Boundary[];\n  collisionPadding?: number | Partial<Record<Side, number>>;\n  sticky?: 'partial' | 'always';\n  hideWhenDetached?: boolean;\n  updatePositionStrategy?: 'optimized' | 'always';\n  onPlaced?: () => void;\n}\n\nconst PopperContent = React.forwardRef<PopperContentElement, PopperContentProps>(\n  (props: ScopedProps<PopperContentProps>, forwardedRef) => {\n    const {\n      __scopePopper,\n      side = 'bottom',\n      sideOffset = 0,\n      align = 'center',\n      alignOffset = 0,\n      arrowPadding = 0,\n      avoidCollisions = true,\n      collisionBoundary = [],\n      collisionPadding: collisionPaddingProp = 0,\n      sticky = 'partial',\n      hideWhenDetached = false,\n      updatePositionStrategy = 'optimized',\n      onPlaced,\n      ...contentProps\n    } = props;\n\n    const context = usePopperContext(CONTENT_NAME, __scopePopper);\n\n    const [content, setContent] = React.useState<HTMLDivElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n\n    const [arrow, setArrow] = React.useState<HTMLSpanElement | null>(null);\n    const arrowSize = useSize(arrow);\n    const arrowWidth = arrowSize?.width ?? 0;\n    const arrowHeight = arrowSize?.height ?? 0;\n\n    const desiredPlacement = (side + (align !== 'center' ? '-' + align : '')) as Placement;\n\n    const collisionPadding =\n      typeof collisionPaddingProp === 'number'\n        ? collisionPaddingProp\n        : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };\n\n    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n    const hasExplicitBoundaries = boundary.length > 0;\n\n    const detectOverflowOptions = {\n      padding: collisionPadding,\n      boundary: boundary.filter(isNotNull),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: hasExplicitBoundaries,\n    };\n\n    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({\n      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n      strategy: 'fixed',\n      placement: desiredPlacement,\n      whileElementsMounted: (...args) => {\n        const cleanup = autoUpdate(...args, {\n          animationFrame: updatePositionStrategy === 'always',\n        });\n        return cleanup;\n      },\n      elements: {\n        reference: context.anchor,\n      },\n      middleware: [\n        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),\n        avoidCollisions &&\n          shift({\n            mainAxis: true,\n            crossAxis: false,\n            limiter: sticky === 'partial' ? limitShift() : undefined,\n            ...detectOverflowOptions,\n          }),\n        avoidCollisions && flip({ ...detectOverflowOptions }),\n        size({\n          ...detectOverflowOptions,\n          apply: ({ elements, rects, availableWidth, availableHeight }) => {\n            const { width: anchorWidth, height: anchorHeight } = rects.reference;\n            const contentStyle = elements.floating.style;\n            contentStyle.setProperty('--radix-popper-available-width', `${availableWidth}px`);\n            contentStyle.setProperty('--radix-popper-available-height', `${availableHeight}px`);\n            contentStyle.setProperty('--radix-popper-anchor-width', `${anchorWidth}px`);\n            contentStyle.setProperty('--radix-popper-anchor-height', `${anchorHeight}px`);\n          },\n        }),\n        arrow && floatingUIarrow({ element: arrow, padding: arrowPadding }),\n        transformOrigin({ arrowWidth, arrowHeight }),\n        hideWhenDetached && hide({ strategy: 'referenceHidden', ...detectOverflowOptions }),\n      ],\n    });\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n\n    const handlePlaced = useCallbackRef(onPlaced);\n    useLayoutEffect(() => {\n      if (isPositioned) {\n        handlePlaced?.();\n      }\n    }, [isPositioned, handlePlaced]);\n\n    const arrowX = middlewareData.arrow?.x;\n    const arrowY = middlewareData.arrow?.y;\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n\n    const [contentZIndex, setContentZIndex] = React.useState<string>();\n    useLayoutEffect(() => {\n      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n    }, [content]);\n\n    return (\n      <div\n        ref={refs.setFloating}\n        data-radix-popper-content-wrapper=\"\"\n        style={{\n          ...floatingStyles,\n          transform: isPositioned ? floatingStyles.transform : 'translate(0, -200%)', // keep off the page when measuring\n          minWidth: 'max-content',\n          zIndex: contentZIndex,\n          ['--radix-popper-transform-origin' as any]: [\n            middlewareData.transformOrigin?.x,\n            middlewareData.transformOrigin?.y,\n          ].join(' '),\n\n          // hide the content if using the hide middleware and should be hidden\n          // set visibility to hidden and disable pointer events so the UI behaves\n          // as if the PopperContent isn't there at all\n          ...(middlewareData.hide?.referenceHidden && {\n            visibility: 'hidden',\n            pointerEvents: 'none',\n          }),\n        }}\n        // Floating UI interally calculates logical alignment based the `dir` attribute on\n        // the reference/floating node, we must add this attribute here to ensure\n        // this is calculated when portalled as well as inline.\n        dir={props.dir}\n      >\n        <PopperContentProvider\n          scope={__scopePopper}\n          placedSide={placedSide}\n          onArrowChange={setArrow}\n          arrowX={arrowX}\n          arrowY={arrowY}\n          shouldHideArrow={cannotCenterArrow}\n        >\n          <Primitive.div\n            data-side={placedSide}\n            data-align={placedAlign}\n            {...contentProps}\n            ref={composedRefs}\n            style={{\n              ...contentProps.style,\n              // if the PopperContent hasn't been placed yet (not all measurements done)\n              // we prevent animations so that users's animation don't kick in too early referring wrong sides\n              animation: !isPositioned ? 'none' : undefined,\n            }}\n          />\n        </PopperContentProvider>\n      </div>\n    );\n  }\n);\n\nPopperContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'PopperArrow';\n\nconst OPPOSITE_SIDE: Record<Side, Side> = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right',\n};\n\ntype PopperArrowElement = React.ElementRef<typeof ArrowPrimitive.Root>;\ntype ArrowProps = React.ComponentPropsWithoutRef<typeof ArrowPrimitive.Root>;\ninterface PopperArrowProps extends ArrowProps {}\n\nconst PopperArrow = React.forwardRef<PopperArrowElement, PopperArrowProps>(function PopperArrow(\n  props: ScopedProps<PopperArrowProps>,\n  forwardedRef\n) {\n  const { __scopePopper, ...arrowProps } = props;\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    <span\n      ref={contentContext.onArrowChange}\n      style={{\n        position: 'absolute',\n        left: contentContext.arrowX,\n        top: contentContext.arrowY,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: '',\n          right: '0 0',\n          bottom: 'center 0',\n          left: '100% 0',\n        }[contentContext.placedSide],\n        transform: {\n          top: 'translateY(100%)',\n          right: 'translateY(50%) rotate(90deg) translateX(-50%)',\n          bottom: `rotate(180deg)`,\n          left: 'translateY(50%) rotate(-90deg) translateX(50%)',\n        }[contentContext.placedSide],\n        visibility: contentContext.shouldHideArrow ? 'hidden' : undefined,\n      }}\n    >\n      <ArrowPrimitive.Root\n        {...arrowProps}\n        ref={forwardedRef}\n        style={{\n          ...arrowProps.style,\n          // ensures the element can be measured correctly (mostly for if SVG)\n          display: 'block',\n        }}\n      />\n    </span>\n  );\n});\n\nPopperArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction isNotNull<T>(value: T | null): value is T {\n  return value !== null;\n}\n\nconst transformOrigin = (options: { arrowWidth: number; arrowHeight: number }): Middleware => ({\n  name: 'transformOrigin',\n  options,\n  fn(data) {\n    const { placement, rects, middlewareData } = data;\n\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = { start: '0%', center: '50%', end: '100%' }[placedAlign];\n\n    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;\n    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;\n\n    let x = '';\n    let y = '';\n\n    if (placedSide === 'bottom') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${-arrowHeight}px`;\n    } else if (placedSide === 'top') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${rects.floating.height + arrowHeight}px`;\n    } else if (placedSide === 'right') {\n      x = `${-arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    } else if (placedSide === 'left') {\n      x = `${rects.floating.width + arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    }\n    return { data: { x, y } };\n  },\n});\n\nfunction getSideAndAlignFromPlacement(placement: Placement) {\n  const [side, align = 'center'] = placement.split('-');\n  return [side as Side, align as Align] as const;\n}\n\nconst Root = Popper;\nconst Anchor = PopperAnchor;\nconst Content = PopperContent;\nconst Arrow = PopperArrow;\n\nexport {\n  createPopperScope,\n  //\n  Popper,\n  PopperAnchor,\n  PopperContent,\n  PopperArrow,\n  //\n  Root,\n  Anchor,\n  Content,\n  Arrow,\n  //\n  SIDE_OPTIONS,\n  ALIGN_OPTIONS,\n};\nexport type { PopperProps, PopperAnchorProps, PopperContentProps, PopperArrowProps };\n"]},"metadata":{},"sourceType":"module"}