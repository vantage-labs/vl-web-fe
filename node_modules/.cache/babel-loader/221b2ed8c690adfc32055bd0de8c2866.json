{"ast":null,"code":"\"use client\"; // packages/react/scroll-area/src/ScrollArea.tsx\n\nimport * as React2 from \"react\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useDirection } from \"@radix-ui/react-direction\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { clamp } from \"@radix-ui/number\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\"; // packages/react/scroll-area/src/useStateMachine.ts\n\nimport * as React from \"react\";\n\nfunction useStateMachine(initialState, machine) {\n  return React.useReducer((state, event) => {\n    const nextState = machine[state][event];\n    return nextState ?? state;\n  }, initialState);\n} // packages/react/scroll-area/src/ScrollArea.tsx\n\n\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nvar SCROLL_AREA_NAME = \"ScrollArea\";\nvar [createScrollAreaContext, createScrollAreaScope] = createContextScope(SCROLL_AREA_NAME);\nvar [ScrollAreaProvider, useScrollAreaContext] = createScrollAreaContext(SCROLL_AREA_NAME);\nvar ScrollArea = React2.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeScrollArea,\n    type = \"hover\",\n    dir,\n    scrollHideDelay = 600,\n    ...scrollAreaProps\n  } = props;\n  const [scrollArea, setScrollArea] = React2.useState(null);\n  const [viewport, setViewport] = React2.useState(null);\n  const [content, setContent] = React2.useState(null);\n  const [scrollbarX, setScrollbarX] = React2.useState(null);\n  const [scrollbarY, setScrollbarY] = React2.useState(null);\n  const [cornerWidth, setCornerWidth] = React2.useState(0);\n  const [cornerHeight, setCornerHeight] = React2.useState(0);\n  const [scrollbarXEnabled, setScrollbarXEnabled] = React2.useState(false);\n  const [scrollbarYEnabled, setScrollbarYEnabled] = React2.useState(false);\n  const composedRefs = useComposedRefs(forwardedRef, node => setScrollArea(node));\n  const direction = useDirection(dir);\n  return /* @__PURE__ */jsx(ScrollAreaProvider, {\n    scope: __scopeScrollArea,\n    type,\n    dir: direction,\n    scrollHideDelay,\n    scrollArea,\n    viewport,\n    onViewportChange: setViewport,\n    content,\n    onContentChange: setContent,\n    scrollbarX,\n    onScrollbarXChange: setScrollbarX,\n    scrollbarXEnabled,\n    onScrollbarXEnabledChange: setScrollbarXEnabled,\n    scrollbarY,\n    onScrollbarYChange: setScrollbarY,\n    scrollbarYEnabled,\n    onScrollbarYEnabledChange: setScrollbarYEnabled,\n    onCornerWidthChange: setCornerWidth,\n    onCornerHeightChange: setCornerHeight,\n    children: /* @__PURE__ */jsx(Primitive.div, {\n      dir: direction,\n      ...scrollAreaProps,\n      ref: composedRefs,\n      style: {\n        position: \"relative\",\n        // Pass corner sizes as CSS vars to reduce re-renders of context consumers\n        [\"--radix-scroll-area-corner-width\"]: cornerWidth + \"px\",\n        [\"--radix-scroll-area-corner-height\"]: cornerHeight + \"px\",\n        ...props.style\n      }\n    })\n  });\n});\nScrollArea.displayName = SCROLL_AREA_NAME;\nvar VIEWPORT_NAME = \"ScrollAreaViewport\";\nvar ScrollAreaViewport = React2.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeScrollArea,\n    children,\n    nonce,\n    ...viewportProps\n  } = props;\n  const context = useScrollAreaContext(VIEWPORT_NAME, __scopeScrollArea);\n  const ref = React2.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(\"style\", {\n      dangerouslySetInnerHTML: {\n        __html: `[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}`\n      },\n      nonce\n    }), /* @__PURE__ */jsx(Primitive.div, {\n      \"data-radix-scroll-area-viewport\": \"\",\n      ...viewportProps,\n      ref: composedRefs,\n      style: {\n        /**\n         * We don't support `visible` because the intention is to have at least one scrollbar\n         * if this component is used and `visible` will behave like `auto` in that case\n         * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description\n         *\n         * We don't handle `auto` because the intention is for the native implementation\n         * to be hidden if using this component. We just want to ensure the node is scrollable\n         * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent\n         * the browser from having to work out whether to render native scrollbars or not,\n         * we tell it to with the intention of hiding them in CSS.\n         */\n        overflowX: context.scrollbarXEnabled ? \"scroll\" : \"hidden\",\n        overflowY: context.scrollbarYEnabled ? \"scroll\" : \"hidden\",\n        ...props.style\n      },\n      children: /* @__PURE__ */jsx(\"div\", {\n        ref: context.onContentChange,\n        style: {\n          minWidth: \"100%\",\n          display: \"table\"\n        },\n        children\n      })\n    })]\n  });\n});\nScrollAreaViewport.displayName = VIEWPORT_NAME;\nvar SCROLLBAR_NAME = \"ScrollAreaScrollbar\";\nvar ScrollAreaScrollbar = React2.forwardRef((props, forwardedRef) => {\n  const {\n    forceMount,\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const {\n    onScrollbarXEnabledChange,\n    onScrollbarYEnabledChange\n  } = context;\n  const isHorizontal = props.orientation === \"horizontal\";\n  React2.useEffect(() => {\n    isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);\n    return () => {\n      isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);\n    };\n  }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);\n  return context.type === \"hover\" ? /* @__PURE__ */jsx(ScrollAreaScrollbarHover, { ...scrollbarProps,\n    ref: forwardedRef,\n    forceMount\n  }) : context.type === \"scroll\" ? /* @__PURE__ */jsx(ScrollAreaScrollbarScroll, { ...scrollbarProps,\n    ref: forwardedRef,\n    forceMount\n  }) : context.type === \"auto\" ? /* @__PURE__ */jsx(ScrollAreaScrollbarAuto, { ...scrollbarProps,\n    ref: forwardedRef,\n    forceMount\n  }) : context.type === \"always\" ? /* @__PURE__ */jsx(ScrollAreaScrollbarVisible, { ...scrollbarProps,\n    ref: forwardedRef\n  }) : null;\n});\nScrollAreaScrollbar.displayName = SCROLLBAR_NAME;\nvar ScrollAreaScrollbarHover = React2.forwardRef((props, forwardedRef) => {\n  const {\n    forceMount,\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const [visible, setVisible] = React2.useState(false);\n  React2.useEffect(() => {\n    const scrollArea = context.scrollArea;\n    let hideTimer = 0;\n\n    if (scrollArea) {\n      const handlePointerEnter = () => {\n        window.clearTimeout(hideTimer);\n        setVisible(true);\n      };\n\n      const handlePointerLeave = () => {\n        hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);\n      };\n\n      scrollArea.addEventListener(\"pointerenter\", handlePointerEnter);\n      scrollArea.addEventListener(\"pointerleave\", handlePointerLeave);\n      return () => {\n        window.clearTimeout(hideTimer);\n        scrollArea.removeEventListener(\"pointerenter\", handlePointerEnter);\n        scrollArea.removeEventListener(\"pointerleave\", handlePointerLeave);\n      };\n    }\n  }, [context.scrollArea, context.scrollHideDelay]);\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || visible,\n    children: /* @__PURE__ */jsx(ScrollAreaScrollbarAuto, {\n      \"data-state\": visible ? \"visible\" : \"hidden\",\n      ...scrollbarProps,\n      ref: forwardedRef\n    })\n  });\n});\nvar ScrollAreaScrollbarScroll = React2.forwardRef((props, forwardedRef) => {\n  const {\n    forceMount,\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const isHorizontal = props.orientation === \"horizontal\";\n  const debounceScrollEnd = useDebounceCallback(() => send(\"SCROLL_END\"), 100);\n  const [state, send] = useStateMachine(\"hidden\", {\n    hidden: {\n      SCROLL: \"scrolling\"\n    },\n    scrolling: {\n      SCROLL_END: \"idle\",\n      POINTER_ENTER: \"interacting\"\n    },\n    interacting: {\n      SCROLL: \"interacting\",\n      POINTER_LEAVE: \"idle\"\n    },\n    idle: {\n      HIDE: \"hidden\",\n      SCROLL: \"scrolling\",\n      POINTER_ENTER: \"interacting\"\n    }\n  });\n  React2.useEffect(() => {\n    if (state === \"idle\") {\n      const hideTimer = window.setTimeout(() => send(\"HIDE\"), context.scrollHideDelay);\n      return () => window.clearTimeout(hideTimer);\n    }\n  }, [state, context.scrollHideDelay, send]);\n  React2.useEffect(() => {\n    const viewport = context.viewport;\n    const scrollDirection = isHorizontal ? \"scrollLeft\" : \"scrollTop\";\n\n    if (viewport) {\n      let prevScrollPos = viewport[scrollDirection];\n\n      const handleScroll = () => {\n        const scrollPos = viewport[scrollDirection];\n        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;\n\n        if (hasScrollInDirectionChanged) {\n          send(\"SCROLL\");\n          debounceScrollEnd();\n        }\n\n        prevScrollPos = scrollPos;\n      };\n\n      viewport.addEventListener(\"scroll\", handleScroll);\n      return () => viewport.removeEventListener(\"scroll\", handleScroll);\n    }\n  }, [context.viewport, isHorizontal, send, debounceScrollEnd]);\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || state !== \"hidden\",\n    children: /* @__PURE__ */jsx(ScrollAreaScrollbarVisible, {\n      \"data-state\": state === \"hidden\" ? \"hidden\" : \"visible\",\n      ...scrollbarProps,\n      ref: forwardedRef,\n      onPointerEnter: composeEventHandlers(props.onPointerEnter, () => send(\"POINTER_ENTER\")),\n      onPointerLeave: composeEventHandlers(props.onPointerLeave, () => send(\"POINTER_LEAVE\"))\n    })\n  });\n});\nvar ScrollAreaScrollbarAuto = React2.forwardRef((props, forwardedRef) => {\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const {\n    forceMount,\n    ...scrollbarProps\n  } = props;\n  const [visible, setVisible] = React2.useState(false);\n  const isHorizontal = props.orientation === \"horizontal\";\n  const handleResize = useDebounceCallback(() => {\n    if (context.viewport) {\n      const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;\n      const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;\n      setVisible(isHorizontal ? isOverflowX : isOverflowY);\n    }\n  }, 10);\n  useResizeObserver(context.viewport, handleResize);\n  useResizeObserver(context.content, handleResize);\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || visible,\n    children: /* @__PURE__ */jsx(ScrollAreaScrollbarVisible, {\n      \"data-state\": visible ? \"visible\" : \"hidden\",\n      ...scrollbarProps,\n      ref: forwardedRef\n    })\n  });\n});\nvar ScrollAreaScrollbarVisible = React2.forwardRef((props, forwardedRef) => {\n  const {\n    orientation = \"vertical\",\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const thumbRef = React2.useRef(null);\n  const pointerOffsetRef = React2.useRef(0);\n  const [sizes, setSizes] = React2.useState({\n    content: 0,\n    viewport: 0,\n    scrollbar: {\n      size: 0,\n      paddingStart: 0,\n      paddingEnd: 0\n    }\n  });\n  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);\n  const commonProps = { ...scrollbarProps,\n    sizes,\n    onSizesChange: setSizes,\n    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),\n    onThumbChange: thumb => thumbRef.current = thumb,\n    onThumbPointerUp: () => pointerOffsetRef.current = 0,\n    onThumbPointerDown: pointerPos => pointerOffsetRef.current = pointerPos\n  };\n\n  function getScrollPosition(pointerPos, dir) {\n    return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);\n  }\n\n  if (orientation === \"horizontal\") {\n    return /* @__PURE__ */jsx(ScrollAreaScrollbarX, { ...commonProps,\n      ref: forwardedRef,\n      onThumbPositionChange: () => {\n        if (context.viewport && thumbRef.current) {\n          const scrollPos = context.viewport.scrollLeft;\n          const offset = getThumbOffsetFromScroll(scrollPos, sizes, context.dir);\n          thumbRef.current.style.transform = `translate3d(${offset}px, 0, 0)`;\n        }\n      },\n      onWheelScroll: scrollPos => {\n        if (context.viewport) context.viewport.scrollLeft = scrollPos;\n      },\n      onDragScroll: pointerPos => {\n        if (context.viewport) {\n          context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir);\n        }\n      }\n    });\n  }\n\n  if (orientation === \"vertical\") {\n    return /* @__PURE__ */jsx(ScrollAreaScrollbarY, { ...commonProps,\n      ref: forwardedRef,\n      onThumbPositionChange: () => {\n        if (context.viewport && thumbRef.current) {\n          const scrollPos = context.viewport.scrollTop;\n          const offset = getThumbOffsetFromScroll(scrollPos, sizes);\n          thumbRef.current.style.transform = `translate3d(0, ${offset}px, 0)`;\n        }\n      },\n      onWheelScroll: scrollPos => {\n        if (context.viewport) context.viewport.scrollTop = scrollPos;\n      },\n      onDragScroll: pointerPos => {\n        if (context.viewport) context.viewport.scrollTop = getScrollPosition(pointerPos);\n      }\n    });\n  }\n\n  return null;\n});\nvar ScrollAreaScrollbarX = React2.forwardRef((props, forwardedRef) => {\n  const {\n    sizes,\n    onSizesChange,\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const [computedStyle, setComputedStyle] = React2.useState();\n  const ref = React2.useRef(null);\n  const composeRefs = useComposedRefs(forwardedRef, ref, context.onScrollbarXChange);\n  React2.useEffect(() => {\n    if (ref.current) setComputedStyle(getComputedStyle(ref.current));\n  }, [ref]);\n  return /* @__PURE__ */jsx(ScrollAreaScrollbarImpl, {\n    \"data-orientation\": \"horizontal\",\n    ...scrollbarProps,\n    ref: composeRefs,\n    sizes,\n    style: {\n      bottom: 0,\n      left: context.dir === \"rtl\" ? \"var(--radix-scroll-area-corner-width)\" : 0,\n      right: context.dir === \"ltr\" ? \"var(--radix-scroll-area-corner-width)\" : 0,\n      [\"--radix-scroll-area-thumb-width\"]: getThumbSize(sizes) + \"px\",\n      ...props.style\n    },\n    onThumbPointerDown: pointerPos => props.onThumbPointerDown(pointerPos.x),\n    onDragScroll: pointerPos => props.onDragScroll(pointerPos.x),\n    onWheelScroll: (event, maxScrollPos) => {\n      if (context.viewport) {\n        const scrollPos = context.viewport.scrollLeft + event.deltaX;\n        props.onWheelScroll(scrollPos);\n\n        if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {\n          event.preventDefault();\n        }\n      }\n    },\n    onResize: () => {\n      if (ref.current && context.viewport && computedStyle) {\n        onSizesChange({\n          content: context.viewport.scrollWidth,\n          viewport: context.viewport.offsetWidth,\n          scrollbar: {\n            size: ref.current.clientWidth,\n            paddingStart: toInt(computedStyle.paddingLeft),\n            paddingEnd: toInt(computedStyle.paddingRight)\n          }\n        });\n      }\n    }\n  });\n});\nvar ScrollAreaScrollbarY = React2.forwardRef((props, forwardedRef) => {\n  const {\n    sizes,\n    onSizesChange,\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const [computedStyle, setComputedStyle] = React2.useState();\n  const ref = React2.useRef(null);\n  const composeRefs = useComposedRefs(forwardedRef, ref, context.onScrollbarYChange);\n  React2.useEffect(() => {\n    if (ref.current) setComputedStyle(getComputedStyle(ref.current));\n  }, [ref]);\n  return /* @__PURE__ */jsx(ScrollAreaScrollbarImpl, {\n    \"data-orientation\": \"vertical\",\n    ...scrollbarProps,\n    ref: composeRefs,\n    sizes,\n    style: {\n      top: 0,\n      right: context.dir === \"ltr\" ? 0 : void 0,\n      left: context.dir === \"rtl\" ? 0 : void 0,\n      bottom: \"var(--radix-scroll-area-corner-height)\",\n      [\"--radix-scroll-area-thumb-height\"]: getThumbSize(sizes) + \"px\",\n      ...props.style\n    },\n    onThumbPointerDown: pointerPos => props.onThumbPointerDown(pointerPos.y),\n    onDragScroll: pointerPos => props.onDragScroll(pointerPos.y),\n    onWheelScroll: (event, maxScrollPos) => {\n      if (context.viewport) {\n        const scrollPos = context.viewport.scrollTop + event.deltaY;\n        props.onWheelScroll(scrollPos);\n\n        if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {\n          event.preventDefault();\n        }\n      }\n    },\n    onResize: () => {\n      if (ref.current && context.viewport && computedStyle) {\n        onSizesChange({\n          content: context.viewport.scrollHeight,\n          viewport: context.viewport.offsetHeight,\n          scrollbar: {\n            size: ref.current.clientHeight,\n            paddingStart: toInt(computedStyle.paddingTop),\n            paddingEnd: toInt(computedStyle.paddingBottom)\n          }\n        });\n      }\n    }\n  });\n});\nvar [ScrollbarProvider, useScrollbarContext] = createScrollAreaContext(SCROLLBAR_NAME);\nvar ScrollAreaScrollbarImpl = React2.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeScrollArea,\n    sizes,\n    hasThumb,\n    onThumbChange,\n    onThumbPointerUp,\n    onThumbPointerDown,\n    onThumbPositionChange,\n    onDragScroll,\n    onWheelScroll,\n    onResize,\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea);\n  const [scrollbar, setScrollbar] = React2.useState(null);\n  const composeRefs = useComposedRefs(forwardedRef, node => setScrollbar(node));\n  const rectRef = React2.useRef(null);\n  const prevWebkitUserSelectRef = React2.useRef(\"\");\n  const viewport = context.viewport;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const handleWheelScroll = useCallbackRef(onWheelScroll);\n  const handleThumbPositionChange = useCallbackRef(onThumbPositionChange);\n  const handleResize = useDebounceCallback(onResize, 10);\n\n  function handleDragScroll(event) {\n    if (rectRef.current) {\n      const x = event.clientX - rectRef.current.left;\n      const y = event.clientY - rectRef.current.top;\n      onDragScroll({\n        x,\n        y\n      });\n    }\n  }\n\n  React2.useEffect(() => {\n    const handleWheel = event => {\n      const element = event.target;\n      const isScrollbarWheel = scrollbar?.contains(element);\n      if (isScrollbarWheel) handleWheelScroll(event, maxScrollPos);\n    };\n\n    document.addEventListener(\"wheel\", handleWheel, {\n      passive: false\n    });\n    return () => document.removeEventListener(\"wheel\", handleWheel, {\n      passive: false\n    });\n  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);\n  React2.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);\n  useResizeObserver(scrollbar, handleResize);\n  useResizeObserver(context.content, handleResize);\n  return /* @__PURE__ */jsx(ScrollbarProvider, {\n    scope: __scopeScrollArea,\n    scrollbar,\n    hasThumb,\n    onThumbChange: useCallbackRef(onThumbChange),\n    onThumbPointerUp: useCallbackRef(onThumbPointerUp),\n    onThumbPositionChange: handleThumbPositionChange,\n    onThumbPointerDown: useCallbackRef(onThumbPointerDown),\n    children: /* @__PURE__ */jsx(Primitive.div, { ...scrollbarProps,\n      ref: composeRefs,\n      style: {\n        position: \"absolute\",\n        ...scrollbarProps.style\n      },\n      onPointerDown: composeEventHandlers(props.onPointerDown, event => {\n        const mainPointer = 0;\n\n        if (event.button === mainPointer) {\n          const element = event.target;\n          element.setPointerCapture(event.pointerId);\n          rectRef.current = scrollbar.getBoundingClientRect();\n          prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;\n          document.body.style.webkitUserSelect = \"none\";\n          if (context.viewport) context.viewport.style.scrollBehavior = \"auto\";\n          handleDragScroll(event);\n        }\n      }),\n      onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),\n      onPointerUp: composeEventHandlers(props.onPointerUp, event => {\n        const element = event.target;\n\n        if (element.hasPointerCapture(event.pointerId)) {\n          element.releasePointerCapture(event.pointerId);\n        }\n\n        document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;\n        if (context.viewport) context.viewport.style.scrollBehavior = \"\";\n        rectRef.current = null;\n      })\n    })\n  });\n});\nvar THUMB_NAME = \"ScrollAreaThumb\";\nvar ScrollAreaThumb = React2.forwardRef((props, forwardedRef) => {\n  const {\n    forceMount,\n    ...thumbProps\n  } = props;\n  const scrollbarContext = useScrollbarContext(THUMB_NAME, props.__scopeScrollArea);\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || scrollbarContext.hasThumb,\n    children: /* @__PURE__ */jsx(ScrollAreaThumbImpl, {\n      ref: forwardedRef,\n      ...thumbProps\n    })\n  });\n});\nvar ScrollAreaThumbImpl = React2.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeScrollArea,\n    style,\n    ...thumbProps\n  } = props;\n  const scrollAreaContext = useScrollAreaContext(THUMB_NAME, __scopeScrollArea);\n  const scrollbarContext = useScrollbarContext(THUMB_NAME, __scopeScrollArea);\n  const {\n    onThumbPositionChange\n  } = scrollbarContext;\n  const composedRef = useComposedRefs(forwardedRef, node => scrollbarContext.onThumbChange(node));\n  const removeUnlinkedScrollListenerRef = React2.useRef(void 0);\n  const debounceScrollEnd = useDebounceCallback(() => {\n    if (removeUnlinkedScrollListenerRef.current) {\n      removeUnlinkedScrollListenerRef.current();\n      removeUnlinkedScrollListenerRef.current = void 0;\n    }\n  }, 100);\n  React2.useEffect(() => {\n    const viewport = scrollAreaContext.viewport;\n\n    if (viewport) {\n      const handleScroll = () => {\n        debounceScrollEnd();\n\n        if (!removeUnlinkedScrollListenerRef.current) {\n          const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);\n          removeUnlinkedScrollListenerRef.current = listener;\n          onThumbPositionChange();\n        }\n      };\n\n      onThumbPositionChange();\n      viewport.addEventListener(\"scroll\", handleScroll);\n      return () => viewport.removeEventListener(\"scroll\", handleScroll);\n    }\n  }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);\n  return /* @__PURE__ */jsx(Primitive.div, {\n    \"data-state\": scrollbarContext.hasThumb ? \"visible\" : \"hidden\",\n    ...thumbProps,\n    ref: composedRef,\n    style: {\n      width: \"var(--radix-scroll-area-thumb-width)\",\n      height: \"var(--radix-scroll-area-thumb-height)\",\n      ...style\n    },\n    onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, event => {\n      const thumb = event.target;\n      const thumbRect = thumb.getBoundingClientRect();\n      const x = event.clientX - thumbRect.left;\n      const y = event.clientY - thumbRect.top;\n      scrollbarContext.onThumbPointerDown({\n        x,\n        y\n      });\n    }),\n    onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)\n  });\n});\nScrollAreaThumb.displayName = THUMB_NAME;\nvar CORNER_NAME = \"ScrollAreaCorner\";\nvar ScrollAreaCorner = React2.forwardRef((props, forwardedRef) => {\n  const context = useScrollAreaContext(CORNER_NAME, props.__scopeScrollArea);\n  const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);\n  const hasCorner = context.type !== \"scroll\" && hasBothScrollbarsVisible;\n  return hasCorner ? /* @__PURE__ */jsx(ScrollAreaCornerImpl, { ...props,\n    ref: forwardedRef\n  }) : null;\n});\nScrollAreaCorner.displayName = CORNER_NAME;\nvar ScrollAreaCornerImpl = React2.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeScrollArea,\n    ...cornerProps\n  } = props;\n  const context = useScrollAreaContext(CORNER_NAME, __scopeScrollArea);\n  const [width, setWidth] = React2.useState(0);\n  const [height, setHeight] = React2.useState(0);\n  const hasSize = Boolean(width && height);\n  useResizeObserver(context.scrollbarX, () => {\n    const height2 = context.scrollbarX?.offsetHeight || 0;\n    context.onCornerHeightChange(height2);\n    setHeight(height2);\n  });\n  useResizeObserver(context.scrollbarY, () => {\n    const width2 = context.scrollbarY?.offsetWidth || 0;\n    context.onCornerWidthChange(width2);\n    setWidth(width2);\n  });\n  return hasSize ? /* @__PURE__ */jsx(Primitive.div, { ...cornerProps,\n    ref: forwardedRef,\n    style: {\n      width,\n      height,\n      position: \"absolute\",\n      right: context.dir === \"ltr\" ? 0 : void 0,\n      left: context.dir === \"rtl\" ? 0 : void 0,\n      bottom: 0,\n      ...props.style\n    }\n  }) : null;\n});\n\nfunction toInt(value) {\n  return value ? parseInt(value, 10) : 0;\n}\n\nfunction getThumbRatio(viewportSize, contentSize) {\n  const ratio = viewportSize / contentSize;\n  return isNaN(ratio) ? 0 : ratio;\n}\n\nfunction getThumbSize(sizes) {\n  const ratio = getThumbRatio(sizes.viewport, sizes.content);\n  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;\n  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;\n  return Math.max(thumbSize, 18);\n}\n\nfunction getScrollPositionFromPointer(pointerPos, pointerOffset, sizes) {\n  let dir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"ltr\";\n  const thumbSizePx = getThumbSize(sizes);\n  const thumbCenter = thumbSizePx / 2;\n  const offset = pointerOffset || thumbCenter;\n  const thumbOffsetFromEnd = thumbSizePx - offset;\n  const minPointerPos = sizes.scrollbar.paddingStart + offset;\n  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const scrollRange = dir === \"ltr\" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];\n  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);\n  return interpolate(pointerPos);\n}\n\nfunction getThumbOffsetFromScroll(scrollPos, sizes) {\n  let dir = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"ltr\";\n  const thumbSizePx = getThumbSize(sizes);\n  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;\n  const scrollbar = sizes.scrollbar.size - scrollbarPadding;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const maxThumbPos = scrollbar - thumbSizePx;\n  const scrollClampRange = dir === \"ltr\" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];\n  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange);\n  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);\n  return interpolate(scrollWithoutMomentum);\n}\n\nfunction linearScale(input, output) {\n  return value => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\n\nfunction isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {\n  return scrollPos > 0 && scrollPos < maxScrollPos;\n}\n\nvar addUnlinkedScrollListener = function (node) {\n  let handler = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : () => {};\n  let prevPosition = {\n    left: node.scrollLeft,\n    top: node.scrollTop\n  };\n  let rAF = 0;\n\n  (function loop() {\n    const position = {\n      left: node.scrollLeft,\n      top: node.scrollTop\n    };\n    const isHorizontalScroll = prevPosition.left !== position.left;\n    const isVerticalScroll = prevPosition.top !== position.top;\n    if (isHorizontalScroll || isVerticalScroll) handler();\n    prevPosition = position;\n    rAF = window.requestAnimationFrame(loop);\n  })();\n\n  return () => window.cancelAnimationFrame(rAF);\n};\n\nfunction useDebounceCallback(callback, delay) {\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = React2.useRef(0);\n  React2.useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);\n  return React2.useCallback(() => {\n    window.clearTimeout(debounceTimerRef.current);\n    debounceTimerRef.current = window.setTimeout(handleCallback, delay);\n  }, [handleCallback, delay]);\n}\n\nfunction useResizeObserver(element, onResize) {\n  const handleResize = useCallbackRef(onResize);\n  useLayoutEffect(() => {\n    let rAF = 0;\n\n    if (element) {\n      const resizeObserver = new ResizeObserver(() => {\n        cancelAnimationFrame(rAF);\n        rAF = window.requestAnimationFrame(handleResize);\n      });\n      resizeObserver.observe(element);\n      return () => {\n        window.cancelAnimationFrame(rAF);\n        resizeObserver.unobserve(element);\n      };\n    }\n  }, [element, handleResize]);\n}\n\nvar Root = ScrollArea;\nvar Viewport = ScrollAreaViewport;\nvar Scrollbar = ScrollAreaScrollbar;\nvar Thumb = ScrollAreaThumb;\nvar Corner = ScrollAreaCorner;\nexport { Corner, Root, ScrollArea, ScrollAreaCorner, ScrollAreaScrollbar, ScrollAreaThumb, ScrollAreaViewport, Scrollbar, Thumb, Viewport, createScrollAreaScope };","map":{"version":3,"mappings":";;AAEA,YAAYA,MAAZ,MAAuB,OAAvB;AACA,SAASC,SAAT,QAA0B,2BAA1B;AACA,SAASC,QAAT,QAAyB,0BAAzB;AACA,SAASC,kBAAT,QAAmC,yBAAnC;AACA,SAASC,eAAT,QAAgC,8BAAhC;AACA,SAASC,cAAT,QAA+B,kCAA/B;AACA,SAASC,YAAT,QAA6B,2BAA7B;AACA,SAASC,eAAT,QAAgC,mCAAhC;AACA,SAASC,KAAT,QAAsB,kBAAtB;AACA,SAASC,oBAAT,QAAqC,qBAArC,C;;ACXA,YAAYT,KAAZ,MAAuB,OAAvB;;AAWO,SAASU,eAAT,CACLC,YADK,EAELC,OAFK,EAGL;AACA,SAAaZ,iBAAW,CAACa,KAAD,EAAyBC,KAAzB,KAAqE;AAC3F,UAAMC,YAAaH,QAAQC,KAAR,EAAuBC,KAAvB,CAAnB;AACA,WAAOC,aAAaF,KAApB;AACF,GAHa,EAGVF,YAHU,CAAb;AAIF,C;;;AD4FQ,SAqCFK,QArCE,OAqCFC,IArCE;AAhFR,IAAMC,mBAAmB,YAAzB;AAGA,IAAM,CAACC,uBAAD,EAA0BC,qBAA1B,IAAmDjB,mBAAmBe,gBAAnB,CAAzD;AAuBA,IAAM,CAACG,kBAAD,EAAqBC,oBAArB,IACJH,wBAAgDD,gBAAhD,CADF;AAWA,IAAMK,aAAmBC,kBACvB,CAACC,KAAD,EAAsCC,YAAtC,KAAuD;AACrD,QAAM;AACJC,qBADI;AAEJC,WAAO,OAFH;AAGJC,OAHI;AAIJC,sBAAkB,GAJd;AAKJ,OAAGC;AALC,MAMFN,KANJ;AAOA,QAAM,CAACO,UAAD,EAAaC,aAAb,IAAoCT,gBAAmC,IAAnC,CAA1C;AACA,QAAM,CAACU,QAAD,EAAWC,WAAX,IAAgCX,gBAA2C,IAA3C,CAAtC;AACA,QAAM,CAACY,OAAD,EAAUC,UAAV,IAA8Bb,gBAAgC,IAAhC,CAApC;AACA,QAAM,CAACc,UAAD,EAAaC,aAAb,IAAoCf,gBAA4C,IAA5C,CAA1C;AACA,QAAM,CAACgB,UAAD,EAAaC,aAAb,IAAoCjB,gBAA4C,IAA5C,CAA1C;AACA,QAAM,CAACkB,WAAD,EAAcC,cAAd,IAAsCnB,gBAAS,CAAT,CAA5C;AACA,QAAM,CAACoB,YAAD,EAAeC,eAAf,IAAwCrB,gBAAS,CAAT,CAA9C;AACA,QAAM,CAACsB,iBAAD,EAAoBC,oBAApB,IAAkDvB,gBAAS,KAAT,CAAxD;AACA,QAAM,CAACwB,iBAAD,EAAoBC,oBAApB,IAAkDzB,gBAAS,KAAT,CAAxD;AACA,QAAM0B,eAAe9C,gBAAgBsB,YAAhB,EAA+ByB,IAAD,IAAUlB,cAAckB,IAAd,CAAxC,CAArB;AACA,QAAMC,YAAY9C,aAAauB,GAAb,CAAlB;AAEA,SACE,mBAACR,kBAAD,EAAC;AACCgC,WAAO1B,iBADR;AAECC,QAFD;AAGCC,SAAKuB,SAHN;AAICtB,mBAJD;AAKCE,cALD;AAMCE,YAND;AAOCoB,sBAAkBnB,WAPnB;AAQCC,WARD;AASCmB,qBAAiBlB,UATlB;AAUCC,cAVD;AAWCkB,wBAAoBjB,aAXrB;AAYCO,qBAZD;AAaCW,+BAA2BV,oBAb5B;AAcCP,cAdD;AAeCkB,wBAAoBjB,aAfrB;AAgBCO,qBAhBD;AAiBCW,+BAA2BV,oBAjB5B;AAkBCW,yBAAqBjB,cAlBtB;AAmBCkB,0BAAsBhB,eAnBvB;AAqBCiB,iCAAC7D,UAAU8D,GAAX,EAAC;AACClC,WAAKuB,SADN;AAEE,SAAGrB,eAFL;AAGCiC,WAAKd,YAHN;AAICe,aAAO;AACLC,kBAAU,UADL;AACK;AAEV,SAAC,kCAAD,GAA6CxB,cAAc,IAHtD;AAIL,SAAC,mCAAD,GAA8CE,eAAe,IAJxD;AAKL,WAAGnB,MAAMwC;AALJ;AAJR,KAAD;AArBD,GAAD,CADF;AAoCF,CAzDuB,CAAzB;AA4DA1C,WAAW4C,WAAX,GAAyBjD,gBAAzB;AAMA,IAAMkD,gBAAgB,oBAAtB;AAOA,IAAMC,qBAA2B7C,kBAC/B,CAACC,KAAD,EAA8CC,YAA9C,KAA+D;AAC7D,QAAM;AAAEC,qBAAF;AAAqBmC,YAArB;AAA+BQ,SAA/B;AAAsC,OAAGC;AAAzC,MAA2D9C,KAAjE;AACA,QAAM+C,UAAUlD,qBAAqB8C,aAArB,EAAoCzC,iBAApC,CAAhB;AACA,QAAMqC,MAAYxC,cAAkC,IAAlC,CAAlB;AACA,QAAM0B,eAAe9C,gBAAgBsB,YAAhB,EAA8BsC,GAA9B,EAAmCQ,QAAQlB,gBAA3C,CAArB;AACA,SACE;AAEEQ,kCAAC,OAAD,EAAC;AACCW,+BAAyB;AACvBC,gBAAQ;AADe,OAD1B;AAICJ;AAJD,KAAD,GAMA,mBAACrE,UAAU8D,GAAX,EAAC;AACC,yCAAgC,EADjC;AAEE,SAAGQ,aAFL;AAGCP,WAAKd,YAHN;AAICe,aAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYLU,mBAAWH,QAAQ1B,iBAAR,GAA4B,QAA5B,GAAuC,QAZ7C;AAaL8B,mBAAWJ,QAAQxB,iBAAR,GAA4B,QAA5B,GAAuC,QAb7C;AAcL,WAAGvB,MAAMwC;AAdJ,OAJR;AA4BCH,mCAAC,KAAD,EAAC;AAAIE,aAAKQ,QAAQjB,eAAjB;AAAkCU,eAAO;AAAEY,oBAAU,MAAZ;AAAoBC,mBAAS;AAA7B,SAAzC;AACEhB;AADF,OAAD;AA5BD,KAAD,CANA;AAFF,IADF;AA2CF,CAjD+B,CAAjC;AAoDAO,mBAAmBF,WAAnB,GAAiCC,aAAjC;AAMA,IAAMW,iBAAiB,qBAAvB;AAOA,IAAMC,sBAA4BxD,kBAChC,CAACC,KAAD,EAA+CC,YAA/C,KAAgE;AAC9D,QAAM;AAAEuD,cAAF;AAAc,OAAGC;AAAjB,MAAoCzD,KAA1C;AACA,QAAM+C,UAAUlD,qBAAqByD,cAArB,EAAqCtD,MAAME,iBAA3C,CAAhB;AACA,QAAM;AAAE8B,6BAAF;AAA6BE;AAA7B,MAA2Da,OAAjE;AACA,QAAMW,eAAe1D,MAAM2D,WAAN,KAAsB,YAA3C;AAEM5D,mBAAU,MAAM;AACpB2D,mBAAe1B,0BAA0B,IAA1B,CAAf,GAAiDE,0BAA0B,IAA1B,CAAjD;AACA,WAAO,MAAM;AACXwB,qBAAe1B,0BAA0B,KAA1B,CAAf,GAAkDE,0BAA0B,KAA1B,CAAlD;AACF,KAFA;AAGF,GALM,EAKH,CAACwB,YAAD,EAAe1B,yBAAf,EAA0CE,yBAA1C,CALG;AAON,SAAOa,QAAQ5C,IAAR,KAAiB,OAAjB,GACL,mBAACyD,wBAAD,EAAC,EAA0B,GAAGH,cAA7B;AAA6ClB,SAAKtC,YAAlD;AAAgEuD;AAAhE,GAAD,CADK,GAEHT,QAAQ5C,IAAR,KAAiB,QAAjB,GACF,mBAAC0D,yBAAD,EAAC,EAA2B,GAAGJ,cAA9B;AAA8ClB,SAAKtC,YAAnD;AAAiEuD;AAAjE,GAAD,CADE,GAEAT,QAAQ5C,IAAR,KAAiB,MAAjB,GACF,mBAAC2D,uBAAD,EAAC,EAAyB,GAAGL,cAA5B;AAA4ClB,SAAKtC,YAAjD;AAA+DuD;AAA/D,GAAD,CADE,GAEAT,QAAQ5C,IAAR,KAAiB,QAAjB,GACF,mBAAC4D,0BAAD,EAAC,EAA4B,GAAGN,cAA/B;AAA+ClB,SAAKtC;AAApD,GAAD,CADE,GAEA,IARJ;AASF,CAvBgC,CAAlC;AA0BAsD,oBAAoBb,WAApB,GAAkCY,cAAlC;AASA,IAAMM,2BAAiC7D,kBAGrC,CAACC,KAAD,EAAoDC,YAApD,KAAqE;AACrE,QAAM;AAAEuD,cAAF;AAAc,OAAGC;AAAjB,MAAoCzD,KAA1C;AACA,QAAM+C,UAAUlD,qBAAqByD,cAArB,EAAqCtD,MAAME,iBAA3C,CAAhB;AACA,QAAM,CAAC8D,OAAD,EAAUC,UAAV,IAA8BlE,gBAAS,KAAT,CAApC;AAEMA,mBAAU,MAAM;AACpB,UAAMQ,aAAawC,QAAQxC,UAA3B;AACA,QAAI2D,YAAY,CAAhB;;AACA,QAAI3D,UAAJ,EAAgB;AACd,YAAM4D,qBAAqB,MAAM;AAC/BC,eAAOC,YAAP,CAAoBH,SAApB;AACAD,mBAAW,IAAX;AACF,OAHA;;AAIA,YAAMK,qBAAqB,MAAM;AAC/BJ,oBAAYE,OAAOG,UAAP,CAAkB,MAAMN,WAAW,KAAX,CAAxB,EAA2ClB,QAAQ1C,eAAnD,CAAZ;AACF,OAFA;;AAGAE,iBAAWiE,gBAAX,CAA4B,cAA5B,EAA4CL,kBAA5C;AACA5D,iBAAWiE,gBAAX,CAA4B,cAA5B,EAA4CF,kBAA5C;AACA,aAAO,MAAM;AACXF,eAAOC,YAAP,CAAoBH,SAApB;AACA3D,mBAAWkE,mBAAX,CAA+B,cAA/B,EAA+CN,kBAA/C;AACA5D,mBAAWkE,mBAAX,CAA+B,cAA/B,EAA+CH,kBAA/C;AACF,OAJA;AAKF;AACF,GAnBM,EAmBH,CAACvB,QAAQxC,UAAT,EAAqBwC,QAAQ1C,eAA7B,CAnBG;AAqBN,SACE,mBAAC5B,QAAD,EAAC;AAASiG,aAASlB,cAAcQ,OAAhC;AACC3B,iCAACyB,uBAAD,EAAC;AACC,oBAAYE,UAAU,SAAV,GAAsB,QADnC;AAEE,SAAGP,cAFL;AAGClB,WAAKtC;AAHN,KAAD;AADD,GAAD,CADF;AASD,CAtCsC,CAAvC;AA6CA,IAAM4D,4BAAkC9D,kBAGtC,CAACC,KAAD,EAAqDC,YAArD,KAAsE;AACtE,QAAM;AAAEuD,cAAF;AAAc,OAAGC;AAAjB,MAAoCzD,KAA1C;AACA,QAAM+C,UAAUlD,qBAAqByD,cAArB,EAAqCtD,MAAME,iBAA3C,CAAhB;AACA,QAAMwD,eAAe1D,MAAM2D,WAAN,KAAsB,YAA3C;AACA,QAAMgB,oBAAoBC,oBAAoB,MAAMC,KAAK,YAAL,CAA1B,EAA8C,GAA9C,CAA1B;AACA,QAAM,CAACzF,KAAD,EAAQyF,IAAR,IAAgB5F,gBAAgB,QAAhB,EAA0B;AAC9C6F,YAAQ;AACNC,cAAQ;AADF,KADsC;AAI9CC,eAAW;AACTC,kBAAY,MADH;AAETC,qBAAe;AAFN,KAJmC;AAQ9CC,iBAAa;AACXJ,cAAQ,aADG;AAEXK,qBAAe;AAFJ,KARiC;AAY9CC,UAAM;AACJC,YAAM,QADF;AAEJP,cAAQ,WAFJ;AAGJG,qBAAe;AAHX;AAZwC,GAA1B,CAAtB;AAmBMnF,mBAAU,MAAM;AACpB,QAAIX,UAAU,MAAd,EAAsB;AACpB,YAAM8E,YAAYE,OAAOG,UAAP,CAAkB,MAAMM,KAAK,MAAL,CAAxB,EAAsC9B,QAAQ1C,eAA9C,CAAlB;AACA,aAAO,MAAM+D,OAAOC,YAAP,CAAoBH,SAApB,CAAb;AACF;AACF,GALM,EAKH,CAAC9E,KAAD,EAAQ2D,QAAQ1C,eAAhB,EAAiCwE,IAAjC,CALG;AAOA9E,mBAAU,MAAM;AACpB,UAAMU,WAAWsC,QAAQtC,QAAzB;AACA,UAAM8E,kBAAkB7B,eAAe,YAAf,GAA8B,WAAtD;;AAEA,QAAIjD,QAAJ,EAAc;AACZ,UAAI+E,gBAAgB/E,SAAS8E,eAAT,CAApB;;AACA,YAAME,eAAe,MAAM;AACzB,cAAMC,YAAYjF,SAAS8E,eAAT,CAAlB;AACA,cAAMI,8BAA8BH,kBAAkBE,SAAtD;;AACA,YAAIC,2BAAJ,EAAiC;AAC/Bd,eAAK,QAAL;AACAF;AACF;;AACAa,wBAAgBE,SAAhB;AACF,OARA;;AASAjF,eAAS+D,gBAAT,CAA0B,QAA1B,EAAoCiB,YAApC;AACA,aAAO,MAAMhF,SAASgE,mBAAT,CAA6B,QAA7B,EAAuCgB,YAAvC,CAAb;AACF;AACF,GAlBM,EAkBH,CAAC1C,QAAQtC,QAAT,EAAmBiD,YAAnB,EAAiCmB,IAAjC,EAAuCF,iBAAvC,CAlBG;AAoBN,SACE,mBAAClG,QAAD,EAAC;AAASiG,aAASlB,cAAcpE,UAAU,QAA1C;AACCiD,iCAAC0B,0BAAD,EAAC;AACC,oBAAY3E,UAAU,QAAV,GAAqB,QAArB,GAAgC,SAD7C;AAEE,SAAGqE,cAFL;AAGClB,WAAKtC,YAHN;AAIC2F,sBAAgB5G,qBAAqBgB,MAAM4F,cAA3B,EAA2C,MAAMf,KAAK,eAAL,CAAjD,CAJjB;AAKCgB,sBAAgB7G,qBAAqBgB,MAAM6F,cAA3B,EAA2C,MAAMhB,KAAK,eAAL,CAAjD;AALjB,KAAD;AADD,GAAD,CADF;AAWD,CAjEuC,CAAxC;AAwEA,IAAMf,0BAAgC/D,kBAGpC,CAACC,KAAD,EAAmDC,YAAnD,KAAoE;AACpE,QAAM8C,UAAUlD,qBAAqByD,cAArB,EAAqCtD,MAAME,iBAA3C,CAAhB;AACA,QAAM;AAAEsD,cAAF;AAAc,OAAGC;AAAjB,MAAoCzD,KAA1C;AACA,QAAM,CAACgE,OAAD,EAAUC,UAAV,IAA8BlE,gBAAS,KAAT,CAApC;AACA,QAAM2D,eAAe1D,MAAM2D,WAAN,KAAsB,YAA3C;AACA,QAAMmC,eAAelB,oBAAoB,MAAM;AAC7C,QAAI7B,QAAQtC,QAAZ,EAAsB;AACpB,YAAMsF,cAAchD,QAAQtC,QAAR,CAAiBuF,WAAjB,GAA+BjD,QAAQtC,QAAR,CAAiBwF,WAApE;AACA,YAAMC,cAAcnD,QAAQtC,QAAR,CAAiB0F,YAAjB,GAAgCpD,QAAQtC,QAAR,CAAiB2F,YAArE;AACAnC,iBAAWP,eAAeqC,WAAf,GAA6BG,WAAxC;AACF;AACF,GANqB,EAMlB,EANkB,CAArB;AAQAG,oBAAkBtD,QAAQtC,QAA1B,EAAoCqF,YAApC;AACAO,oBAAkBtD,QAAQpC,OAA1B,EAAmCmF,YAAnC;AAEA,SACE,mBAACrH,QAAD,EAAC;AAASiG,aAASlB,cAAcQ,OAAhC;AACC3B,iCAAC0B,0BAAD,EAAC;AACC,oBAAYC,UAAU,SAAV,GAAsB,QADnC;AAEE,SAAGP,cAFL;AAGClB,WAAKtC;AAHN,KAAD;AADD,GAAD,CADF;AASD,CA5BqC,CAAtC;AAsCA,IAAM8D,6BAAmChE,kBAGvC,CAACC,KAAD,EAAsDC,YAAtD,KAAuE;AACvE,QAAM;AAAE0D,kBAAc,UAAhB;AAA4B,OAAGF;AAA/B,MAAkDzD,KAAxD;AACA,QAAM+C,UAAUlD,qBAAqByD,cAArB,EAAqCtD,MAAME,iBAA3C,CAAhB;AACA,QAAMoG,WAAiBvG,cAAsC,IAAtC,CAAvB;AACA,QAAMwG,mBAAyBxG,cAAO,CAAP,CAA/B;AACA,QAAM,CAACyG,KAAD,EAAQC,QAAR,IAA0B1G,gBAAgB;AAC9CY,aAAS,CADqC;AAE9CF,cAAU,CAFoC;AAG9CiG,eAAW;AAAEC,YAAM,CAAR;AAAWC,oBAAc,CAAzB;AAA4BC,kBAAY;AAAxC;AAHmC,GAAhB,CAAhC;AAKA,QAAMC,aAAaC,cAAcP,MAAM/F,QAApB,EAA8B+F,MAAM7F,OAApC,CAAnB;AAGA,QAAMqG,cAAwE,EAC5E,GAAGvD,cADyE;AAE5E+C,SAF4E;AAG5ES,mBAAeR,QAH6D;AAI5ES,cAAUC,QAAQL,aAAa,CAAb,IAAkBA,aAAa,CAAvC,CAJkE;AAK5EM,mBAAgBC,KAAD,IAAYf,SAASgB,OAAT,GAAmBD,KAL8B;AAM5EE,sBAAkB,MAAOhB,iBAAiBe,OAAjB,GAA2B,CANwB;AAO5EE,wBAAqBC,UAAD,IAAiBlB,iBAAiBe,OAAjB,GAA2BG;AAPY,GAA9E;;AAUA,WAASC,iBAAT,CAA2BD,UAA3B,EAA+CrH,GAA/C,EAAgE;AAC9D,WAAOuH,6BAA6BF,UAA7B,EAAyClB,iBAAiBe,OAA1D,EAAmEd,KAAnE,EAA0EpG,GAA1E,CAAP;AACF;;AAEA,MAAIuD,gBAAgB,YAApB,EAAkC;AAChC,WACE,mBAACiE,oBAAD,EAAC,EACE,GAAGZ,WADL;AAECzE,WAAKtC,YAFN;AAGC4H,6BAAuB,MAAM;AAC3B,YAAI9E,QAAQtC,QAAR,IAAoB6F,SAASgB,OAAjC,EAA0C;AACxC,gBAAM5B,YAAY3C,QAAQtC,QAAR,CAAiBqH,UAAnC;AACA,gBAAMC,SAASC,yBAAyBtC,SAAzB,EAAoCc,KAApC,EAA2CzD,QAAQ3C,GAAnD,CAAf;AACAkG,mBAASgB,OAAT,CAAiB9E,KAAjB,CAAuByF,SAAvB,GAAmC,eAAeF,MAAM,WAAxD;AACF;AACF,OATD;AAUCG,qBAAgBxC,SAAD,IAAe;AAC5B,YAAI3C,QAAQtC,QAAZ,EAAsBsC,QAAQtC,QAAR,CAAiBqH,UAAjB,GAA8BpC,SAA9B;AACxB,OAZD;AAaCyC,oBAAeV,UAAD,IAAgB;AAC5B,YAAI1E,QAAQtC,QAAZ,EAAsB;AACpBsC,kBAAQtC,QAAR,CAAiBqH,UAAjB,GAA8BJ,kBAAkBD,UAAlB,EAA8B1E,QAAQ3C,GAAtC,CAA9B;AACF;AACF;AAjBD,KAAD,CADF;AAqBF;;AAEA,MAAIuD,gBAAgB,UAApB,EAAgC;AAC9B,WACE,mBAACyE,oBAAD,EAAC,EACE,GAAGpB,WADL;AAECzE,WAAKtC,YAFN;AAGC4H,6BAAuB,MAAM;AAC3B,YAAI9E,QAAQtC,QAAR,IAAoB6F,SAASgB,OAAjC,EAA0C;AACxC,gBAAM5B,YAAY3C,QAAQtC,QAAR,CAAiB4H,SAAnC;AACA,gBAAMN,SAASC,yBAAyBtC,SAAzB,EAAoCc,KAApC,CAAf;AACAF,mBAASgB,OAAT,CAAiB9E,KAAjB,CAAuByF,SAAvB,GAAmC,kBAAkBF,MAAM,QAA3D;AACF;AACF,OATD;AAUCG,qBAAgBxC,SAAD,IAAe;AAC5B,YAAI3C,QAAQtC,QAAZ,EAAsBsC,QAAQtC,QAAR,CAAiB4H,SAAjB,GAA6B3C,SAA7B;AACxB,OAZD;AAaCyC,oBAAeV,UAAD,IAAgB;AAC5B,YAAI1E,QAAQtC,QAAZ,EAAsBsC,QAAQtC,QAAR,CAAiB4H,SAAjB,GAA6BX,kBAAkBD,UAAlB,CAA7B;AACxB;AAfD,KAAD,CADF;AAmBF;;AAEA,SAAO,IAAP;AACD,CA7EwC,CAAzC;AAkGA,IAAMG,uBAA6B7H,kBAGjC,CAACC,KAAD,EAAmDC,YAAnD,KAAoE;AACpE,QAAM;AAAEuG,SAAF;AAASS,iBAAT;AAAwB,OAAGxD;AAA3B,MAA8CzD,KAApD;AACA,QAAM+C,UAAUlD,qBAAqByD,cAArB,EAAqCtD,MAAME,iBAA3C,CAAhB;AACA,QAAM,CAACoI,aAAD,EAAgBC,gBAAhB,IAA0CxI,iBAAhD;AACA,QAAMwC,MAAYxC,cAAuC,IAAvC,CAAlB;AACA,QAAMyI,cAAc7J,gBAAgBsB,YAAhB,EAA8BsC,GAA9B,EAAmCQ,QAAQhB,kBAA3C,CAApB;AAEMhC,mBAAU,MAAM;AACpB,QAAIwC,IAAI+E,OAAR,EAAiBiB,iBAAiBE,iBAAiBlG,IAAI+E,OAArB,CAAjB;AACnB,GAFM,EAEH,CAAC/E,GAAD,CAFG;AAIN,SACE,mBAACmG,uBAAD,EAAC;AACC,wBAAiB,YADlB;AAEE,OAAGjF,cAFL;AAGClB,SAAKiG,WAHN;AAIChC,SAJD;AAKChE,WAAO;AACLmG,cAAQ,CADH;AAELC,YAAM7F,QAAQ3C,GAAR,KAAgB,KAAhB,GAAwB,uCAAxB,GAAkE,CAFnE;AAGLyI,aAAO9F,QAAQ3C,GAAR,KAAgB,KAAhB,GAAwB,uCAAxB,GAAkE,CAHpE;AAIL,OAAC,iCAAD,GAA4C0I,aAAatC,KAAb,IAAsB,IAJ7D;AAKL,SAAGxG,MAAMwC;AALJ,KALR;AAYCgF,wBAAqBC,UAAD,IAAgBzH,MAAMwH,kBAAN,CAAyBC,WAAWsB,CAApC,CAZrC;AAaCZ,kBAAeV,UAAD,IAAgBzH,MAAMmI,YAAN,CAAmBV,WAAWsB,CAA9B,CAb/B;AAcCb,mBAAe,CAAC7I,KAAD,EAAQ2J,YAAR,KAAyB;AACtC,UAAIjG,QAAQtC,QAAZ,EAAsB;AACpB,cAAMiF,YAAY3C,QAAQtC,QAAR,CAAiBqH,UAAjB,GAA8BzI,MAAM4J,MAAtD;AACAjJ,cAAMkI,aAAN,CAAoBxC,SAApB;;AAEA,YAAIwD,iCAAiCxD,SAAjC,EAA4CsD,YAA5C,CAAJ,EAA+D;AAC7D3J,gBAAM8J,cAAN;AACF;AACF;AACF,KAvBD;AAwBCC,cAAU,MAAM;AACd,UAAI7G,IAAI+E,OAAJ,IAAevE,QAAQtC,QAAvB,IAAmC6H,aAAvC,EAAsD;AACpDrB,sBAAc;AACZtG,mBAASoC,QAAQtC,QAAR,CAAiBwF,WADd;AAEZxF,oBAAUsC,QAAQtC,QAAR,CAAiBuF,WAFf;AAGZU,qBAAW;AACTC,kBAAMpE,IAAI+E,OAAJ,CAAY+B,WADT;AAETzC,0BAAc0C,MAAMhB,cAAciB,WAApB,CAFL;AAGT1C,wBAAYyC,MAAMhB,cAAckB,YAApB;AAHH;AAHC,SAAd;AASF;AACF;AApCD,GAAD,CADF;AAwCD,CAtDkC,CAAnC;AAwDA,IAAMpB,uBAA6BrI,kBAGjC,CAACC,KAAD,EAAmDC,YAAnD,KAAoE;AACpE,QAAM;AAAEuG,SAAF;AAASS,iBAAT;AAAwB,OAAGxD;AAA3B,MAA8CzD,KAApD;AACA,QAAM+C,UAAUlD,qBAAqByD,cAArB,EAAqCtD,MAAME,iBAA3C,CAAhB;AACA,QAAM,CAACoI,aAAD,EAAgBC,gBAAhB,IAA0CxI,iBAAhD;AACA,QAAMwC,MAAYxC,cAAuC,IAAvC,CAAlB;AACA,QAAMyI,cAAc7J,gBAAgBsB,YAAhB,EAA8BsC,GAA9B,EAAmCQ,QAAQd,kBAA3C,CAApB;AAEMlC,mBAAU,MAAM;AACpB,QAAIwC,IAAI+E,OAAR,EAAiBiB,iBAAiBE,iBAAiBlG,IAAI+E,OAArB,CAAjB;AACnB,GAFM,EAEH,CAAC/E,GAAD,CAFG;AAIN,SACE,mBAACmG,uBAAD,EAAC;AACC,wBAAiB,UADlB;AAEE,OAAGjF,cAFL;AAGClB,SAAKiG,WAHN;AAIChC,SAJD;AAKChE,WAAO;AACLiH,WAAK,CADA;AAELZ,aAAO9F,QAAQ3C,GAAR,KAAgB,KAAhB,GAAwB,CAAxB,GAA4B,MAF9B;AAGLwI,YAAM7F,QAAQ3C,GAAR,KAAgB,KAAhB,GAAwB,CAAxB,GAA4B,MAH7B;AAILuI,cAAQ,wCAJH;AAKL,OAAC,kCAAD,GAA6CG,aAAatC,KAAb,IAAsB,IAL9D;AAML,SAAGxG,MAAMwC;AANJ,KALR;AAaCgF,wBAAqBC,UAAD,IAAgBzH,MAAMwH,kBAAN,CAAyBC,WAAWiC,CAApC,CAbrC;AAcCvB,kBAAeV,UAAD,IAAgBzH,MAAMmI,YAAN,CAAmBV,WAAWiC,CAA9B,CAd/B;AAeCxB,mBAAe,CAAC7I,KAAD,EAAQ2J,YAAR,KAAyB;AACtC,UAAIjG,QAAQtC,QAAZ,EAAsB;AACpB,cAAMiF,YAAY3C,QAAQtC,QAAR,CAAiB4H,SAAjB,GAA6BhJ,MAAMsK,MAArD;AACA3J,cAAMkI,aAAN,CAAoBxC,SAApB;;AAEA,YAAIwD,iCAAiCxD,SAAjC,EAA4CsD,YAA5C,CAAJ,EAA+D;AAC7D3J,gBAAM8J,cAAN;AACF;AACF;AACF,KAxBD;AAyBCC,cAAU,MAAM;AACd,UAAI7G,IAAI+E,OAAJ,IAAevE,QAAQtC,QAAvB,IAAmC6H,aAAvC,EAAsD;AACpDrB,sBAAc;AACZtG,mBAASoC,QAAQtC,QAAR,CAAiB2F,YADd;AAEZ3F,oBAAUsC,QAAQtC,QAAR,CAAiB0F,YAFf;AAGZO,qBAAW;AACTC,kBAAMpE,IAAI+E,OAAJ,CAAYsC,YADT;AAEThD,0BAAc0C,MAAMhB,cAAcuB,UAApB,CAFL;AAGThD,wBAAYyC,MAAMhB,cAAcwB,aAApB;AAHH;AAHC,SAAd;AASF;AACF;AArCD,GAAD,CADF;AAyCD,CAvDkC,CAAnC;AAoEA,IAAM,CAACC,iBAAD,EAAoBC,mBAApB,IACJtK,wBAA0C4D,cAA1C,CADF;AAmBA,IAAMoF,0BAAgC3I,kBAGpC,CAACC,KAAD,EAAmDC,YAAnD,KAAoE;AACpE,QAAM;AACJC,qBADI;AAEJsG,SAFI;AAGJU,YAHI;AAIJE,iBAJI;AAKJG,oBALI;AAMJC,sBANI;AAOJK,yBAPI;AAQJM,gBARI;AASJD,iBATI;AAUJkB,YAVI;AAWJ,OAAG3F;AAXC,MAYFzD,KAZJ;AAaA,QAAM+C,UAAUlD,qBAAqByD,cAArB,EAAqCpD,iBAArC,CAAhB;AACA,QAAM,CAACwG,SAAD,EAAYuD,YAAZ,IAAkClK,gBAA4C,IAA5C,CAAxC;AACA,QAAMyI,cAAc7J,gBAAgBsB,YAAhB,EAA+ByB,IAAD,IAAUuI,aAAavI,IAAb,CAAxC,CAApB;AACA,QAAMwI,UAAgBnK,cAAuB,IAAvB,CAAtB;AACA,QAAMoK,0BAAgCpK,cAAe,EAAf,CAAtC;AACA,QAAMU,WAAWsC,QAAQtC,QAAzB;AACA,QAAMuI,eAAexC,MAAM7F,OAAN,GAAgB6F,MAAM/F,QAA3C;AACA,QAAM2J,oBAAoBxL,eAAesJ,aAAf,CAA1B;AACA,QAAMmC,4BAA4BzL,eAAeiJ,qBAAf,CAAlC;AACA,QAAM/B,eAAelB,oBAAoBwE,QAApB,EAA8B,EAA9B,CAArB;;AAEA,WAASkB,gBAAT,CAA0BjL,KAA1B,EAAkE;AAChE,QAAI6K,QAAQ5C,OAAZ,EAAqB;AACnB,YAAMyB,IAAI1J,MAAMkL,OAAN,GAAgBL,QAAQ5C,OAAR,CAAgBsB,IAA1C;AACA,YAAMc,IAAIrK,MAAMmL,OAAN,GAAgBN,QAAQ5C,OAAR,CAAgBmC,GAA1C;AACAtB,mBAAa;AAAEY,SAAF;AAAKW;AAAL,OAAb;AACF;AACF;;AAMM3J,mBAAU,MAAM;AACpB,UAAM0K,cAAepL,KAAD,IAAuB;AACzC,YAAMqL,UAAUrL,MAAMsL,MAAtB;AACA,YAAMC,mBAAmBlE,WAAWmE,QAAX,CAAoBH,OAApB,CAAzB;AACA,UAAIE,gBAAJ,EAAsBR,kBAAkB/K,KAAlB,EAAyB2J,YAAzB;AACxB,KAJA;;AAKA8B,aAAStG,gBAAT,CAA0B,OAA1B,EAAmCiG,WAAnC,EAAgD;AAAEM,eAAS;AAAX,KAAhD;AACA,WAAO,MAAMD,SAASrG,mBAAT,CAA6B,OAA7B,EAAsCgG,WAAtC,EAAmD;AAAEM,eAAS;AAAX,KAAnD,CAAb;AACF,GARM,EAQH,CAACtK,QAAD,EAAWiG,SAAX,EAAsBsC,YAAtB,EAAoCoB,iBAApC,CARG;AAaArK,mBAAUsK,yBAAV,EAAqC,CAAC7D,KAAD,EAAQ6D,yBAAR,CAArC;AAENhE,oBAAkBK,SAAlB,EAA6BZ,YAA7B;AACAO,oBAAkBtD,QAAQpC,OAA1B,EAAmCmF,YAAnC;AAEA,SACE,mBAACiE,iBAAD,EAAC;AACCnI,WAAO1B,iBADR;AAECwG,aAFD;AAGCQ,YAHD;AAICE,mBAAexI,eAAewI,aAAf,CAJhB;AAKCG,sBAAkB3I,eAAe2I,gBAAf,CALnB;AAMCM,2BAAuBwC,yBANxB;AAOC7C,wBAAoB5I,eAAe4I,kBAAf,CAPrB;AASCnF,iCAAC7D,UAAU8D,GAAX,EAAC,EACE,GAAGmB,cADL;AAEClB,WAAKiG,WAFN;AAGChG,aAAO;AAAEC,kBAAU,UAAZ;AAAwB,WAAGgB,eAAejB;AAA1C,OAHR;AAICwI,qBAAehM,qBAAqBgB,MAAMgL,aAA3B,EAA2C3L,KAAD,IAAW;AAClE,cAAM4L,cAAc,CAApB;;AACA,YAAI5L,MAAM6L,MAAN,KAAiBD,WAArB,EAAkC;AAChC,gBAAMP,UAAUrL,MAAMsL,MAAtB;AACAD,kBAAQS,iBAAR,CAA0B9L,MAAM+L,SAAhC;AACAlB,kBAAQ5C,OAAR,GAAkBZ,UAAW2E,qBAAX,EAAlB;AAGAlB,kCAAwB7C,OAAxB,GAAkCwD,SAASQ,IAAT,CAAc9I,KAAd,CAAoB+I,gBAAtD;AACAT,mBAASQ,IAAT,CAAc9I,KAAd,CAAoB+I,gBAApB,GAAuC,MAAvC;AACA,cAAIxI,QAAQtC,QAAZ,EAAsBsC,QAAQtC,QAAR,CAAiB+B,KAAjB,CAAuBgJ,cAAvB,GAAwC,MAAxC;AACtBlB,2BAAiBjL,KAAjB;AACF;AACD,OAbc,CAJhB;AAkBCoM,qBAAezM,qBAAqBgB,MAAMyL,aAA3B,EAA0CnB,gBAA1C,CAlBhB;AAmBCoB,mBAAa1M,qBAAqBgB,MAAM0L,WAA3B,EAAyCrM,KAAD,IAAW;AAC9D,cAAMqL,UAAUrL,MAAMsL,MAAtB;;AACA,YAAID,QAAQiB,iBAAR,CAA0BtM,MAAM+L,SAAhC,CAAJ,EAAgD;AAC9CV,kBAAQkB,qBAAR,CAA8BvM,MAAM+L,SAApC;AACF;;AACAN,iBAASQ,IAAT,CAAc9I,KAAd,CAAoB+I,gBAApB,GAAuCpB,wBAAwB7C,OAA/D;AACA,YAAIvE,QAAQtC,QAAZ,EAAsBsC,QAAQtC,QAAR,CAAiB+B,KAAjB,CAAuBgJ,cAAvB,GAAwC,EAAxC;AACtBtB,gBAAQ5C,OAAR,GAAkB,IAAlB;AACD,OARY;AAnBd,KAAD;AATD,GAAD,CADF;AAyCD,CAnGqC,CAAtC;AAyGA,IAAMuE,aAAa,iBAAnB;AAWA,IAAMC,kBAAwB/L,kBAC5B,CAACC,KAAD,EAA2CC,YAA3C,KAA4D;AAC1D,QAAM;AAAEuD,cAAF;AAAc,OAAGuI;AAAjB,MAAgC/L,KAAtC;AACA,QAAMgM,mBAAmBhC,oBAAoB6B,UAApB,EAAgC7L,MAAME,iBAAtC,CAAzB;AACA,SACE,mBAACzB,QAAD,EAAC;AAASiG,aAASlB,cAAcwI,iBAAiB9E,QAAjD;AACC7E,iCAAC4J,mBAAD,EAAC;AAAoB1J,WAAKtC,YAAzB;AAAwC,SAAG8L;AAA3C,KAAD;AADD,GAAD,CADF;AAKF,CAT4B,CAA9B;AAeA,IAAME,sBAA4BlM,kBAChC,CAACC,KAAD,EAA+CC,YAA/C,KAAgE;AAC9D,QAAM;AAAEC,qBAAF;AAAqBsC,SAArB;AAA4B,OAAGuJ;AAA/B,MAA8C/L,KAApD;AACA,QAAMkM,oBAAoBrM,qBAAqBgM,UAArB,EAAiC3L,iBAAjC,CAA1B;AACA,QAAM8L,mBAAmBhC,oBAAoB6B,UAApB,EAAgC3L,iBAAhC,CAAzB;AACA,QAAM;AAAE2H;AAAF,MAA4BmE,gBAAlC;AACA,QAAMG,cAAcxN,gBAAgBsB,YAAhB,EAA+ByB,IAAD,IAChDsK,iBAAiB5E,aAAjB,CAA+B1F,IAA/B,CADkB,CAApB;AAGA,QAAM0K,kCAAwCrM,cAAmB,MAAnB,CAA9C;AACA,QAAM4E,oBAAoBC,oBAAoB,MAAM;AAClD,QAAIwH,gCAAgC9E,OAApC,EAA6C;AAC3C8E,sCAAgC9E,OAAhC;AACA8E,sCAAgC9E,OAAhC,GAA0C,MAA1C;AACF;AACF,GAL0B,EAKvB,GALuB,CAA1B;AAOMvH,mBAAU,MAAM;AACpB,UAAMU,WAAWyL,kBAAkBzL,QAAnC;;AACA,QAAIA,QAAJ,EAAc;AAQZ,YAAMgF,eAAe,MAAM;AACzBd;;AACA,YAAI,CAACyH,gCAAgC9E,OAArC,EAA8C;AAC5C,gBAAM+E,WAAWC,0BAA0B7L,QAA1B,EAAoCoH,qBAApC,CAAjB;AACAuE,0CAAgC9E,OAAhC,GAA0C+E,QAA1C;AACAxE;AACF;AACF,OAPA;;AAQAA;AACApH,eAAS+D,gBAAT,CAA0B,QAA1B,EAAoCiB,YAApC;AACA,aAAO,MAAMhF,SAASgE,mBAAT,CAA6B,QAA7B,EAAuCgB,YAAvC,CAAb;AACF;AACF,GAtBM,EAsBH,CAACyG,kBAAkBzL,QAAnB,EAA6BkE,iBAA7B,EAAgDkD,qBAAhD,CAtBG;AAwBN,SACE,mBAACrJ,UAAU8D,GAAX,EAAC;AACC,kBAAY0J,iBAAiB9E,QAAjB,GAA4B,SAA5B,GAAwC,QADrD;AAEE,OAAG6E,UAFL;AAGCxJ,SAAK4J,WAHN;AAIC3J,WAAO;AACL+J,aAAO,sCADF;AAELC,cAAQ,uCAFH;AAGL,SAAGhK;AAHE,KAJR;AASCiK,0BAAsBzN,qBAAqBgB,MAAMyM,oBAA3B,EAAkDpN,KAAD,IAAW;AAChF,YAAMgI,QAAQhI,MAAMsL,MAApB;AACA,YAAM+B,YAAYrF,MAAMgE,qBAAN,EAAlB;AACA,YAAMtC,IAAI1J,MAAMkL,OAAN,GAAgBmC,UAAU9D,IAApC;AACA,YAAMc,IAAIrK,MAAMmL,OAAN,GAAgBkC,UAAUjD,GAApC;AACAuC,uBAAiBxE,kBAAjB,CAAoC;AAAEuB,SAAF;AAAKW;AAAL,OAApC;AACD,KANqB,CATvB;AAgBCgC,iBAAa1M,qBAAqBgB,MAAM0L,WAA3B,EAAwCM,iBAAiBzE,gBAAzD;AAhBd,GAAD,CADF;AAoBF,CA7DgC,CAAlC;AAgEAuE,gBAAgBpJ,WAAhB,GAA8BmJ,UAA9B;AAMA,IAAMc,cAAc,kBAApB;AAKA,IAAMC,mBAAyB7M,kBAC7B,CAACC,KAAD,EAA4CC,YAA5C,KAA6D;AAC3D,QAAM8C,UAAUlD,qBAAqB8M,WAArB,EAAkC3M,MAAME,iBAAxC,CAAhB;AACA,QAAM2M,2BAA2B1F,QAAQpE,QAAQlC,UAAR,IAAsBkC,QAAQhC,UAAtC,CAAjC;AACA,QAAM+L,YAAY/J,QAAQ5C,IAAR,KAAiB,QAAjB,IAA6B0M,wBAA/C;AACA,SAAOC,YAAY,mBAACC,oBAAD,EAAC,EAAsB,GAAG/M,KAAzB;AAAgCuC,SAAKtC;AAArC,GAAD,CAAZ,GAAqE,IAA5E;AACF,CAN6B,CAA/B;AASA2M,iBAAiBlK,WAAjB,GAA+BiK,WAA/B;AAOA,IAAMI,uBAA6BhN,kBAGjC,CAACC,KAAD,EAAgDC,YAAhD,KAAiE;AACjE,QAAM;AAAEC,qBAAF;AAAqB,OAAG8M;AAAxB,MAAwChN,KAA9C;AACA,QAAM+C,UAAUlD,qBAAqB8M,WAArB,EAAkCzM,iBAAlC,CAAhB;AACA,QAAM,CAACqM,KAAD,EAAQU,QAAR,IAA0BlN,gBAAS,CAAT,CAAhC;AACA,QAAM,CAACyM,MAAD,EAASU,SAAT,IAA4BnN,gBAAS,CAAT,CAAlC;AACA,QAAMoN,UAAUhG,QAAQoF,SAASC,MAAjB,CAAhB;AAEAnG,oBAAkBtD,QAAQlC,UAA1B,EAAsC,MAAM;AAC1C,UAAM2L,UAASzJ,QAAQlC,UAAR,EAAoBsF,YAApB,IAAoC,CAAnD;AACApD,YAAQX,oBAAR,CAA6BoK,OAA7B;AACAU,cAAUV,OAAV;AACD,GAJD;AAMAnG,oBAAkBtD,QAAQhC,UAA1B,EAAsC,MAAM;AAC1C,UAAMwL,SAAQxJ,QAAQhC,UAAR,EAAoBiF,WAApB,IAAmC,CAAjD;AACAjD,YAAQZ,mBAAR,CAA4BoK,MAA5B;AACAU,aAASV,MAAT;AACD,GAJD;AAMA,SAAOY,UACL,mBAAC3O,UAAU8D,GAAX,EAAC,EACE,GAAG0K,WADL;AAECzK,SAAKtC,YAFN;AAGCuC,WAAO;AACL+J,WADK;AAELC,YAFK;AAGL/J,gBAAU,UAHL;AAILoG,aAAO9F,QAAQ3C,GAAR,KAAgB,KAAhB,GAAwB,CAAxB,GAA4B,MAJ9B;AAKLwI,YAAM7F,QAAQ3C,GAAR,KAAgB,KAAhB,GAAwB,CAAxB,GAA4B,MAL7B;AAMLuI,cAAQ,CANH;AAOL,SAAG3I,MAAMwC;AAPJ;AAHR,GAAD,CADK,GAcH,IAdJ;AAeD,CArCkC,CAAnC;;AAyCA,SAAS8G,KAAT,CAAe8D,KAAf,EAA+B;AAC7B,SAAOA,QAAQC,SAASD,KAAT,EAAgB,EAAhB,CAAR,GAA8B,CAArC;AACF;;AAEA,SAASrG,aAAT,CAAuBuG,YAAvB,EAA6CC,WAA7C,EAAkE;AAChE,QAAMC,QAAQF,eAAeC,WAA7B;AACA,SAAOE,MAAMD,KAAN,IAAe,CAAf,GAAmBA,KAA1B;AACF;;AAEA,SAAS1E,YAAT,CAAsBtC,KAAtB,EAAoC;AAClC,QAAMgH,QAAQzG,cAAcP,MAAM/F,QAApB,EAA8B+F,MAAM7F,OAApC,CAAd;AACA,QAAM+M,mBAAmBlH,MAAME,SAAN,CAAgBE,YAAhB,GAA+BJ,MAAME,SAAN,CAAgBG,UAAxE;AACA,QAAM8G,aAAanH,MAAME,SAAN,CAAgBC,IAAhB,GAAuB+G,gBAApC,IAAwDF,KAA9D;AAEA,SAAOI,KAAKC,GAAL,CAASF,SAAT,EAAoB,EAApB,CAAP;AACF;;AAEA,SAAShG,4BAAT,CACEF,UADF,EAEEqG,aAFF,EAGEtH,KAHF,EAKE;AAAA,MADApG,GACA,uEADiB,KACjB;AACA,QAAM2N,cAAcjF,aAAatC,KAAb,CAApB;AACA,QAAMwH,cAAcD,cAAc,CAAlC;AACA,QAAMhG,SAAS+F,iBAAiBE,WAAhC;AACA,QAAMC,qBAAqBF,cAAchG,MAAzC;AACA,QAAMmG,gBAAgB1H,MAAME,SAAN,CAAgBE,YAAhB,GAA+BmB,MAArD;AACA,QAAMoG,gBAAgB3H,MAAME,SAAN,CAAgBC,IAAhB,GAAuBH,MAAME,SAAN,CAAgBG,UAAvC,GAAoDoH,kBAA1E;AACA,QAAMjF,eAAexC,MAAM7F,OAAN,GAAgB6F,MAAM/F,QAA3C;AACA,QAAM2N,cAAchO,QAAQ,KAAR,GAAgB,CAAC,CAAD,EAAI4I,YAAJ,CAAhB,GAAoC,CAACA,eAAe,EAAhB,EAAoB,CAApB,CAAxD;AACA,QAAMqF,cAAcC,YAAY,CAACJ,aAAD,EAAgBC,aAAhB,CAAZ,EAA4CC,WAA5C,CAApB;AACA,SAAOC,YAAY5G,UAAZ,CAAP;AACF;;AAEA,SAASO,wBAAT,CAAkCtC,SAAlC,EAAqDc,KAArD,EAA2F;AAAA,MAAxBpG,GAAwB,uEAAP,KAAO;AACzF,QAAM2N,cAAcjF,aAAatC,KAAb,CAApB;AACA,QAAMkH,mBAAmBlH,MAAME,SAAN,CAAgBE,YAAhB,GAA+BJ,MAAME,SAAN,CAAgBG,UAAxE;AACA,QAAMH,YAAYF,MAAME,SAAN,CAAgBC,IAAhB,GAAuB+G,gBAAzC;AACA,QAAM1E,eAAexC,MAAM7F,OAAN,GAAgB6F,MAAM/F,QAA3C;AACA,QAAM8N,cAAc7H,YAAYqH,WAAhC;AACA,QAAMS,mBAAmBpO,QAAQ,KAAR,GAAgB,CAAC,CAAD,EAAI4I,YAAJ,CAAhB,GAAoC,CAACA,eAAe,EAAhB,EAAoB,CAApB,CAA7D;AACA,QAAMyF,wBAAwB1P,MAAM2G,SAAN,EAAiB8I,gBAAjB,CAA9B;AACA,QAAMH,cAAcC,YAAY,CAAC,CAAD,EAAItF,YAAJ,CAAZ,EAA+B,CAAC,CAAD,EAAIuF,WAAJ,CAA/B,CAApB;AACA,SAAOF,YAAYI,qBAAZ,CAAP;AACF;;AAGA,SAASH,WAAT,CAAqBI,KAArB,EAAuDC,MAAvD,EAA0F;AACxF,SAAQvB,KAAD,IAAmB;AACxB,QAAIsB,MAAM,CAAN,MAAaA,MAAM,CAAN,CAAb,IAAyBC,OAAO,CAAP,MAAcA,OAAO,CAAP,CAA3C,EAAsD,OAAOA,OAAO,CAAP,CAAP;AACtD,UAAMnB,SAASmB,OAAO,CAAP,IAAYA,OAAO,CAAP,CAArB,KAAmCD,MAAM,CAAN,IAAWA,MAAM,CAAN,CAA9C,CAAN;AACA,WAAOC,OAAO,CAAP,IAAYnB,SAASJ,QAAQsB,MAAM,CAAN,CAAjB,CAAnB;AACF,GAJA;AAKF;;AAEA,SAASxF,gCAAT,CAA0CxD,SAA1C,EAA6DsD,YAA7D,EAAmF;AACjF,SAAOtD,YAAY,CAAZ,IAAiBA,YAAYsD,YAApC;AACF;;AAIA,IAAMsD,4BAA4B,UAAC5K,IAAD,EAA2C;AAAA,MAAvBkN,OAAuB,uEAAb,MAAM,CAAC,CAAM;AAC3E,MAAIC,eAAe;AAAEjG,UAAMlH,KAAKoG,UAAb;AAAyB2B,SAAK/H,KAAK2G;AAAnC,GAAnB;AACA,MAAIyG,MAAM,CAAV;;AACA,GAAC,SAASC,IAAT,GAAgB;AACf,UAAMtM,WAAW;AAAEmG,YAAMlH,KAAKoG,UAAb;AAAyB2B,WAAK/H,KAAK2G;AAAnC,KAAjB;AACA,UAAM2G,qBAAqBH,aAAajG,IAAb,KAAsBnG,SAASmG,IAA1D;AACA,UAAMqG,mBAAmBJ,aAAapF,GAAb,KAAqBhH,SAASgH,GAAvD;AACA,QAAIuF,sBAAsBC,gBAA1B,EAA4CL;AAC5CC,mBAAepM,QAAf;AACAqM,UAAM1K,OAAO8K,qBAAP,CAA6BH,IAA7B,CAAN;AACF,GAPA;;AAQA,SAAO,MAAM3K,OAAO+K,oBAAP,CAA4BL,GAA5B,CAAb;AACF,CAZA;;AAcA,SAASlK,mBAAT,CAA6BwK,QAA7B,EAAmDC,KAAnD,EAAkE;AAChE,QAAMC,iBAAiB1Q,eAAewQ,QAAf,CAAvB;AACA,QAAMG,mBAAyBxP,cAAO,CAAP,CAA/B;AACMA,mBAAU,MAAM,MAAMqE,OAAOC,YAAP,CAAoBkL,iBAAiBjI,OAArC,CAAtB,EAAqE,EAArE;AACN,SAAavH,mBAAY,MAAM;AAC7BqE,WAAOC,YAAP,CAAoBkL,iBAAiBjI,OAArC;AACAiI,qBAAiBjI,OAAjB,GAA2BlD,OAAOG,UAAP,CAAkB+K,cAAlB,EAAkCD,KAAlC,CAA3B;AACF,GAHa,EAGV,CAACC,cAAD,EAAiBD,KAAjB,CAHU,CAAb;AAIF;;AAEA,SAAShJ,iBAAT,CAA2BqE,OAA3B,EAAwDtB,QAAxD,EAA8E;AAC5E,QAAMtD,eAAelH,eAAewK,QAAf,CAArB;AACAtK,kBAAgB,MAAM;AACpB,QAAIgQ,MAAM,CAAV;;AACA,QAAIpE,OAAJ,EAAa;AAQX,YAAM8E,iBAAiB,IAAIC,cAAJ,CAAmB,MAAM;AAC9CN,6BAAqBL,GAArB;AACAA,cAAM1K,OAAO8K,qBAAP,CAA6BpJ,YAA7B,CAAN;AACD,OAHsB,CAAvB;AAIA0J,qBAAeE,OAAf,CAAuBhF,OAAvB;AACA,aAAO,MAAM;AACXtG,eAAO+K,oBAAP,CAA4BL,GAA5B;AACAU,uBAAeG,SAAf,CAAyBjF,OAAzB;AACF,OAHA;AAIF;AACF,GApBA,EAoBG,CAACA,OAAD,EAAU5E,YAAV,CApBH;AAqBF;;AAIA,IAAM8J,OAAO9P,UAAb;AACA,IAAM+P,WAAWjN,kBAAjB;AACA,IAAMkN,YAAYvM,mBAAlB;AACA,IAAMwM,QAAQjE,eAAd;AACA,IAAMkE,SAASpD,gBAAf","names":["React","Primitive","Presence","createContextScope","useComposedRefs","useCallbackRef","useDirection","useLayoutEffect","clamp","composeEventHandlers","useStateMachine","initialState","machine","state","event","nextState","Fragment","jsxs","SCROLL_AREA_NAME","createScrollAreaContext","createScrollAreaScope","ScrollAreaProvider","useScrollAreaContext","ScrollArea","React2","props","forwardedRef","__scopeScrollArea","type","dir","scrollHideDelay","scrollAreaProps","scrollArea","setScrollArea","viewport","setViewport","content","setContent","scrollbarX","setScrollbarX","scrollbarY","setScrollbarY","cornerWidth","setCornerWidth","cornerHeight","setCornerHeight","scrollbarXEnabled","setScrollbarXEnabled","scrollbarYEnabled","setScrollbarYEnabled","composedRefs","node","direction","scope","onViewportChange","onContentChange","onScrollbarXChange","onScrollbarXEnabledChange","onScrollbarYChange","onScrollbarYEnabledChange","onCornerWidthChange","onCornerHeightChange","children","div","ref","style","position","displayName","VIEWPORT_NAME","ScrollAreaViewport","nonce","viewportProps","context","dangerouslySetInnerHTML","__html","overflowX","overflowY","minWidth","display","SCROLLBAR_NAME","ScrollAreaScrollbar","forceMount","scrollbarProps","isHorizontal","orientation","ScrollAreaScrollbarHover","ScrollAreaScrollbarScroll","ScrollAreaScrollbarAuto","ScrollAreaScrollbarVisible","visible","setVisible","hideTimer","handlePointerEnter","window","clearTimeout","handlePointerLeave","setTimeout","addEventListener","removeEventListener","present","debounceScrollEnd","useDebounceCallback","send","hidden","SCROLL","scrolling","SCROLL_END","POINTER_ENTER","interacting","POINTER_LEAVE","idle","HIDE","scrollDirection","prevScrollPos","handleScroll","scrollPos","hasScrollInDirectionChanged","onPointerEnter","onPointerLeave","handleResize","isOverflowX","offsetWidth","scrollWidth","isOverflowY","offsetHeight","scrollHeight","useResizeObserver","thumbRef","pointerOffsetRef","sizes","setSizes","scrollbar","size","paddingStart","paddingEnd","thumbRatio","getThumbRatio","commonProps","onSizesChange","hasThumb","Boolean","onThumbChange","thumb","current","onThumbPointerUp","onThumbPointerDown","pointerPos","getScrollPosition","getScrollPositionFromPointer","ScrollAreaScrollbarX","onThumbPositionChange","scrollLeft","offset","getThumbOffsetFromScroll","transform","onWheelScroll","onDragScroll","ScrollAreaScrollbarY","scrollTop","computedStyle","setComputedStyle","composeRefs","getComputedStyle","ScrollAreaScrollbarImpl","bottom","left","right","getThumbSize","x","maxScrollPos","deltaX","isScrollingWithinScrollbarBounds","preventDefault","onResize","clientWidth","toInt","paddingLeft","paddingRight","top","y","deltaY","clientHeight","paddingTop","paddingBottom","ScrollbarProvider","useScrollbarContext","setScrollbar","rectRef","prevWebkitUserSelectRef","handleWheelScroll","handleThumbPositionChange","handleDragScroll","clientX","clientY","handleWheel","element","target","isScrollbarWheel","contains","document","passive","onPointerDown","mainPointer","button","setPointerCapture","pointerId","getBoundingClientRect","body","webkitUserSelect","scrollBehavior","onPointerMove","onPointerUp","hasPointerCapture","releasePointerCapture","THUMB_NAME","ScrollAreaThumb","thumbProps","scrollbarContext","ScrollAreaThumbImpl","scrollAreaContext","composedRef","removeUnlinkedScrollListenerRef","listener","addUnlinkedScrollListener","width","height","onPointerDownCapture","thumbRect","CORNER_NAME","ScrollAreaCorner","hasBothScrollbarsVisible","hasCorner","ScrollAreaCornerImpl","cornerProps","setWidth","setHeight","hasSize","value","parseInt","viewportSize","contentSize","ratio","isNaN","scrollbarPadding","thumbSize","Math","max","pointerOffset","thumbSizePx","thumbCenter","thumbOffsetFromEnd","minPointerPos","maxPointerPos","scrollRange","interpolate","linearScale","maxThumbPos","scrollClampRange","scrollWithoutMomentum","input","output","handler","prevPosition","rAF","loop","isHorizontalScroll","isVerticalScroll","requestAnimationFrame","cancelAnimationFrame","callback","delay","handleCallback","debounceTimerRef","resizeObserver","ResizeObserver","observe","unobserve","Root","Viewport","Scrollbar","Thumb","Corner"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-scroll-area/src/ScrollArea.tsx","/home/bahari/vl-web-fe/node_modules/@radix-ui/react-scroll-area/src/useStateMachine.ts"],"sourcesContent":["/// <reference types=\"resize-observer-browser\" />\n\nimport * as React from 'react';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { Presence } from '@radix-ui/react-presence';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { clamp } from '@radix-ui/number';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useStateMachine } from './useStateMachine';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\ntype Sizes = {\n  content: number;\n  viewport: number;\n  scrollbar: {\n    size: number;\n    paddingStart: number;\n    paddingEnd: number;\n  };\n};\n\n/* -------------------------------------------------------------------------------------------------\n * ScrollArea\n * -----------------------------------------------------------------------------------------------*/\n\nconst SCROLL_AREA_NAME = 'ScrollArea';\n\ntype ScopedProps<P> = P & { __scopeScrollArea?: Scope };\nconst [createScrollAreaContext, createScrollAreaScope] = createContextScope(SCROLL_AREA_NAME);\n\ntype ScrollAreaContextValue = {\n  type: 'auto' | 'always' | 'scroll' | 'hover';\n  dir: Direction;\n  scrollHideDelay: number;\n  scrollArea: ScrollAreaElement | null;\n  viewport: ScrollAreaViewportElement | null;\n  onViewportChange(viewport: ScrollAreaViewportElement | null): void;\n  content: HTMLDivElement | null;\n  onContentChange(content: HTMLDivElement): void;\n  scrollbarX: ScrollAreaScrollbarElement | null;\n  onScrollbarXChange(scrollbar: ScrollAreaScrollbarElement | null): void;\n  scrollbarXEnabled: boolean;\n  onScrollbarXEnabledChange(rendered: boolean): void;\n  scrollbarY: ScrollAreaScrollbarElement | null;\n  onScrollbarYChange(scrollbar: ScrollAreaScrollbarElement | null): void;\n  scrollbarYEnabled: boolean;\n  onScrollbarYEnabledChange(rendered: boolean): void;\n  onCornerWidthChange(width: number): void;\n  onCornerHeightChange(height: number): void;\n};\n\nconst [ScrollAreaProvider, useScrollAreaContext] =\n  createScrollAreaContext<ScrollAreaContextValue>(SCROLL_AREA_NAME);\n\ntype ScrollAreaElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ScrollAreaProps extends PrimitiveDivProps {\n  type?: ScrollAreaContextValue['type'];\n  dir?: ScrollAreaContextValue['dir'];\n  scrollHideDelay?: number;\n}\n\nconst ScrollArea = React.forwardRef<ScrollAreaElement, ScrollAreaProps>(\n  (props: ScopedProps<ScrollAreaProps>, forwardedRef) => {\n    const {\n      __scopeScrollArea,\n      type = 'hover',\n      dir,\n      scrollHideDelay = 600,\n      ...scrollAreaProps\n    } = props;\n    const [scrollArea, setScrollArea] = React.useState<ScrollAreaElement | null>(null);\n    const [viewport, setViewport] = React.useState<ScrollAreaViewportElement | null>(null);\n    const [content, setContent] = React.useState<HTMLDivElement | null>(null);\n    const [scrollbarX, setScrollbarX] = React.useState<ScrollAreaScrollbarElement | null>(null);\n    const [scrollbarY, setScrollbarY] = React.useState<ScrollAreaScrollbarElement | null>(null);\n    const [cornerWidth, setCornerWidth] = React.useState(0);\n    const [cornerHeight, setCornerHeight] = React.useState(0);\n    const [scrollbarXEnabled, setScrollbarXEnabled] = React.useState(false);\n    const [scrollbarYEnabled, setScrollbarYEnabled] = React.useState(false);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setScrollArea(node));\n    const direction = useDirection(dir);\n\n    return (\n      <ScrollAreaProvider\n        scope={__scopeScrollArea}\n        type={type}\n        dir={direction}\n        scrollHideDelay={scrollHideDelay}\n        scrollArea={scrollArea}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        content={content}\n        onContentChange={setContent}\n        scrollbarX={scrollbarX}\n        onScrollbarXChange={setScrollbarX}\n        scrollbarXEnabled={scrollbarXEnabled}\n        onScrollbarXEnabledChange={setScrollbarXEnabled}\n        scrollbarY={scrollbarY}\n        onScrollbarYChange={setScrollbarY}\n        scrollbarYEnabled={scrollbarYEnabled}\n        onScrollbarYEnabledChange={setScrollbarYEnabled}\n        onCornerWidthChange={setCornerWidth}\n        onCornerHeightChange={setCornerHeight}\n      >\n        <Primitive.div\n          dir={direction}\n          {...scrollAreaProps}\n          ref={composedRefs}\n          style={{\n            position: 'relative',\n            // Pass corner sizes as CSS vars to reduce re-renders of context consumers\n            ['--radix-scroll-area-corner-width' as any]: cornerWidth + 'px',\n            ['--radix-scroll-area-corner-height' as any]: cornerHeight + 'px',\n            ...props.style,\n          }}\n        />\n      </ScrollAreaProvider>\n    );\n  }\n);\n\nScrollArea.displayName = SCROLL_AREA_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ScrollAreaViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'ScrollAreaViewport';\n\ntype ScrollAreaViewportElement = React.ElementRef<typeof Primitive.div>;\ninterface ScrollAreaViewportProps extends PrimitiveDivProps {\n  nonce?: string;\n}\n\nconst ScrollAreaViewport = React.forwardRef<ScrollAreaViewportElement, ScrollAreaViewportProps>(\n  (props: ScopedProps<ScrollAreaViewportProps>, forwardedRef) => {\n    const { __scopeScrollArea, children, nonce, ...viewportProps } = props;\n    const context = useScrollAreaContext(VIEWPORT_NAME, __scopeScrollArea);\n    const ref = React.useRef<ScrollAreaViewportElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n    return (\n      <>\n        {/* Hide scrollbars cross-browser and enable momentum scroll for touch devices */}\n        <style\n          dangerouslySetInnerHTML={{\n            __html: `[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}`,\n          }}\n          nonce={nonce}\n        />\n        <Primitive.div\n          data-radix-scroll-area-viewport=\"\"\n          {...viewportProps}\n          ref={composedRefs}\n          style={{\n            /**\n             * We don't support `visible` because the intention is to have at least one scrollbar\n             * if this component is used and `visible` will behave like `auto` in that case\n             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description\n             *\n             * We don't handle `auto` because the intention is for the native implementation\n             * to be hidden if using this component. We just want to ensure the node is scrollable\n             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent\n             * the browser from having to work out whether to render native scrollbars or not,\n             * we tell it to with the intention of hiding them in CSS.\n             */\n            overflowX: context.scrollbarXEnabled ? 'scroll' : 'hidden',\n            overflowY: context.scrollbarYEnabled ? 'scroll' : 'hidden',\n            ...props.style,\n          }}\n        >\n          {/**\n           * `display: table` ensures our content div will match the size of its children in both\n           * horizontal and vertical axis so we can determine if scroll width/height changed and\n           * recalculate thumb sizes. This doesn't account for children with *percentage*\n           * widths that change. We'll wait to see what use-cases consumers come up with there\n           * before trying to resolve it.\n           */}\n          <div ref={context.onContentChange} style={{ minWidth: '100%', display: 'table' }}>\n            {children}\n          </div>\n        </Primitive.div>\n      </>\n    );\n  }\n);\n\nScrollAreaViewport.displayName = VIEWPORT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ScrollAreaScrollbar\n * -----------------------------------------------------------------------------------------------*/\n\nconst SCROLLBAR_NAME = 'ScrollAreaScrollbar';\n\ntype ScrollAreaScrollbarElement = ScrollAreaScrollbarVisibleElement;\ninterface ScrollAreaScrollbarProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nconst ScrollAreaScrollbar = React.forwardRef<ScrollAreaScrollbarElement, ScrollAreaScrollbarProps>(\n  (props: ScopedProps<ScrollAreaScrollbarProps>, forwardedRef) => {\n    const { forceMount, ...scrollbarProps } = props;\n    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n    const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;\n    const isHorizontal = props.orientation === 'horizontal';\n\n    React.useEffect(() => {\n      isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);\n      return () => {\n        isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);\n      };\n    }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);\n\n    return context.type === 'hover' ? (\n      <ScrollAreaScrollbarHover {...scrollbarProps} ref={forwardedRef} forceMount={forceMount} />\n    ) : context.type === 'scroll' ? (\n      <ScrollAreaScrollbarScroll {...scrollbarProps} ref={forwardedRef} forceMount={forceMount} />\n    ) : context.type === 'auto' ? (\n      <ScrollAreaScrollbarAuto {...scrollbarProps} ref={forwardedRef} forceMount={forceMount} />\n    ) : context.type === 'always' ? (\n      <ScrollAreaScrollbarVisible {...scrollbarProps} ref={forwardedRef} />\n    ) : null;\n  }\n);\n\nScrollAreaScrollbar.displayName = SCROLLBAR_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ScrollAreaScrollbarHoverElement = ScrollAreaScrollbarAutoElement;\ninterface ScrollAreaScrollbarHoverProps extends ScrollAreaScrollbarAutoProps {\n  forceMount?: true;\n}\n\nconst ScrollAreaScrollbarHover = React.forwardRef<\n  ScrollAreaScrollbarHoverElement,\n  ScrollAreaScrollbarHoverProps\n>((props: ScopedProps<ScrollAreaScrollbarHoverProps>, forwardedRef) => {\n  const { forceMount, ...scrollbarProps } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const [visible, setVisible] = React.useState(false);\n\n  React.useEffect(() => {\n    const scrollArea = context.scrollArea;\n    let hideTimer = 0;\n    if (scrollArea) {\n      const handlePointerEnter = () => {\n        window.clearTimeout(hideTimer);\n        setVisible(true);\n      };\n      const handlePointerLeave = () => {\n        hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);\n      };\n      scrollArea.addEventListener('pointerenter', handlePointerEnter);\n      scrollArea.addEventListener('pointerleave', handlePointerLeave);\n      return () => {\n        window.clearTimeout(hideTimer);\n        scrollArea.removeEventListener('pointerenter', handlePointerEnter);\n        scrollArea.removeEventListener('pointerleave', handlePointerLeave);\n      };\n    }\n  }, [context.scrollArea, context.scrollHideDelay]);\n\n  return (\n    <Presence present={forceMount || visible}>\n      <ScrollAreaScrollbarAuto\n        data-state={visible ? 'visible' : 'hidden'}\n        {...scrollbarProps}\n        ref={forwardedRef}\n      />\n    </Presence>\n  );\n});\n\ntype ScrollAreaScrollbarScrollElement = ScrollAreaScrollbarVisibleElement;\ninterface ScrollAreaScrollbarScrollProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nconst ScrollAreaScrollbarScroll = React.forwardRef<\n  ScrollAreaScrollbarScrollElement,\n  ScrollAreaScrollbarScrollProps\n>((props: ScopedProps<ScrollAreaScrollbarScrollProps>, forwardedRef) => {\n  const { forceMount, ...scrollbarProps } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const isHorizontal = props.orientation === 'horizontal';\n  const debounceScrollEnd = useDebounceCallback(() => send('SCROLL_END'), 100);\n  const [state, send] = useStateMachine('hidden', {\n    hidden: {\n      SCROLL: 'scrolling',\n    },\n    scrolling: {\n      SCROLL_END: 'idle',\n      POINTER_ENTER: 'interacting',\n    },\n    interacting: {\n      SCROLL: 'interacting',\n      POINTER_LEAVE: 'idle',\n    },\n    idle: {\n      HIDE: 'hidden',\n      SCROLL: 'scrolling',\n      POINTER_ENTER: 'interacting',\n    },\n  });\n\n  React.useEffect(() => {\n    if (state === 'idle') {\n      const hideTimer = window.setTimeout(() => send('HIDE'), context.scrollHideDelay);\n      return () => window.clearTimeout(hideTimer);\n    }\n  }, [state, context.scrollHideDelay, send]);\n\n  React.useEffect(() => {\n    const viewport = context.viewport;\n    const scrollDirection = isHorizontal ? 'scrollLeft' : 'scrollTop';\n\n    if (viewport) {\n      let prevScrollPos = viewport[scrollDirection];\n      const handleScroll = () => {\n        const scrollPos = viewport[scrollDirection];\n        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;\n        if (hasScrollInDirectionChanged) {\n          send('SCROLL');\n          debounceScrollEnd();\n        }\n        prevScrollPos = scrollPos;\n      };\n      viewport.addEventListener('scroll', handleScroll);\n      return () => viewport.removeEventListener('scroll', handleScroll);\n    }\n  }, [context.viewport, isHorizontal, send, debounceScrollEnd]);\n\n  return (\n    <Presence present={forceMount || state !== 'hidden'}>\n      <ScrollAreaScrollbarVisible\n        data-state={state === 'hidden' ? 'hidden' : 'visible'}\n        {...scrollbarProps}\n        ref={forwardedRef}\n        onPointerEnter={composeEventHandlers(props.onPointerEnter, () => send('POINTER_ENTER'))}\n        onPointerLeave={composeEventHandlers(props.onPointerLeave, () => send('POINTER_LEAVE'))}\n      />\n    </Presence>\n  );\n});\n\ntype ScrollAreaScrollbarAutoElement = ScrollAreaScrollbarVisibleElement;\ninterface ScrollAreaScrollbarAutoProps extends ScrollAreaScrollbarVisibleProps {\n  forceMount?: true;\n}\n\nconst ScrollAreaScrollbarAuto = React.forwardRef<\n  ScrollAreaScrollbarAutoElement,\n  ScrollAreaScrollbarAutoProps\n>((props: ScopedProps<ScrollAreaScrollbarAutoProps>, forwardedRef) => {\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const { forceMount, ...scrollbarProps } = props;\n  const [visible, setVisible] = React.useState(false);\n  const isHorizontal = props.orientation === 'horizontal';\n  const handleResize = useDebounceCallback(() => {\n    if (context.viewport) {\n      const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;\n      const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;\n      setVisible(isHorizontal ? isOverflowX : isOverflowY);\n    }\n  }, 10);\n\n  useResizeObserver(context.viewport, handleResize);\n  useResizeObserver(context.content, handleResize);\n\n  return (\n    <Presence present={forceMount || visible}>\n      <ScrollAreaScrollbarVisible\n        data-state={visible ? 'visible' : 'hidden'}\n        {...scrollbarProps}\n        ref={forwardedRef}\n      />\n    </Presence>\n  );\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ScrollAreaScrollbarVisibleElement = ScrollAreaScrollbarAxisElement;\ninterface ScrollAreaScrollbarVisibleProps\n  extends Omit<ScrollAreaScrollbarAxisProps, keyof ScrollAreaScrollbarAxisPrivateProps> {\n  orientation?: 'horizontal' | 'vertical';\n}\n\nconst ScrollAreaScrollbarVisible = React.forwardRef<\n  ScrollAreaScrollbarVisibleElement,\n  ScrollAreaScrollbarVisibleProps\n>((props: ScopedProps<ScrollAreaScrollbarVisibleProps>, forwardedRef) => {\n  const { orientation = 'vertical', ...scrollbarProps } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const thumbRef = React.useRef<ScrollAreaThumbElement | null>(null);\n  const pointerOffsetRef = React.useRef(0);\n  const [sizes, setSizes] = React.useState<Sizes>({\n    content: 0,\n    viewport: 0,\n    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 },\n  });\n  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);\n\n  type UncommonProps = 'onThumbPositionChange' | 'onDragScroll' | 'onWheelScroll';\n  const commonProps: Omit<ScrollAreaScrollbarAxisPrivateProps, UncommonProps> = {\n    ...scrollbarProps,\n    sizes,\n    onSizesChange: setSizes,\n    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),\n    onThumbChange: (thumb) => (thumbRef.current = thumb),\n    onThumbPointerUp: () => (pointerOffsetRef.current = 0),\n    onThumbPointerDown: (pointerPos) => (pointerOffsetRef.current = pointerPos),\n  };\n\n  function getScrollPosition(pointerPos: number, dir?: Direction) {\n    return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);\n  }\n\n  if (orientation === 'horizontal') {\n    return (\n      <ScrollAreaScrollbarX\n        {...commonProps}\n        ref={forwardedRef}\n        onThumbPositionChange={() => {\n          if (context.viewport && thumbRef.current) {\n            const scrollPos = context.viewport.scrollLeft;\n            const offset = getThumbOffsetFromScroll(scrollPos, sizes, context.dir);\n            thumbRef.current.style.transform = `translate3d(${offset}px, 0, 0)`;\n          }\n        }}\n        onWheelScroll={(scrollPos) => {\n          if (context.viewport) context.viewport.scrollLeft = scrollPos;\n        }}\n        onDragScroll={(pointerPos) => {\n          if (context.viewport) {\n            context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir);\n          }\n        }}\n      />\n    );\n  }\n\n  if (orientation === 'vertical') {\n    return (\n      <ScrollAreaScrollbarY\n        {...commonProps}\n        ref={forwardedRef}\n        onThumbPositionChange={() => {\n          if (context.viewport && thumbRef.current) {\n            const scrollPos = context.viewport.scrollTop;\n            const offset = getThumbOffsetFromScroll(scrollPos, sizes);\n            thumbRef.current.style.transform = `translate3d(0, ${offset}px, 0)`;\n          }\n        }}\n        onWheelScroll={(scrollPos) => {\n          if (context.viewport) context.viewport.scrollTop = scrollPos;\n        }}\n        onDragScroll={(pointerPos) => {\n          if (context.viewport) context.viewport.scrollTop = getScrollPosition(pointerPos);\n        }}\n      />\n    );\n  }\n\n  return null;\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ScrollAreaScrollbarAxisPrivateProps = {\n  hasThumb: boolean;\n  sizes: Sizes;\n  onSizesChange(sizes: Sizes): void;\n  onThumbChange(thumb: ScrollAreaThumbElement | null): void;\n  onThumbPointerDown(pointerPos: number): void;\n  onThumbPointerUp(): void;\n  onThumbPositionChange(): void;\n  onWheelScroll(scrollPos: number): void;\n  onDragScroll(pointerPos: number): void;\n};\n\ntype ScrollAreaScrollbarAxisElement = ScrollAreaScrollbarImplElement;\ninterface ScrollAreaScrollbarAxisProps\n  extends Omit<ScrollAreaScrollbarImplProps, keyof ScrollAreaScrollbarImplPrivateProps>,\n    ScrollAreaScrollbarAxisPrivateProps {}\n\nconst ScrollAreaScrollbarX = React.forwardRef<\n  ScrollAreaScrollbarAxisElement,\n  ScrollAreaScrollbarAxisProps\n>((props: ScopedProps<ScrollAreaScrollbarAxisProps>, forwardedRef) => {\n  const { sizes, onSizesChange, ...scrollbarProps } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const [computedStyle, setComputedStyle] = React.useState<CSSStyleDeclaration>();\n  const ref = React.useRef<ScrollAreaScrollbarAxisElement>(null);\n  const composeRefs = useComposedRefs(forwardedRef, ref, context.onScrollbarXChange);\n\n  React.useEffect(() => {\n    if (ref.current) setComputedStyle(getComputedStyle(ref.current));\n  }, [ref]);\n\n  return (\n    <ScrollAreaScrollbarImpl\n      data-orientation=\"horizontal\"\n      {...scrollbarProps}\n      ref={composeRefs}\n      sizes={sizes}\n      style={{\n        bottom: 0,\n        left: context.dir === 'rtl' ? 'var(--radix-scroll-area-corner-width)' : 0,\n        right: context.dir === 'ltr' ? 'var(--radix-scroll-area-corner-width)' : 0,\n        ['--radix-scroll-area-thumb-width' as any]: getThumbSize(sizes) + 'px',\n        ...props.style,\n      }}\n      onThumbPointerDown={(pointerPos) => props.onThumbPointerDown(pointerPos.x)}\n      onDragScroll={(pointerPos) => props.onDragScroll(pointerPos.x)}\n      onWheelScroll={(event, maxScrollPos) => {\n        if (context.viewport) {\n          const scrollPos = context.viewport.scrollLeft + event.deltaX;\n          props.onWheelScroll(scrollPos);\n          // prevent window scroll when wheeling on scrollbar\n          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {\n            event.preventDefault();\n          }\n        }\n      }}\n      onResize={() => {\n        if (ref.current && context.viewport && computedStyle) {\n          onSizesChange({\n            content: context.viewport.scrollWidth,\n            viewport: context.viewport.offsetWidth,\n            scrollbar: {\n              size: ref.current.clientWidth,\n              paddingStart: toInt(computedStyle.paddingLeft),\n              paddingEnd: toInt(computedStyle.paddingRight),\n            },\n          });\n        }\n      }}\n    />\n  );\n});\n\nconst ScrollAreaScrollbarY = React.forwardRef<\n  ScrollAreaScrollbarAxisElement,\n  ScrollAreaScrollbarAxisProps\n>((props: ScopedProps<ScrollAreaScrollbarAxisProps>, forwardedRef) => {\n  const { sizes, onSizesChange, ...scrollbarProps } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);\n  const [computedStyle, setComputedStyle] = React.useState<CSSStyleDeclaration>();\n  const ref = React.useRef<ScrollAreaScrollbarAxisElement>(null);\n  const composeRefs = useComposedRefs(forwardedRef, ref, context.onScrollbarYChange);\n\n  React.useEffect(() => {\n    if (ref.current) setComputedStyle(getComputedStyle(ref.current));\n  }, [ref]);\n\n  return (\n    <ScrollAreaScrollbarImpl\n      data-orientation=\"vertical\"\n      {...scrollbarProps}\n      ref={composeRefs}\n      sizes={sizes}\n      style={{\n        top: 0,\n        right: context.dir === 'ltr' ? 0 : undefined,\n        left: context.dir === 'rtl' ? 0 : undefined,\n        bottom: 'var(--radix-scroll-area-corner-height)',\n        ['--radix-scroll-area-thumb-height' as any]: getThumbSize(sizes) + 'px',\n        ...props.style,\n      }}\n      onThumbPointerDown={(pointerPos) => props.onThumbPointerDown(pointerPos.y)}\n      onDragScroll={(pointerPos) => props.onDragScroll(pointerPos.y)}\n      onWheelScroll={(event, maxScrollPos) => {\n        if (context.viewport) {\n          const scrollPos = context.viewport.scrollTop + event.deltaY;\n          props.onWheelScroll(scrollPos);\n          // prevent window scroll when wheeling on scrollbar\n          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {\n            event.preventDefault();\n          }\n        }\n      }}\n      onResize={() => {\n        if (ref.current && context.viewport && computedStyle) {\n          onSizesChange({\n            content: context.viewport.scrollHeight,\n            viewport: context.viewport.offsetHeight,\n            scrollbar: {\n              size: ref.current.clientHeight,\n              paddingStart: toInt(computedStyle.paddingTop),\n              paddingEnd: toInt(computedStyle.paddingBottom),\n            },\n          });\n        }\n      }}\n    />\n  );\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ScrollbarContext = {\n  hasThumb: boolean;\n  scrollbar: ScrollAreaScrollbarElement | null;\n  onThumbChange(thumb: ScrollAreaThumbElement | null): void;\n  onThumbPointerUp(): void;\n  onThumbPointerDown(pointerPos: { x: number; y: number }): void;\n  onThumbPositionChange(): void;\n};\n\nconst [ScrollbarProvider, useScrollbarContext] =\n  createScrollAreaContext<ScrollbarContext>(SCROLLBAR_NAME);\n\ntype ScrollAreaScrollbarImplElement = React.ElementRef<typeof Primitive.div>;\ntype ScrollAreaScrollbarImplPrivateProps = {\n  sizes: Sizes;\n  hasThumb: boolean;\n  onThumbChange: ScrollbarContext['onThumbChange'];\n  onThumbPointerUp: ScrollbarContext['onThumbPointerUp'];\n  onThumbPointerDown: ScrollbarContext['onThumbPointerDown'];\n  onThumbPositionChange: ScrollbarContext['onThumbPositionChange'];\n  onWheelScroll(event: WheelEvent, maxScrollPos: number): void;\n  onDragScroll(pointerPos: { x: number; y: number }): void;\n  onResize(): void;\n};\ninterface ScrollAreaScrollbarImplProps\n  extends Omit<PrimitiveDivProps, keyof ScrollAreaScrollbarImplPrivateProps>,\n    ScrollAreaScrollbarImplPrivateProps {}\n\nconst ScrollAreaScrollbarImpl = React.forwardRef<\n  ScrollAreaScrollbarImplElement,\n  ScrollAreaScrollbarImplProps\n>((props: ScopedProps<ScrollAreaScrollbarImplProps>, forwardedRef) => {\n  const {\n    __scopeScrollArea,\n    sizes,\n    hasThumb,\n    onThumbChange,\n    onThumbPointerUp,\n    onThumbPointerDown,\n    onThumbPositionChange,\n    onDragScroll,\n    onWheelScroll,\n    onResize,\n    ...scrollbarProps\n  } = props;\n  const context = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea);\n  const [scrollbar, setScrollbar] = React.useState<ScrollAreaScrollbarElement | null>(null);\n  const composeRefs = useComposedRefs(forwardedRef, (node) => setScrollbar(node));\n  const rectRef = React.useRef<DOMRect | null>(null);\n  const prevWebkitUserSelectRef = React.useRef<string>('');\n  const viewport = context.viewport;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const handleWheelScroll = useCallbackRef(onWheelScroll);\n  const handleThumbPositionChange = useCallbackRef(onThumbPositionChange);\n  const handleResize = useDebounceCallback(onResize, 10);\n\n  function handleDragScroll(event: React.PointerEvent<HTMLElement>) {\n    if (rectRef.current) {\n      const x = event.clientX - rectRef.current.left;\n      const y = event.clientY - rectRef.current.top;\n      onDragScroll({ x, y });\n    }\n  }\n\n  /**\n   * We bind wheel event imperatively so we can switch off passive\n   * mode for document wheel event to allow it to be prevented\n   */\n  React.useEffect(() => {\n    const handleWheel = (event: WheelEvent) => {\n      const element = event.target as HTMLElement;\n      const isScrollbarWheel = scrollbar?.contains(element);\n      if (isScrollbarWheel) handleWheelScroll(event, maxScrollPos);\n    };\n    document.addEventListener('wheel', handleWheel, { passive: false });\n    return () => document.removeEventListener('wheel', handleWheel, { passive: false } as any);\n  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);\n\n  /**\n   * Update thumb position on sizes change\n   */\n  React.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);\n\n  useResizeObserver(scrollbar, handleResize);\n  useResizeObserver(context.content, handleResize);\n\n  return (\n    <ScrollbarProvider\n      scope={__scopeScrollArea}\n      scrollbar={scrollbar}\n      hasThumb={hasThumb}\n      onThumbChange={useCallbackRef(onThumbChange)}\n      onThumbPointerUp={useCallbackRef(onThumbPointerUp)}\n      onThumbPositionChange={handleThumbPositionChange}\n      onThumbPointerDown={useCallbackRef(onThumbPointerDown)}\n    >\n      <Primitive.div\n        {...scrollbarProps}\n        ref={composeRefs}\n        style={{ position: 'absolute', ...scrollbarProps.style }}\n        onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n          const mainPointer = 0;\n          if (event.button === mainPointer) {\n            const element = event.target as HTMLElement;\n            element.setPointerCapture(event.pointerId);\n            rectRef.current = scrollbar!.getBoundingClientRect();\n            // pointer capture doesn't prevent text selection in Safari\n            // so we remove text selection manually when scrolling\n            prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;\n            document.body.style.webkitUserSelect = 'none';\n            if (context.viewport) context.viewport.style.scrollBehavior = 'auto';\n            handleDragScroll(event);\n          }\n        })}\n        onPointerMove={composeEventHandlers(props.onPointerMove, handleDragScroll)}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          const element = event.target as HTMLElement;\n          if (element.hasPointerCapture(event.pointerId)) {\n            element.releasePointerCapture(event.pointerId);\n          }\n          document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;\n          if (context.viewport) context.viewport.style.scrollBehavior = '';\n          rectRef.current = null;\n        })}\n      />\n    </ScrollbarProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * ScrollAreaThumb\n * -----------------------------------------------------------------------------------------------*/\n\nconst THUMB_NAME = 'ScrollAreaThumb';\n\ntype ScrollAreaThumbElement = ScrollAreaThumbImplElement;\ninterface ScrollAreaThumbProps extends ScrollAreaThumbImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst ScrollAreaThumb = React.forwardRef<ScrollAreaThumbElement, ScrollAreaThumbProps>(\n  (props: ScopedProps<ScrollAreaThumbProps>, forwardedRef) => {\n    const { forceMount, ...thumbProps } = props;\n    const scrollbarContext = useScrollbarContext(THUMB_NAME, props.__scopeScrollArea);\n    return (\n      <Presence present={forceMount || scrollbarContext.hasThumb}>\n        <ScrollAreaThumbImpl ref={forwardedRef} {...thumbProps} />\n      </Presence>\n    );\n  }\n);\n\ntype ScrollAreaThumbImplElement = React.ElementRef<typeof Primitive.div>;\ninterface ScrollAreaThumbImplProps extends PrimitiveDivProps {}\n\nconst ScrollAreaThumbImpl = React.forwardRef<ScrollAreaThumbImplElement, ScrollAreaThumbImplProps>(\n  (props: ScopedProps<ScrollAreaThumbImplProps>, forwardedRef) => {\n    const { __scopeScrollArea, style, ...thumbProps } = props;\n    const scrollAreaContext = useScrollAreaContext(THUMB_NAME, __scopeScrollArea);\n    const scrollbarContext = useScrollbarContext(THUMB_NAME, __scopeScrollArea);\n    const { onThumbPositionChange } = scrollbarContext;\n    const composedRef = useComposedRefs(forwardedRef, (node) =>\n      scrollbarContext.onThumbChange(node)\n    );\n    const removeUnlinkedScrollListenerRef = React.useRef<() => void>(undefined);\n    const debounceScrollEnd = useDebounceCallback(() => {\n      if (removeUnlinkedScrollListenerRef.current) {\n        removeUnlinkedScrollListenerRef.current();\n        removeUnlinkedScrollListenerRef.current = undefined;\n      }\n    }, 100);\n\n    React.useEffect(() => {\n      const viewport = scrollAreaContext.viewport;\n      if (viewport) {\n        /**\n         * We only bind to native scroll event so we know when scroll starts and ends.\n         * When scroll starts we start a requestAnimationFrame loop that checks for\n         * changes to scroll position. That rAF loop triggers our thumb position change\n         * when relevant to avoid scroll-linked effects. We cancel the loop when scroll ends.\n         * https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Scroll-linked_effects\n         */\n        const handleScroll = () => {\n          debounceScrollEnd();\n          if (!removeUnlinkedScrollListenerRef.current) {\n            const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);\n            removeUnlinkedScrollListenerRef.current = listener;\n            onThumbPositionChange();\n          }\n        };\n        onThumbPositionChange();\n        viewport.addEventListener('scroll', handleScroll);\n        return () => viewport.removeEventListener('scroll', handleScroll);\n      }\n    }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);\n\n    return (\n      <Primitive.div\n        data-state={scrollbarContext.hasThumb ? 'visible' : 'hidden'}\n        {...thumbProps}\n        ref={composedRef}\n        style={{\n          width: 'var(--radix-scroll-area-thumb-width)',\n          height: 'var(--radix-scroll-area-thumb-height)',\n          ...style,\n        }}\n        onPointerDownCapture={composeEventHandlers(props.onPointerDownCapture, (event) => {\n          const thumb = event.target as HTMLElement;\n          const thumbRect = thumb.getBoundingClientRect();\n          const x = event.clientX - thumbRect.left;\n          const y = event.clientY - thumbRect.top;\n          scrollbarContext.onThumbPointerDown({ x, y });\n        })}\n        onPointerUp={composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)}\n      />\n    );\n  }\n);\n\nScrollAreaThumb.displayName = THUMB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ScrollAreaCorner\n * -----------------------------------------------------------------------------------------------*/\n\nconst CORNER_NAME = 'ScrollAreaCorner';\n\ntype ScrollAreaCornerElement = ScrollAreaCornerImplElement;\ninterface ScrollAreaCornerProps extends ScrollAreaCornerImplProps {}\n\nconst ScrollAreaCorner = React.forwardRef<ScrollAreaCornerElement, ScrollAreaCornerProps>(\n  (props: ScopedProps<ScrollAreaCornerProps>, forwardedRef) => {\n    const context = useScrollAreaContext(CORNER_NAME, props.__scopeScrollArea);\n    const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);\n    const hasCorner = context.type !== 'scroll' && hasBothScrollbarsVisible;\n    return hasCorner ? <ScrollAreaCornerImpl {...props} ref={forwardedRef} /> : null;\n  }\n);\n\nScrollAreaCorner.displayName = CORNER_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ScrollAreaCornerImplElement = React.ElementRef<typeof Primitive.div>;\ninterface ScrollAreaCornerImplProps extends PrimitiveDivProps {}\n\nconst ScrollAreaCornerImpl = React.forwardRef<\n  ScrollAreaCornerImplElement,\n  ScrollAreaCornerImplProps\n>((props: ScopedProps<ScrollAreaCornerImplProps>, forwardedRef) => {\n  const { __scopeScrollArea, ...cornerProps } = props;\n  const context = useScrollAreaContext(CORNER_NAME, __scopeScrollArea);\n  const [width, setWidth] = React.useState(0);\n  const [height, setHeight] = React.useState(0);\n  const hasSize = Boolean(width && height);\n\n  useResizeObserver(context.scrollbarX, () => {\n    const height = context.scrollbarX?.offsetHeight || 0;\n    context.onCornerHeightChange(height);\n    setHeight(height);\n  });\n\n  useResizeObserver(context.scrollbarY, () => {\n    const width = context.scrollbarY?.offsetWidth || 0;\n    context.onCornerWidthChange(width);\n    setWidth(width);\n  });\n\n  return hasSize ? (\n    <Primitive.div\n      {...cornerProps}\n      ref={forwardedRef}\n      style={{\n        width,\n        height,\n        position: 'absolute',\n        right: context.dir === 'ltr' ? 0 : undefined,\n        left: context.dir === 'rtl' ? 0 : undefined,\n        bottom: 0,\n        ...props.style,\n      }}\n    />\n  ) : null;\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction toInt(value?: string) {\n  return value ? parseInt(value, 10) : 0;\n}\n\nfunction getThumbRatio(viewportSize: number, contentSize: number) {\n  const ratio = viewportSize / contentSize;\n  return isNaN(ratio) ? 0 : ratio;\n}\n\nfunction getThumbSize(sizes: Sizes) {\n  const ratio = getThumbRatio(sizes.viewport, sizes.content);\n  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;\n  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;\n  // minimum of 18 matches macOS minimum\n  return Math.max(thumbSize, 18);\n}\n\nfunction getScrollPositionFromPointer(\n  pointerPos: number,\n  pointerOffset: number,\n  sizes: Sizes,\n  dir: Direction = 'ltr'\n) {\n  const thumbSizePx = getThumbSize(sizes);\n  const thumbCenter = thumbSizePx / 2;\n  const offset = pointerOffset || thumbCenter;\n  const thumbOffsetFromEnd = thumbSizePx - offset;\n  const minPointerPos = sizes.scrollbar.paddingStart + offset;\n  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const scrollRange = dir === 'ltr' ? [0, maxScrollPos] : [maxScrollPos * -1, 0];\n  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange as [number, number]);\n  return interpolate(pointerPos);\n}\n\nfunction getThumbOffsetFromScroll(scrollPos: number, sizes: Sizes, dir: Direction = 'ltr') {\n  const thumbSizePx = getThumbSize(sizes);\n  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;\n  const scrollbar = sizes.scrollbar.size - scrollbarPadding;\n  const maxScrollPos = sizes.content - sizes.viewport;\n  const maxThumbPos = scrollbar - thumbSizePx;\n  const scrollClampRange = dir === 'ltr' ? [0, maxScrollPos] : [maxScrollPos * -1, 0];\n  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange as [number, number]);\n  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);\n  return interpolate(scrollWithoutMomentum);\n}\n\n// https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js\nfunction linearScale(input: readonly [number, number], output: readonly [number, number]) {\n  return (value: number) => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\n\nfunction isScrollingWithinScrollbarBounds(scrollPos: number, maxScrollPos: number) {\n  return scrollPos > 0 && scrollPos < maxScrollPos;\n}\n\n// Custom scroll handler to avoid scroll-linked effects\n// https://developer.mozilla.org/en-US/docs/Mozilla/Performance/Scroll-linked_effects\nconst addUnlinkedScrollListener = (node: HTMLElement, handler = () => {}) => {\n  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };\n  let rAF = 0;\n  (function loop() {\n    const position = { left: node.scrollLeft, top: node.scrollTop };\n    const isHorizontalScroll = prevPosition.left !== position.left;\n    const isVerticalScroll = prevPosition.top !== position.top;\n    if (isHorizontalScroll || isVerticalScroll) handler();\n    prevPosition = position;\n    rAF = window.requestAnimationFrame(loop);\n  })();\n  return () => window.cancelAnimationFrame(rAF);\n};\n\nfunction useDebounceCallback(callback: () => void, delay: number) {\n  const handleCallback = useCallbackRef(callback);\n  const debounceTimerRef = React.useRef(0);\n  React.useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);\n  return React.useCallback(() => {\n    window.clearTimeout(debounceTimerRef.current);\n    debounceTimerRef.current = window.setTimeout(handleCallback, delay);\n  }, [handleCallback, delay]);\n}\n\nfunction useResizeObserver(element: HTMLElement | null, onResize: () => void) {\n  const handleResize = useCallbackRef(onResize);\n  useLayoutEffect(() => {\n    let rAF = 0;\n    if (element) {\n      /**\n       * Resize Observer will throw an often benign error that says `ResizeObserver loop\n       * completed with undelivered notifications`. This means that ResizeObserver was not\n       * able to deliver all observations within a single animation frame, so we use\n       * `requestAnimationFrame` to ensure we don't deliver unnecessary observations.\n       * Further reading: https://github.com/WICG/resize-observer/issues/38\n       */\n      const resizeObserver = new ResizeObserver(() => {\n        cancelAnimationFrame(rAF);\n        rAF = window.requestAnimationFrame(handleResize);\n      });\n      resizeObserver.observe(element);\n      return () => {\n        window.cancelAnimationFrame(rAF);\n        resizeObserver.unobserve(element);\n      };\n    }\n  }, [element, handleResize]);\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = ScrollArea;\nconst Viewport = ScrollAreaViewport;\nconst Scrollbar = ScrollAreaScrollbar;\nconst Thumb = ScrollAreaThumb;\nconst Corner = ScrollAreaCorner;\n\nexport {\n  createScrollAreaScope,\n  //\n  ScrollArea,\n  ScrollAreaViewport,\n  ScrollAreaScrollbar,\n  ScrollAreaThumb,\n  ScrollAreaCorner,\n  //\n  Root,\n  Viewport,\n  Scrollbar,\n  Thumb,\n  Corner,\n};\nexport type {\n  ScrollAreaProps,\n  ScrollAreaViewportProps,\n  ScrollAreaScrollbarProps,\n  ScrollAreaThumbProps,\n  ScrollAreaCornerProps,\n};\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n//  https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n"]},"metadata":{},"sourceType":"module"}