{"ast":null,"code":"import _toConsumableArray from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { invariant } from 'motion-utils';\nimport { setTarget } from '../../render/utils/setters.mjs';\nimport { animateVisualElement } from '../interfaces/visual-element.mjs';\n\nfunction stopAnimation(visualElement) {\n  visualElement.values.forEach(function (value) {\n    return value.stop();\n  });\n}\n\nfunction setVariants(visualElement, variantLabels) {\n  var reversedLabels = _toConsumableArray(variantLabels).reverse();\n\n  reversedLabels.forEach(function (key) {\n    var variant = visualElement.getVariant(key);\n    variant && setTarget(visualElement, variant);\n\n    if (visualElement.variantChildren) {\n      visualElement.variantChildren.forEach(function (child) {\n        setVariants(child, variantLabels);\n      });\n    }\n  });\n}\n\nfunction setValues(visualElement, definition) {\n  if (Array.isArray(definition)) {\n    return setVariants(visualElement, definition);\n  } else if (typeof definition === \"string\") {\n    return setVariants(visualElement, [definition]);\n  } else {\n    setTarget(visualElement, definition);\n  }\n}\n/**\n * @public\n */\n\n\nfunction animationControls() {\n  /**\n   * Track whether the host component has mounted.\n   */\n  var hasMounted = false;\n  /**\n   * A collection of linked component animation controls.\n   */\n\n  var subscribers = new Set();\n  var controls = {\n    subscribe: function subscribe(visualElement) {\n      subscribers.add(visualElement);\n      return function () {\n        return void subscribers.delete(visualElement);\n      };\n    },\n    start: function start(definition, transitionOverride) {\n      invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      var animations = [];\n      subscribers.forEach(function (visualElement) {\n        animations.push(animateVisualElement(visualElement, definition, {\n          transitionOverride: transitionOverride\n        }));\n      });\n      return Promise.all(animations);\n    },\n    set: function set(definition) {\n      invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n      return subscribers.forEach(function (visualElement) {\n        setValues(visualElement, definition);\n      });\n    },\n    stop: function stop() {\n      subscribers.forEach(function (visualElement) {\n        stopAnimation(visualElement);\n      });\n    },\n    mount: function mount() {\n      hasMounted = true;\n      return function () {\n        hasMounted = false;\n        controls.stop();\n      };\n    }\n  };\n  return controls;\n}\n\nexport { animationControls, setValues };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/animation/hooks/animation-controls.mjs"],"names":["invariant","setTarget","animateVisualElement","stopAnimation","visualElement","values","forEach","value","stop","setVariants","variantLabels","reversedLabels","reverse","key","variant","getVariant","variantChildren","child","setValues","definition","Array","isArray","animationControls","hasMounted","subscribers","Set","controls","subscribe","add","delete","start","transitionOverride","animations","push","Promise","all","set","mount"],"mappings":"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","sourcesContent":["import { invariant } from 'motion-utils';\nimport { setTarget } from '../../render/utils/setters.mjs';\nimport { animateVisualElement } from '../interfaces/visual-element.mjs';\n\nfunction stopAnimation(visualElement) {\n    visualElement.values.forEach((value) => value.stop());\n}\nfunction setVariants(visualElement, variantLabels) {\n    const reversedLabels = [...variantLabels].reverse();\n    reversedLabels.forEach((key) => {\n        const variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        if (visualElement.variantChildren) {\n            visualElement.variantChildren.forEach((child) => {\n                setVariants(child, variantLabels);\n            });\n        }\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    let hasMounted = false;\n    /**\n     * A collection of linked component animation controls.\n     */\n    const subscribers = new Set();\n    const controls = {\n        subscribe(visualElement) {\n            subscribers.add(visualElement);\n            return () => void subscribers.delete(visualElement);\n        },\n        start(definition, transitionOverride) {\n            invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            const animations = [];\n            subscribers.forEach((visualElement) => {\n                animations.push(animateVisualElement(visualElement, definition, {\n                    transitionOverride,\n                }));\n            });\n            return Promise.all(animations);\n        },\n        set(definition) {\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach((visualElement) => {\n                setValues(visualElement, definition);\n            });\n        },\n        stop() {\n            subscribers.forEach((visualElement) => {\n                stopAnimation(visualElement);\n            });\n        },\n        mount() {\n            hasMounted = true;\n            return () => {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\nexport { animationControls, setValues };\n"]},"metadata":{},"sourceType":"module"}