{"ast":null,"code":"import { MotionGlobalConfig } from '../utils/GlobalConfig.mjs';\nimport { createRenderStep } from './render-step.mjs';\nvar stepsOrder = [\"read\", // Read\n\"resolveKeyframes\", // Write/Read/Write/Read\n\"update\", // Compute\n\"preRender\", // Compute\n\"render\", // Write\n\"postRender\" // Compute\n];\nvar maxElapsed = 40;\n\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n  var runNextFrame = false;\n  var useDefaultElapsed = true;\n  var state = {\n    delta: 0.0,\n    timestamp: 0.0,\n    isProcessing: false\n  };\n\n  var flagRunNextFrame = function flagRunNextFrame() {\n    return runNextFrame = true;\n  };\n\n  var steps = stepsOrder.reduce(function (acc, key) {\n    acc[key] = createRenderStep(flagRunNextFrame);\n    return acc;\n  }, {});\n  var read = steps.read,\n      resolveKeyframes = steps.resolveKeyframes,\n      update = steps.update,\n      preRender = steps.preRender,\n      render = steps.render,\n      postRender = steps.postRender;\n\n  var processBatch = function processBatch() {\n    var timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();\n    runNextFrame = false;\n    state.delta = useDefaultElapsed ? 1000 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\n    state.timestamp = timestamp;\n    state.isProcessing = true; // Unrolled render loop for better per-frame performance\n\n    read.process(state);\n    resolveKeyframes.process(state);\n    update.process(state);\n    preRender.process(state);\n    render.process(state);\n    postRender.process(state);\n    state.isProcessing = false;\n\n    if (runNextFrame && allowKeepAlive) {\n      useDefaultElapsed = false;\n      scheduleNextBatch(processBatch);\n    }\n  };\n\n  var wake = function wake() {\n    runNextFrame = true;\n    useDefaultElapsed = true;\n\n    if (!state.isProcessing) {\n      scheduleNextBatch(processBatch);\n    }\n  };\n\n  var schedule = stepsOrder.reduce(function (acc, key) {\n    var step = steps[key];\n\n    acc[key] = function (process) {\n      var keepAlive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      if (!runNextFrame) wake();\n      return step.schedule(process, keepAlive, immediate);\n    };\n\n    return acc;\n  }, {});\n\n  var cancel = function cancel(process) {\n    for (var i = 0; i < stepsOrder.length; i++) {\n      steps[stepsOrder[i]].cancel(process);\n    }\n  };\n\n  return {\n    schedule: schedule,\n    cancel: cancel,\n    state: state,\n    steps: steps\n  };\n}\n\nexport { createRenderBatcher, stepsOrder };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/frameloop/batcher.mjs"],"names":["MotionGlobalConfig","createRenderStep","stepsOrder","maxElapsed","createRenderBatcher","scheduleNextBatch","allowKeepAlive","runNextFrame","useDefaultElapsed","state","delta","timestamp","isProcessing","flagRunNextFrame","steps","reduce","acc","key","read","resolveKeyframes","update","preRender","render","postRender","processBatch","useManualTiming","performance","now","Math","max","min","process","wake","schedule","step","keepAlive","immediate","cancel","i","length"],"mappings":"AAAA,SAASA,kBAAT,QAAmC,2BAAnC;AACA,SAASC,gBAAT,QAAiC,mBAAjC;AAEA,IAAMC,UAAU,GAAG,CACf,MADe,EACP;AACR,kBAFe,EAEK;AACpB,QAHe,EAGL;AACV,WAJe,EAIF;AACb,QALe,EAKL;AACV,YANe,CAMD;AANC,CAAnB;AAQA,IAAMC,UAAU,GAAG,EAAnB;;AACA,SAASC,mBAAT,CAA6BC,iBAA7B,EAAgDC,cAAhD,EAAgE;AAC5D,MAAIC,YAAY,GAAG,KAAnB;AACA,MAAIC,iBAAiB,GAAG,IAAxB;AACA,MAAMC,KAAK,GAAG;AACVC,IAAAA,KAAK,EAAE,GADG;AAEVC,IAAAA,SAAS,EAAE,GAFD;AAGVC,IAAAA,YAAY,EAAE;AAHJ,GAAd;;AAKA,MAAMC,gBAAgB,GAAG,SAAnBA,gBAAmB;AAAA,WAAON,YAAY,GAAG,IAAtB;AAAA,GAAzB;;AACA,MAAMO,KAAK,GAAGZ,UAAU,CAACa,MAAX,CAAkB,UAACC,GAAD,EAAMC,GAAN,EAAc;AAC1CD,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAWhB,gBAAgB,CAACY,gBAAD,CAA3B;AACA,WAAOG,GAAP;AACH,GAHa,EAGX,EAHW,CAAd;AAIA,MAAQE,IAAR,GAA0EJ,KAA1E,CAAQI,IAAR;AAAA,MAAcC,gBAAd,GAA0EL,KAA1E,CAAcK,gBAAd;AAAA,MAAgCC,MAAhC,GAA0EN,KAA1E,CAAgCM,MAAhC;AAAA,MAAwCC,SAAxC,GAA0EP,KAA1E,CAAwCO,SAAxC;AAAA,MAAmDC,MAAnD,GAA0ER,KAA1E,CAAmDQ,MAAnD;AAAA,MAA2DC,UAA3D,GAA0ET,KAA1E,CAA2DS,UAA3D;;AACA,MAAMC,YAAY,GAAG,SAAfA,YAAe,GAAM;AACvB,QAAMb,SAAS,GAAGX,kBAAkB,CAACyB,eAAnB,GACZhB,KAAK,CAACE,SADM,GAEZe,WAAW,CAACC,GAAZ,EAFN;AAGApB,IAAAA,YAAY,GAAG,KAAf;AACAE,IAAAA,KAAK,CAACC,KAAN,GAAcF,iBAAiB,GACzB,OAAO,EADkB,GAEzBoB,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,GAAL,CAASnB,SAAS,GAAGF,KAAK,CAACE,SAA3B,EAAsCR,UAAtC,CAAT,EAA4D,CAA5D,CAFN;AAGAM,IAAAA,KAAK,CAACE,SAAN,GAAkBA,SAAlB;AACAF,IAAAA,KAAK,CAACG,YAAN,GAAqB,IAArB,CATuB,CAUvB;;AACAM,IAAAA,IAAI,CAACa,OAAL,CAAatB,KAAb;AACAU,IAAAA,gBAAgB,CAACY,OAAjB,CAAyBtB,KAAzB;AACAW,IAAAA,MAAM,CAACW,OAAP,CAAetB,KAAf;AACAY,IAAAA,SAAS,CAACU,OAAV,CAAkBtB,KAAlB;AACAa,IAAAA,MAAM,CAACS,OAAP,CAAetB,KAAf;AACAc,IAAAA,UAAU,CAACQ,OAAX,CAAmBtB,KAAnB;AACAA,IAAAA,KAAK,CAACG,YAAN,GAAqB,KAArB;;AACA,QAAIL,YAAY,IAAID,cAApB,EAAoC;AAChCE,MAAAA,iBAAiB,GAAG,KAApB;AACAH,MAAAA,iBAAiB,CAACmB,YAAD,CAAjB;AACH;AACJ,GAtBD;;AAuBA,MAAMQ,IAAI,GAAG,SAAPA,IAAO,GAAM;AACfzB,IAAAA,YAAY,GAAG,IAAf;AACAC,IAAAA,iBAAiB,GAAG,IAApB;;AACA,QAAI,CAACC,KAAK,CAACG,YAAX,EAAyB;AACrBP,MAAAA,iBAAiB,CAACmB,YAAD,CAAjB;AACH;AACJ,GAND;;AAOA,MAAMS,QAAQ,GAAG/B,UAAU,CAACa,MAAX,CAAkB,UAACC,GAAD,EAAMC,GAAN,EAAc;AAC7C,QAAMiB,IAAI,GAAGpB,KAAK,CAACG,GAAD,CAAlB;;AACAD,IAAAA,GAAG,CAACC,GAAD,CAAH,GAAW,UAACc,OAAD,EAAmD;AAAA,UAAzCI,SAAyC,uEAA7B,KAA6B;AAAA,UAAtBC,SAAsB,uEAAV,KAAU;AAC1D,UAAI,CAAC7B,YAAL,EACIyB,IAAI;AACR,aAAOE,IAAI,CAACD,QAAL,CAAcF,OAAd,EAAuBI,SAAvB,EAAkCC,SAAlC,CAAP;AACH,KAJD;;AAKA,WAAOpB,GAAP;AACH,GARgB,EAQd,EARc,CAAjB;;AASA,MAAMqB,MAAM,GAAG,SAATA,MAAS,CAACN,OAAD,EAAa;AACxB,SAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpC,UAAU,CAACqC,MAA/B,EAAuCD,CAAC,EAAxC,EAA4C;AACxCxB,MAAAA,KAAK,CAACZ,UAAU,CAACoC,CAAD,CAAX,CAAL,CAAqBD,MAArB,CAA4BN,OAA5B;AACH;AACJ,GAJD;;AAKA,SAAO;AAAEE,IAAAA,QAAQ,EAARA,QAAF;AAAYI,IAAAA,MAAM,EAANA,MAAZ;AAAoB5B,IAAAA,KAAK,EAALA,KAApB;AAA2BK,IAAAA,KAAK,EAALA;AAA3B,GAAP;AACH;;AAED,SAASV,mBAAT,EAA8BF,UAA9B","sourcesContent":["import { MotionGlobalConfig } from '../utils/GlobalConfig.mjs';\nimport { createRenderStep } from './render-step.mjs';\n\nconst stepsOrder = [\n    \"read\", // Read\n    \"resolveKeyframes\", // Write/Read/Write/Read\n    \"update\", // Compute\n    \"preRender\", // Compute\n    \"render\", // Write\n    \"postRender\", // Compute\n];\nconst maxElapsed = 40;\nfunction createRenderBatcher(scheduleNextBatch, allowKeepAlive) {\n    let runNextFrame = false;\n    let useDefaultElapsed = true;\n    const state = {\n        delta: 0.0,\n        timestamp: 0.0,\n        isProcessing: false,\n    };\n    const flagRunNextFrame = () => (runNextFrame = true);\n    const steps = stepsOrder.reduce((acc, key) => {\n        acc[key] = createRenderStep(flagRunNextFrame);\n        return acc;\n    }, {});\n    const { read, resolveKeyframes, update, preRender, render, postRender } = steps;\n    const processBatch = () => {\n        const timestamp = MotionGlobalConfig.useManualTiming\n            ? state.timestamp\n            : performance.now();\n        runNextFrame = false;\n        state.delta = useDefaultElapsed\n            ? 1000 / 60\n            : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);\n        state.timestamp = timestamp;\n        state.isProcessing = true;\n        // Unrolled render loop for better per-frame performance\n        read.process(state);\n        resolveKeyframes.process(state);\n        update.process(state);\n        preRender.process(state);\n        render.process(state);\n        postRender.process(state);\n        state.isProcessing = false;\n        if (runNextFrame && allowKeepAlive) {\n            useDefaultElapsed = false;\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const wake = () => {\n        runNextFrame = true;\n        useDefaultElapsed = true;\n        if (!state.isProcessing) {\n            scheduleNextBatch(processBatch);\n        }\n    };\n    const schedule = stepsOrder.reduce((acc, key) => {\n        const step = steps[key];\n        acc[key] = (process, keepAlive = false, immediate = false) => {\n            if (!runNextFrame)\n                wake();\n            return step.schedule(process, keepAlive, immediate);\n        };\n        return acc;\n    }, {});\n    const cancel = (process) => {\n        for (let i = 0; i < stepsOrder.length; i++) {\n            steps[stepsOrder[i]].cancel(process);\n        }\n    };\n    return { schedule, cancel, state, steps };\n}\n\nexport { createRenderBatcher, stepsOrder };\n"]},"metadata":{},"sourceType":"module"}