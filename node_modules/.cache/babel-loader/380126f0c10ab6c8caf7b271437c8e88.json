{"ast":null,"code":"\"use client\"; // packages/react/roving-focus/src/RovingFocusGroup.tsx\n\nimport * as React from \"react\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { useId } from \"@radix-ui/react-id\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useDirection } from \"@radix-ui/react-direction\";\nimport { jsx } from \"react/jsx-runtime\";\nvar ENTRY_FOCUS = \"rovingFocusGroup.onEntryFocus\";\nvar EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\nvar GROUP_NAME = \"RovingFocusGroup\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(GROUP_NAME);\nvar [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(GROUP_NAME, [createCollectionScope]);\nvar [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME);\nvar RovingFocusGroup = React.forwardRef((props, forwardedRef) => {\n  return /* @__PURE__ */jsx(Collection.Provider, {\n    scope: props.__scopeRovingFocusGroup,\n    children: /* @__PURE__ */jsx(Collection.Slot, {\n      scope: props.__scopeRovingFocusGroup,\n      children: /* @__PURE__ */jsx(RovingFocusGroupImpl, { ...props,\n        ref: forwardedRef\n      })\n    })\n  });\n});\nRovingFocusGroup.displayName = GROUP_NAME;\nvar RovingFocusGroupImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n  React.useEffect(() => {\n    const node = ref.current;\n\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n  return /* @__PURE__ */jsx(RovingFocusProvider, {\n    scope: __scopeRovingFocusGroup,\n    orientation,\n    dir: direction,\n    loop,\n    currentTabStopId,\n    onItemFocus: React.useCallback(tabStopId => setCurrentTabStopId(tabStopId), [setCurrentTabStopId]),\n    onItemShiftTab: React.useCallback(() => setIsTabbingBackOut(true), []),\n    onFocusableItemAdd: React.useCallback(() => setFocusableItemsCount(prevCount => prevCount + 1), []),\n    onFocusableItemRemove: React.useCallback(() => setFocusableItemsCount(prevCount => prevCount - 1), []),\n    children: /* @__PURE__ */jsx(Primitive.div, {\n      tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,\n      \"data-orientation\": orientation,\n      ...groupProps,\n      ref: composedRefs,\n      style: {\n        outline: \"none\",\n        ...props.style\n      },\n      onMouseDown: composeEventHandlers(props.onMouseDown, () => {\n        isClickFocusRef.current = true;\n      }),\n      onFocus: composeEventHandlers(props.onFocus, event => {\n        const isKeyboardFocus = !isClickFocusRef.current;\n\n        if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n          const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n          event.currentTarget.dispatchEvent(entryFocusEvent);\n\n          if (!entryFocusEvent.defaultPrevented) {\n            const items = getItems().filter(item => item.focusable);\n            const activeItem = items.find(item => item.active);\n            const currentItem = items.find(item => item.id === currentTabStopId);\n            const candidateItems = [activeItem, currentItem, ...items].filter(Boolean);\n            const candidateNodes = candidateItems.map(item => item.ref.current);\n            focusFirst(candidateNodes, preventScrollOnEntryFocus);\n          }\n        }\n\n        isClickFocusRef.current = false;\n      }),\n      onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))\n    })\n  });\n});\nvar ITEM_NAME = \"RovingFocusGroupItem\";\nvar RovingFocusGroupItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    focusable = true,\n    active = false,\n    tabStopId,\n    ...itemProps\n  } = props;\n  const autoId = useId();\n  const id = tabStopId || autoId;\n  const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n  const isCurrentTabStop = context.currentTabStopId === id;\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const {\n    onFocusableItemAdd,\n    onFocusableItemRemove\n  } = context;\n  React.useEffect(() => {\n    if (focusable) {\n      onFocusableItemAdd();\n      return () => onFocusableItemRemove();\n    }\n  }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n  return /* @__PURE__ */jsx(Collection.ItemSlot, {\n    scope: __scopeRovingFocusGroup,\n    id,\n    focusable,\n    active,\n    children: /* @__PURE__ */jsx(Primitive.span, {\n      tabIndex: isCurrentTabStop ? 0 : -1,\n      \"data-orientation\": context.orientation,\n      ...itemProps,\n      ref: forwardedRef,\n      onMouseDown: composeEventHandlers(props.onMouseDown, event => {\n        if (!focusable) event.preventDefault();else context.onItemFocus(id);\n      }),\n      onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id)),\n      onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n        if (event.key === \"Tab\" && event.shiftKey) {\n          context.onItemShiftTab();\n          return;\n        }\n\n        if (event.target !== event.currentTarget) return;\n        const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n        if (focusIntent !== void 0) {\n          if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n          event.preventDefault();\n          const items = getItems().filter(item => item.focusable);\n          let candidateNodes = items.map(item => item.ref.current);\n          if (focusIntent === \"last\") candidateNodes.reverse();else if (focusIntent === \"prev\" || focusIntent === \"next\") {\n            if (focusIntent === \"prev\") candidateNodes.reverse();\n            const currentIndex = candidateNodes.indexOf(event.currentTarget);\n            candidateNodes = context.loop ? wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);\n          }\n          setTimeout(() => focusFirst(candidateNodes));\n        }\n      })\n    })\n  });\n});\nRovingFocusGroupItem.displayName = ITEM_NAME;\nvar MAP_KEY_TO_FOCUS_INTENT = {\n  ArrowLeft: \"prev\",\n  ArrowUp: \"prev\",\n  ArrowRight: \"next\",\n  ArrowDown: \"next\",\n  PageUp: \"first\",\n  Home: \"first\",\n  PageDown: \"last\",\n  End: \"last\"\n};\n\nfunction getDirectionAwareKey(key, dir) {\n  if (dir !== \"rtl\") return key;\n  return key === \"ArrowLeft\" ? \"ArrowRight\" : key === \"ArrowRight\" ? \"ArrowLeft\" : key;\n}\n\nfunction getFocusIntent(event, orientation, dir) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === \"vertical\" && [\"ArrowLeft\", \"ArrowRight\"].includes(key)) return void 0;\n  if (orientation === \"horizontal\" && [\"ArrowUp\", \"ArrowDown\"].includes(key)) return void 0;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates) {\n  let preventScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({\n      preventScroll\n    });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\nfunction wrapArray(array, startIndex) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nvar Root = RovingFocusGroup;\nvar Item = RovingFocusGroupItem;\nexport { Item, Root, RovingFocusGroup, RovingFocusGroupItem, createRovingFocusGroupScope };","map":{"version":3,"mappings":"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","names":["React","composeEventHandlers","createCollection","useComposedRefs","createContextScope","useId","Primitive","useCallbackRef","useControllableState","useDirection","ENTRY_FOCUS","EVENT_OPTIONS","bubbles","cancelable","GROUP_NAME","Collection","useCollection","createCollectionScope","createRovingFocusGroupContext","createRovingFocusGroupScope","RovingFocusProvider","useRovingFocusContext","RovingFocusGroup","props","forwardedRef","Provider","scope","__scopeRovingFocusGroup","children","Slot","RovingFocusGroupImpl","ref","displayName","orientation","loop","dir","currentTabStopId","currentTabStopIdProp","defaultCurrentTabStopId","onCurrentTabStopIdChange","onEntryFocus","preventScrollOnEntryFocus","groupProps","composedRefs","direction","setCurrentTabStopId","prop","defaultProp","onChange","isTabbingBackOut","setIsTabbingBackOut","handleEntryFocus","getItems","isClickFocusRef","focusableItemsCount","setFocusableItemsCount","node","current","addEventListener","removeEventListener","onItemFocus","tabStopId","onItemShiftTab","onFocusableItemAdd","prevCount","onFocusableItemRemove","div","tabIndex","style","outline","onMouseDown","onFocus","event","isKeyboardFocus","target","currentTarget","entryFocusEvent","CustomEvent","dispatchEvent","defaultPrevented","items","filter","item","focusable","activeItem","find","active","currentItem","id","candidateItems","Boolean","candidateNodes","map","focusFirst","onBlur","ITEM_NAME","RovingFocusGroupItem","itemProps","autoId","context","isCurrentTabStop","ItemSlot","span","preventDefault","onKeyDown","key","shiftKey","focusIntent","getFocusIntent","metaKey","ctrlKey","altKey","reverse","currentIndex","indexOf","wrapArray","slice","setTimeout","MAP_KEY_TO_FOCUS_INTENT","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","PageUp","Home","PageDown","End","getDirectionAwareKey","includes","candidates","preventScroll","PREVIOUSLY_FOCUSED_ELEMENT","document","activeElement","candidate","focus","array","startIndex","_","index","length","Root","Item"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-roving-focus/src/RovingFocusGroup.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\n\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n  onFocusableItemAdd(): void;\n  onFocusableItemRemove(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n  preventScrollOnEntryFocus?: boolean;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    loop = false,\n    dir,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    preventScrollOnEntryFocus = false,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const direction = useDirection(dir);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n  const [focusableItemsCount, setFocusableItemsCount] = React.useState(0);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={direction}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n      onFocusableItemAdd={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount + 1),\n        []\n      )}\n      onFocusableItemRemove={React.useCallback(\n        () => setFocusableItemsCount((prevCount) => prevCount - 1),\n        []\n      )}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes, preventScrollOnEntryFocus);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends PrimitiveSpanProps {\n  tabStopId?: string;\n  focusable?: boolean;\n  active?: boolean;\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const {\n      __scopeRovingFocusGroup,\n      focusable = true,\n      active = false,\n      tabStopId,\n      ...itemProps\n    } = props;\n    const autoId = useId();\n    const id = tabStopId || autoId;\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    const { onFocusableItemAdd, onFocusableItemRemove } = context;\n\n    React.useEffect(() => {\n      if (focusable) {\n        onFocusableItemAdd();\n        return () => onFocusableItemRemove();\n      }\n    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        />\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[], preventScroll = false) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus({ preventScroll });\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n"]},"metadata":{},"sourceType":"module"}