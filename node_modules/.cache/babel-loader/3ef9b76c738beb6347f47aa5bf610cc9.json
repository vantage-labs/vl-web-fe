{"ast":null,"code":"import { supportsLinearEasing, attachTimeline, isGenerator, isWaapiSupportedEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { anticipate } from '../../easing/anticipate.mjs';\nimport { backInOut } from '../../easing/back.mjs';\nimport { circInOut } from '../../easing/circ.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\nimport { startWaapiAnimation } from './waapi/index.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nimport { supportsWaapi } from './waapi/utils/supports-waapi.mjs';\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\n\nconst sampleDelta = 10; //ms\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\n\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\n\nfunction requiresPregeneratedKeyframes(options) {\n  return isGenerator(options.type) || options.type === \"spring\" || !isWaapiSupportedEasing(options.ease);\n}\n\nfunction pregenerateKeyframes(keyframes, options) {\n  /**\n   * Create a main-thread animation to pregenerate keyframes.\n   * We sample this at regular intervals to generate keyframes that we then\n   * linearly interpolate between.\n   */\n  const sampleAnimation = new MainThreadAnimation({ ...options,\n    keyframes,\n    repeat: 0,\n    delay: 0,\n    isGenerator: true\n  });\n  let state = {\n    done: false,\n    value: keyframes[0]\n  };\n  const pregeneratedKeyframes = [];\n  /**\n   * Bail after 20 seconds of pre-generated keyframes as it's likely\n   * we're heading for an infinite loop.\n   */\n\n  let t = 0;\n\n  while (!state.done && t < maxDuration) {\n    state = sampleAnimation.sample(t);\n    pregeneratedKeyframes.push(state.value);\n    t += sampleDelta;\n  }\n\n  return {\n    times: undefined,\n    keyframes: pregeneratedKeyframes,\n    duration: t - sampleDelta,\n    ease: \"linear\"\n  };\n}\n\nconst unsupportedEasingFunctions = {\n  anticipate,\n  backInOut,\n  circInOut\n};\n\nfunction isUnsupportedEase(key) {\n  return key in unsupportedEasingFunctions;\n}\n\nclass AcceleratedAnimation extends BaseAnimation {\n  constructor(options) {\n    super(options);\n    const {\n      name,\n      motionValue,\n      element,\n      keyframes\n    } = this.options;\n    this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n    this.resolver.scheduleResolve();\n  }\n\n  initPlayback(keyframes, finalKeyframe) {\n    var _a;\n\n    let {\n      duration = 300,\n      times,\n      ease,\n      type,\n      motionValue,\n      name,\n      startTime\n    } = this.options;\n    /**\n     * If element has since been unmounted, return false to indicate\n     * the animation failed to initialised.\n     */\n\n    if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n      return false;\n    }\n    /**\n     * If the user has provided an easing function name that isn't supported\n     * by WAAPI (like \"anticipate\"), we need to provide the corressponding\n     * function. This will later get converted to a linear() easing function.\n     */\n\n\n    if (typeof ease === \"string\" && supportsLinearEasing() && isUnsupportedEase(ease)) {\n      ease = unsupportedEasingFunctions[ease];\n    }\n    /**\n     * If this animation needs pre-generated keyframes then generate.\n     */\n\n\n    if (requiresPregeneratedKeyframes(this.options)) {\n      const {\n        onComplete,\n        onUpdate,\n        motionValue,\n        element,\n        ...options\n      } = this.options;\n      const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n      keyframes = pregeneratedAnimation.keyframes; // If this is a very short animation, ensure we have\n      // at least two keyframes to animate between as older browsers\n      // can't animate between a single keyframe.\n\n      if (keyframes.length === 1) {\n        keyframes[1] = keyframes[0];\n      }\n\n      duration = pregeneratedAnimation.duration;\n      times = pregeneratedAnimation.times;\n      ease = pregeneratedAnimation.ease;\n      type = \"keyframes\";\n    }\n\n    const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options,\n      duration,\n      times,\n      ease\n    }); // Override the browser calculated startTime with one synchronised to other JS\n    // and WAAPI animations starting this event loop.\n\n    animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n\n    if (this.pendingTimeline) {\n      attachTimeline(animation, this.pendingTimeline);\n      this.pendingTimeline = undefined;\n    } else {\n      /**\n       * Prefer the `onfinish` prop as it's more widely supported than\n       * the `finished` promise.\n       *\n       * Here, we synchronously set the provided MotionValue to the end\n       * keyframe. If we didn't, when the WAAPI animation is finished it would\n       * be removed from the element which would then revert to its old styles.\n       */\n      animation.onfinish = () => {\n        const {\n          onComplete\n        } = this.options;\n        motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n        onComplete && onComplete();\n        this.cancel();\n        this.resolveFinishedPromise();\n      };\n    }\n\n    return {\n      animation,\n      duration,\n      times,\n      type,\n      ease,\n      keyframes: keyframes\n    };\n  }\n\n  get duration() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return 0;\n    const {\n      duration\n    } = resolved;\n    return millisecondsToSeconds(duration);\n  }\n\n  get time() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return 0;\n    const {\n      animation\n    } = resolved;\n    return millisecondsToSeconds(animation.currentTime || 0);\n  }\n\n  set time(newTime) {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n    animation.currentTime = secondsToMilliseconds(newTime);\n  }\n\n  get speed() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return 1;\n    const {\n      animation\n    } = resolved;\n    return animation.playbackRate;\n  }\n\n  set speed(newSpeed) {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n    animation.playbackRate = newSpeed;\n  }\n\n  get state() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return \"idle\";\n    const {\n      animation\n    } = resolved;\n    return animation.playState;\n  }\n\n  get startTime() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return null;\n    const {\n      animation\n    } = resolved; // Coerce to number as TypeScript incorrectly types this\n    // as CSSNumberish\n\n    return animation.startTime;\n  }\n  /**\n   * Replace the default DocumentTimeline with another AnimationTimeline.\n   * Currently used for scroll animations.\n   */\n\n\n  attachTimeline(timeline) {\n    if (!this._resolved) {\n      this.pendingTimeline = timeline;\n    } else {\n      const {\n        resolved\n      } = this;\n      if (!resolved) return noop;\n      const {\n        animation\n      } = resolved;\n      attachTimeline(animation, timeline);\n    }\n\n    return noop;\n  }\n\n  play() {\n    if (this.isStopped) return;\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n\n    if (animation.playState === \"finished\") {\n      this.updateFinishedPromise();\n    }\n\n    animation.play();\n  }\n\n  pause() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n    animation.pause();\n  }\n\n  stop() {\n    this.resolver.cancel();\n    this.isStopped = true;\n    if (this.state === \"idle\") return;\n    this.resolveFinishedPromise();\n    this.updateFinishedPromise();\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation,\n      keyframes,\n      duration,\n      type,\n      ease,\n      times\n    } = resolved;\n\n    if (animation.playState === \"idle\" || animation.playState === \"finished\") {\n      return;\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * Rather than read commited styles back out of the DOM, we can\n     * create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to calculate velocity for any subsequent animation.\n     */\n\n\n    if (this.time) {\n      const {\n        motionValue,\n        onUpdate,\n        onComplete,\n        element,\n        ...options\n      } = this.options;\n      const sampleAnimation = new MainThreadAnimation({ ...options,\n        keyframes,\n        duration,\n        type,\n        ease,\n        times,\n        isGenerator: true\n      });\n      const sampleTime = secondsToMilliseconds(this.time);\n      motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n    }\n\n    const {\n      onStop\n    } = this.options;\n    onStop && onStop();\n    this.cancel();\n  }\n\n  complete() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    resolved.animation.finish();\n  }\n\n  cancel() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    resolved.animation.cancel();\n  }\n\n  static supports(options) {\n    const {\n      motionValue,\n      name,\n      repeatDelay,\n      repeatType,\n      damping,\n      type\n    } = options;\n    return supportsWaapi() && name && acceleratedValues.has(name) && motionValue && motionValue.owner && motionValue.owner.current instanceof HTMLElement &&\n    /**\n     * If we're outputting values to onUpdate then we can't use WAAPI as there's\n     * no way to read the value from WAAPI every frame.\n     */\n    !motionValue.owner.getProps().onUpdate && !repeatDelay && repeatType !== \"mirror\" && damping !== 0 && type !== \"inertia\";\n  }\n\n}\n\nexport { AcceleratedAnimation };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs"],"names":["supportsLinearEasing","attachTimeline","isGenerator","isWaapiSupportedEasing","millisecondsToSeconds","secondsToMilliseconds","noop","anticipate","backInOut","circInOut","DOMKeyframesResolver","BaseAnimation","MainThreadAnimation","acceleratedValues","startWaapiAnimation","getFinalKeyframe","supportsWaapi","sampleDelta","maxDuration","requiresPregeneratedKeyframes","options","type","ease","pregenerateKeyframes","keyframes","sampleAnimation","repeat","delay","state","done","value","pregeneratedKeyframes","t","sample","push","times","undefined","duration","unsupportedEasingFunctions","isUnsupportedEase","key","AcceleratedAnimation","constructor","name","motionValue","element","resolver","resolvedKeyframes","finalKeyframe","onKeyframesResolved","scheduleResolve","initPlayback","_a","startTime","owner","current","onComplete","onUpdate","pregeneratedAnimation","length","animation","calcStartTime","pendingTimeline","onfinish","set","cancel","resolveFinishedPromise","resolved","time","currentTime","newTime","speed","playbackRate","newSpeed","playState","timeline","_resolved","play","isStopped","updateFinishedPromise","pause","stop","sampleTime","setWithVelocity","onStop","complete","finish","supports","repeatDelay","repeatType","damping","has","HTMLElement","getProps"],"mappings":"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","sourcesContent":["import { supportsLinearEasing, attachTimeline, isGenerator, isWaapiSupportedEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { anticipate } from '../../easing/anticipate.mjs';\nimport { backInOut } from '../../easing/back.mjs';\nimport { circInOut } from '../../easing/circ.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\nimport { startWaapiAnimation } from './waapi/index.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nimport { supportsWaapi } from './waapi/utils/supports-waapi.mjs';\n\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n    return (isGenerator(options.type) ||\n        options.type === \"spring\" ||\n        !isWaapiSupportedEasing(options.ease));\n}\nfunction pregenerateKeyframes(keyframes, options) {\n    /**\n     * Create a main-thread animation to pregenerate keyframes.\n     * We sample this at regular intervals to generate keyframes that we then\n     * linearly interpolate between.\n     */\n    const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes,\n        repeat: 0,\n        delay: 0,\n        isGenerator: true,\n    });\n    let state = { done: false, value: keyframes[0] };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n        state = sampleAnimation.sample(t);\n        pregeneratedKeyframes.push(state.value);\n        t += sampleDelta;\n    }\n    return {\n        times: undefined,\n        keyframes: pregeneratedKeyframes,\n        duration: t - sampleDelta,\n        ease: \"linear\",\n    };\n}\nconst unsupportedEasingFunctions = {\n    anticipate,\n    backInOut,\n    circInOut,\n};\nfunction isUnsupportedEase(key) {\n    return key in unsupportedEasingFunctions;\n}\nclass AcceleratedAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        const { name, motionValue, element, keyframes } = this.options;\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes, finalKeyframe) {\n        var _a;\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\n        /**\n         * If element has since been unmounted, return false to indicate\n         * the animation failed to initialised.\n         */\n        if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n            return false;\n        }\n        /**\n         * If the user has provided an easing function name that isn't supported\n         * by WAAPI (like \"anticipate\"), we need to provide the corressponding\n         * function. This will later get converted to a linear() easing function.\n         */\n        if (typeof ease === \"string\" &&\n            supportsLinearEasing() &&\n            isUnsupportedEase(ease)) {\n            ease = unsupportedEasingFunctions[ease];\n        }\n        /**\n         * If this animation needs pre-generated keyframes then generate.\n         */\n        if (requiresPregeneratedKeyframes(this.options)) {\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n            keyframes = pregeneratedAnimation.keyframes;\n            // If this is a very short animation, ensure we have\n            // at least two keyframes to animate between as older browsers\n            // can't animate between a single keyframe.\n            if (keyframes.length === 1) {\n                keyframes[1] = keyframes[0];\n            }\n            duration = pregeneratedAnimation.duration;\n            times = pregeneratedAnimation.times;\n            ease = pregeneratedAnimation.ease;\n            type = \"keyframes\";\n        }\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\n        // Override the browser calculated startTime with one synchronised to other JS\n        // and WAAPI animations starting this event loop.\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        if (this.pendingTimeline) {\n            attachTimeline(animation, this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        else {\n            /**\n             * Prefer the `onfinish` prop as it's more widely supported than\n             * the `finished` promise.\n             *\n             * Here, we synchronously set the provided MotionValue to the end\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\n             * be removed from the element which would then revert to its old styles.\n             */\n            animation.onfinish = () => {\n                const { onComplete } = this.options;\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.cancel();\n                this.resolveFinishedPromise();\n            };\n        }\n        return {\n            animation,\n            duration,\n            times,\n            type,\n            ease,\n            keyframes: keyframes,\n        };\n    }\n    get duration() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { duration } = resolved;\n        return millisecondsToSeconds(duration);\n    }\n    get time() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { animation } = resolved;\n        return millisecondsToSeconds(animation.currentTime || 0);\n    }\n    set time(newTime) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    get speed() {\n        const { resolved } = this;\n        if (!resolved)\n            return 1;\n        const { animation } = resolved;\n        return animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.playbackRate = newSpeed;\n    }\n    get state() {\n        const { resolved } = this;\n        if (!resolved)\n            return \"idle\";\n        const { animation } = resolved;\n        return animation.playState;\n    }\n    get startTime() {\n        const { resolved } = this;\n        if (!resolved)\n            return null;\n        const { animation } = resolved;\n        // Coerce to number as TypeScript incorrectly types this\n        // as CSSNumberish\n        return animation.startTime;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n    attachTimeline(timeline) {\n        if (!this._resolved) {\n            this.pendingTimeline = timeline;\n        }\n        else {\n            const { resolved } = this;\n            if (!resolved)\n                return noop;\n            const { animation } = resolved;\n            attachTimeline(animation, timeline);\n        }\n        return noop;\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        if (animation.playState === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        animation.play();\n    }\n    pause() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.pause();\n    }\n    stop() {\n        this.resolver.cancel();\n        this.isStopped = true;\n        if (this.state === \"idle\")\n            return;\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation, keyframes, duration, type, ease, times } = resolved;\n        if (animation.playState === \"idle\" ||\n            animation.playState === \"finished\") {\n            return;\n        }\n        /**\n         * WAAPI doesn't natively have any interruption capabilities.\n         *\n         * Rather than read commited styles back out of the DOM, we can\n         * create a renderless JS animation and sample it twice to calculate\n         * its current value, \"previous\" value, and therefore allow\n         * Motion to calculate velocity for any subsequent animation.\n         */\n        if (this.time) {\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\n            const sampleAnimation = new MainThreadAnimation({\n                ...options,\n                keyframes,\n                duration,\n                type,\n                ease,\n                times,\n                isGenerator: true,\n            });\n            const sampleTime = secondsToMilliseconds(this.time);\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        }\n        const { onStop } = this.options;\n        onStop && onStop();\n        this.cancel();\n    }\n    complete() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.finish();\n    }\n    cancel() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.cancel();\n    }\n    static supports(options) {\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n        return (supportsWaapi() &&\n            name &&\n            acceleratedValues.has(name) &&\n            motionValue &&\n            motionValue.owner &&\n            motionValue.owner.current instanceof HTMLElement &&\n            /**\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\n             * no way to read the value from WAAPI every frame.\n             */\n            !motionValue.owner.getProps().onUpdate &&\n            !repeatDelay &&\n            repeatType !== \"mirror\" &&\n            damping !== 0 &&\n            type !== \"inertia\");\n    }\n}\n\nexport { AcceleratedAnimation };\n"]},"metadata":{},"sourceType":"module"}