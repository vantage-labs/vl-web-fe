{"ast":null,"code":"import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia(_ref) {\n  var keyframes = _ref.keyframes,\n      _ref$velocity = _ref.velocity,\n      velocity = _ref$velocity === void 0 ? 0.0 : _ref$velocity,\n      _ref$power = _ref.power,\n      power = _ref$power === void 0 ? 0.8 : _ref$power,\n      _ref$timeConstant = _ref.timeConstant,\n      timeConstant = _ref$timeConstant === void 0 ? 325 : _ref$timeConstant,\n      _ref$bounceDamping = _ref.bounceDamping,\n      bounceDamping = _ref$bounceDamping === void 0 ? 10 : _ref$bounceDamping,\n      _ref$bounceStiffness = _ref.bounceStiffness,\n      bounceStiffness = _ref$bounceStiffness === void 0 ? 500 : _ref$bounceStiffness,\n      modifyTarget = _ref.modifyTarget,\n      min = _ref.min,\n      max = _ref.max,\n      _ref$restDelta = _ref.restDelta,\n      restDelta = _ref$restDelta === void 0 ? 0.5 : _ref$restDelta,\n      restSpeed = _ref.restSpeed;\n  var origin = keyframes[0];\n  var state = {\n    done: false,\n    value: origin\n  };\n\n  var isOutOfBounds = function isOutOfBounds(v) {\n    return min !== undefined && v < min || max !== undefined && v > max;\n  };\n\n  var nearestBoundary = function nearestBoundary(v) {\n    if (min === undefined) return max;\n    if (max === undefined) return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  };\n\n  var amplitude = power * velocity;\n  var ideal = origin + amplitude;\n  var target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n  /**\n   * If the target has changed we need to re-calculate the amplitude, otherwise\n   * the animation will start from the wrong position.\n   */\n\n  if (target !== ideal) amplitude = target - origin;\n\n  var calcDelta = function calcDelta(t) {\n    return -amplitude * Math.exp(-t / timeConstant);\n  };\n\n  var calcLatest = function calcLatest(t) {\n    return target + calcDelta(t);\n  };\n\n  var applyFriction = function applyFriction(t) {\n    var delta = calcDelta(t);\n    var latest = calcLatest(t);\n    state.done = Math.abs(delta) <= restDelta;\n    state.value = state.done ? target : latest;\n  };\n  /**\n   * Ideally this would resolve for t in a stateless way, we could\n   * do that by always precalculating the animation but as we know\n   * this will be done anyway we can assume that spring will\n   * be discovered during that.\n   */\n\n\n  var timeReachedBoundary;\n  var spring$1;\n\n  var checkCatchBoundary = function checkCatchBoundary(t) {\n    if (!isOutOfBounds(state.value)) return;\n    timeReachedBoundary = t;\n    spring$1 = spring({\n      keyframes: [state.value, nearestBoundary(state.value)],\n      velocity: calcGeneratorVelocity(calcLatest, t, state.value),\n      // TODO: This should be passing * 1000\n      damping: bounceDamping,\n      stiffness: bounceStiffness,\n      restDelta: restDelta,\n      restSpeed: restSpeed\n    });\n  };\n\n  checkCatchBoundary(0);\n  return {\n    calculatedDuration: null,\n    next: function next(t) {\n      /**\n       * We need to resolve the friction to figure out if we need a\n       * spring but we don't want to do this twice per frame. So here\n       * we flag if we updated for this frame and later if we did\n       * we can skip doing it again.\n       */\n      var hasUpdatedFrame = false;\n\n      if (!spring$1 && timeReachedBoundary === undefined) {\n        hasUpdatedFrame = true;\n        applyFriction(t);\n        checkCatchBoundary(t);\n      }\n      /**\n       * If we have a spring and the provided t is beyond the moment the friction\n       * animation crossed the min/max boundary, use the spring.\n       */\n\n\n      if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n        return spring$1.next(t - timeReachedBoundary);\n      } else {\n        !hasUpdatedFrame && applyFriction(t);\n        return state;\n      }\n    }\n  };\n}\n\nexport { inertia };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/animation/generators/inertia.mjs"],"names":["spring","calcGeneratorVelocity","inertia","keyframes","velocity","power","timeConstant","bounceDamping","bounceStiffness","modifyTarget","min","max","restDelta","restSpeed","origin","state","done","value","isOutOfBounds","v","undefined","nearestBoundary","Math","abs","amplitude","ideal","target","calcDelta","t","exp","calcLatest","applyFriction","delta","latest","timeReachedBoundary","spring$1","checkCatchBoundary","damping","stiffness","calculatedDuration","next","hasUpdatedFrame"],"mappings":"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","sourcesContent":["import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value), // TODO: This should be passing * 1000\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nexport { inertia };\n"]},"metadata":{},"sourceType":"module"}