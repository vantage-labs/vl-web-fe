{"ast":null,"code":"// packages/react/slot/src/Slot.tsx\nimport * as React from \"react\";\nimport { composeRefs } from \"@radix-ui/react-compose-refs\";\nimport { Fragment, jsx } from \"react/jsx-runtime\";\nvar Slot = React.forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    ...slotProps\n  } = props;\n  const childrenArray = React.Children.toArray(children);\n  const slottable = childrenArray.find(isSlottable);\n\n  if (slottable) {\n    const newElement = slottable.props.children;\n    const newChildren = childrenArray.map(child => {\n      if (child === slottable) {\n        if (React.Children.count(newElement) > 1) return React.Children.only(null);\n        return React.isValidElement(newElement) ? newElement.props.children : null;\n      } else {\n        return child;\n      }\n    });\n    return /* @__PURE__ */jsx(SlotClone, { ...slotProps,\n      ref: forwardedRef,\n      children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null\n    });\n  }\n\n  return /* @__PURE__ */jsx(SlotClone, { ...slotProps,\n    ref: forwardedRef,\n    children\n  });\n});\nSlot.displayName = \"Slot\";\nvar SlotClone = React.forwardRef((props, forwardedRef) => {\n  const {\n    children,\n    ...slotProps\n  } = props;\n\n  if (React.isValidElement(children)) {\n    const childrenRef = getElementRef(children);\n    return React.cloneElement(children, { ...mergeProps(slotProps, children.props),\n      // @ts-ignore\n      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef\n    });\n  }\n\n  return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n});\nSlotClone.displayName = \"SlotClone\";\n\nvar Slottable = _ref => {\n  let {\n    children\n  } = _ref;\n  return /* @__PURE__ */jsx(Fragment, {\n    children\n  });\n};\n\nfunction isSlottable(child) {\n  return React.isValidElement(child) && child.type === Slottable;\n}\n\nfunction mergeProps(slotProps, childProps) {\n  const overrideProps = { ...childProps\n  };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n    const isHandler = /^on[A-Z]/.test(propName);\n\n    if (isHandler) {\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = function () {\n          childPropValue(...arguments);\n          slotPropValue(...arguments);\n        };\n      } else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    } else if (propName === \"style\") {\n      overrideProps[propName] = { ...slotPropValue,\n        ...childPropValue\n      };\n    } else if (propName === \"className\") {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(\" \");\n    }\n  }\n\n  return { ...slotProps,\n    ...overrideProps\n  };\n}\n\nfunction getElementRef(element) {\n  let getter = Object.getOwnPropertyDescriptor(element.props, \"ref\")?.get;\n  let mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n\n  if (mayWarn) {\n    return element.ref;\n  }\n\n  getter = Object.getOwnPropertyDescriptor(element, \"ref\")?.get;\n  mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n\n  if (mayWarn) {\n    return element.props.ref;\n  }\n\n  return element.props.ref || element.ref;\n}\n\nvar Root = Slot;\nexport { Root, Slot, Slottable };","map":{"version":3,"mappings":"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","names":["React","composeRefs","Fragment","Slot","props","forwardedRef","children","slotProps","childrenArray","toArray","slottable","find","isSlottable","newElement","newChildren","map","child","count","only","SlotClone","ref","displayName","childrenRef","getElementRef","mergeProps","Slottable","type","childProps","overrideProps","propName","slotPropValue","childPropValue","isHandler","test","filter","Boolean","join","element","getter","Object","getOwnPropertyDescriptor","get","mayWarn","isReactWarning","Root"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-slot/src/Slot.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeRefs } from '@radix-ui/react-compose-refs';\n\n/* -------------------------------------------------------------------------------------------------\n * Slot\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotProps extends React.HTMLAttributes<HTMLElement> {\n  children?: React.ReactNode;\n}\n\nconst Slot = React.forwardRef<HTMLElement, SlotProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n  const childrenArray = React.Children.toArray(children);\n  const slottable = childrenArray.find(isSlottable);\n\n  if (slottable) {\n    // the new element to render is the one passed as a child of `Slottable`\n    const newElement = slottable.props.children;\n\n    const newChildren = childrenArray.map((child) => {\n      if (child === slottable) {\n        // because the new element will be the one rendered, we are only interested\n        // in grabbing its children (`newElement.props.children`)\n        if (React.Children.count(newElement) > 1) return React.Children.only(null);\n        return React.isValidElement(newElement)\n          ? (newElement.props as { children: React.ReactNode }).children\n          : null;\n      } else {\n        return child;\n      }\n    });\n\n    return (\n      <SlotClone {...slotProps} ref={forwardedRef}>\n        {React.isValidElement(newElement)\n          ? React.cloneElement(newElement, undefined, newChildren)\n          : null}\n      </SlotClone>\n    );\n  }\n\n  return (\n    <SlotClone {...slotProps} ref={forwardedRef}>\n      {children}\n    </SlotClone>\n  );\n});\n\nSlot.displayName = 'Slot';\n\n/* -------------------------------------------------------------------------------------------------\n * SlotClone\n * -----------------------------------------------------------------------------------------------*/\n\ninterface SlotCloneProps {\n  children: React.ReactNode;\n}\n\nconst SlotClone = React.forwardRef<any, SlotCloneProps>((props, forwardedRef) => {\n  const { children, ...slotProps } = props;\n\n  if (React.isValidElement(children)) {\n    const childrenRef = getElementRef(children);\n    return React.cloneElement(children, {\n      ...mergeProps(slotProps, children.props as AnyProps),\n      // @ts-ignore\n      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef,\n    });\n  }\n\n  return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n});\n\nSlotClone.displayName = 'SlotClone';\n\n/* -------------------------------------------------------------------------------------------------\n * Slottable\n * -----------------------------------------------------------------------------------------------*/\n\nconst Slottable = ({ children }: { children: React.ReactNode }) => {\n  return <>{children}</>;\n};\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype AnyProps = Record<string, any>;\n\nfunction isSlottable(\n  child: React.ReactNode\n): child is React.ReactElement<React.ComponentProps<typeof Slottable>, typeof Slottable> {\n  return React.isValidElement(child) && child.type === Slottable;\n}\n\nfunction mergeProps(slotProps: AnyProps, childProps: AnyProps) {\n  // all child props should override\n  const overrideProps = { ...childProps };\n\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      // if the handler exists on both, we compose them\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args: unknown[]) => {\n          childPropValue(...args);\n          slotPropValue(...args);\n        };\n      }\n      // but if it exists only on the slot, we use only this one\n      else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    }\n    // if it's `style`, we merge them\n    else if (propName === 'style') {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === 'className') {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(' ');\n    }\n  }\n\n  return { ...slotProps, ...overrideProps };\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element.props as { ref?: React.Ref<unknown> }).ref;\n  }\n\n  // Not DEV\n  return (element.props as { ref?: React.Ref<unknown> }).ref || (element as any).ref;\n}\n\nconst Root = Slot;\n\nexport {\n  Slot,\n  Slottable,\n  //\n  Root,\n};\nexport type { SlotProps };\n"]},"metadata":{},"sourceType":"module"}