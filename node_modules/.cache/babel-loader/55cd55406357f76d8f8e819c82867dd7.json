{"ast":null,"code":"import { appearStoreId } from './store-id.mjs';\nimport { startWaapiAnimation } from '../animators/waapi/index.mjs';\nimport { optimizedAppearDataId } from './data-id.mjs';\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\nimport { appearAnimationStore, appearComplete } from './store.mjs';\nimport { noop } from 'motion-utils';\nimport { getOptimisedAppearId } from './get-appear-id.mjs';\n/**\n * A single time to use across all animations to manually set startTime\n * and ensure they're all in sync.\n */\n\nlet startFrameTime;\n/**\n * A dummy animation to detect when Chrome is ready to start\n * painting the page and hold off from triggering the real animation\n * until then. We only need one animation to detect paint ready.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n */\n\nlet readyAnimation;\n/**\n * Keep track of animations that were suspended vs cancelled so we\n * can easily resume them when we're done measuring layout.\n */\n\nconst suspendedAnimations = new Set();\n\nfunction resumeSuspendedAnimations() {\n  suspendedAnimations.forEach(data => {\n    data.animation.play();\n    data.animation.startTime = data.startTime;\n  });\n  suspendedAnimations.clear();\n}\n\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n  // Prevent optimised appear animations if Motion has already started animating.\n  if (window.MotionIsMounted) {\n    return;\n  }\n\n  const id = element.dataset[optimizedAppearDataId];\n  if (!id) return;\n  window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n  const storeId = appearStoreId(id, name);\n\n  if (!readyAnimation) {\n    readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]],\n    /**\n     * 10 secs is basically just a super-safe duration to give Chrome\n     * long enough to get the animation ready.\n     */\n    {\n      duration: 10000,\n      ease: \"linear\"\n    });\n    appearAnimationStore.set(storeId, {\n      animation: readyAnimation,\n      startTime: null\n    });\n    /**\n     * If there's no readyAnimation then there's been no instantiation\n     * of handoff animations.\n     */\n\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n\n    window.MotionHasOptimisedAnimation = (elementId, valueName) => {\n      if (!elementId) return false;\n      /**\n       * Keep a map of elementIds that have started animating. We check\n       * via ID instead of Element because of hydration errors and\n       * pre-hydration checks. We also actively record IDs as they start\n       * animating rather than simply checking for data-appear-id as\n       * this attrbute might be present but not lead to an animation, for\n       * instance if the element's appear animation is on a different\n       * breakpoint.\n       */\n\n      if (!valueName) {\n        return appearComplete.has(elementId);\n      }\n\n      const animationId = appearStoreId(elementId, valueName);\n      return Boolean(appearAnimationStore.get(animationId));\n    };\n\n    window.MotionHandoffMarkAsComplete = elementId => {\n      if (appearComplete.has(elementId)) {\n        appearComplete.set(elementId, true);\n      }\n    };\n\n    window.MotionHandoffIsComplete = elementId => {\n      return appearComplete.get(elementId) === true;\n    };\n    /**\n     * We only need to cancel transform animations as\n     * they're the ones that will interfere with the\n     * layout animation measurements.\n     */\n\n\n    window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\n      const animationId = appearStoreId(elementId, valueName);\n      const data = appearAnimationStore.get(animationId);\n      if (!data) return;\n\n      if (frame && canResume === undefined) {\n        /**\n         * Wait until the end of the subsequent frame to cancel the animation\n         * to ensure we don't remove the animation before the main thread has\n         * had a chance to resolve keyframes and render.\n         */\n        frame.postRender(() => {\n          frame.postRender(() => {\n            data.animation.cancel();\n          });\n        });\n      } else {\n        data.animation.cancel();\n      }\n\n      if (frame && canResume) {\n        suspendedAnimations.add(data);\n        frame.render(resumeSuspendedAnimations);\n      } else {\n        appearAnimationStore.delete(animationId);\n        /**\n         * If there are no more animations left, we can remove the cancel function.\n         * This will let us know when we can stop checking for conflicting layout animations.\n         */\n\n        if (!appearAnimationStore.size) {\n          window.MotionCancelOptimisedAnimation = undefined;\n        }\n      }\n    };\n\n    window.MotionCheckAppearSync = (visualElement, valueName, value) => {\n      var _a, _b;\n\n      const appearId = getOptimisedAppearId(visualElement);\n      if (!appearId) return;\n      const valueIsOptimised = (_a = window.MotionHasOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n      const externalAnimationValue = (_b = visualElement.props.values) === null || _b === void 0 ? void 0 : _b[valueName];\n      if (!valueIsOptimised || !externalAnimationValue) return;\n      const removeSyncCheck = value.on(\"change\", latestValue => {\n        var _a;\n\n        if (externalAnimationValue.get() !== latestValue) {\n          (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n          removeSyncCheck();\n        }\n      });\n      return removeSyncCheck;\n    };\n  }\n\n  const startAnimation = () => {\n    readyAnimation.cancel();\n    const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\n    /**\n     * Record the time of the first started animation. We call performance.now() once\n     * here and once in handoff to ensure we're getting\n     * close to a frame-locked time. This keeps all animations in sync.\n     */\n\n    if (startFrameTime === undefined) {\n      startFrameTime = performance.now();\n    }\n\n    appearAnimation.startTime = startFrameTime;\n    appearAnimationStore.set(storeId, {\n      animation: appearAnimation,\n      startTime: startFrameTime\n    });\n    if (onReady) onReady(appearAnimation);\n  };\n\n  appearComplete.set(id, false);\n\n  if (readyAnimation.ready) {\n    readyAnimation.ready.then(startAnimation).catch(noop);\n  } else {\n    startAnimation();\n  }\n}\n\nexport { startOptimizedAppearAnimation };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs"],"names":["appearStoreId","startWaapiAnimation","optimizedAppearDataId","handoffOptimizedAppearAnimation","appearAnimationStore","appearComplete","noop","getOptimisedAppearId","startFrameTime","readyAnimation","suspendedAnimations","Set","resumeSuspendedAnimations","forEach","data","animation","play","startTime","clear","startOptimizedAppearAnimation","element","name","keyframes","options","onReady","window","MotionIsMounted","id","dataset","MotionHandoffAnimation","storeId","duration","ease","set","MotionHasOptimisedAnimation","elementId","valueName","has","animationId","Boolean","get","MotionHandoffMarkAsComplete","MotionHandoffIsComplete","MotionCancelOptimisedAnimation","frame","canResume","undefined","postRender","cancel","add","render","delete","size","MotionCheckAppearSync","visualElement","value","_a","_b","appearId","valueIsOptimised","call","externalAnimationValue","props","values","removeSyncCheck","on","latestValue","startAnimation","appearAnimation","performance","now","ready","then","catch"],"mappings":"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","sourcesContent":["import { appearStoreId } from './store-id.mjs';\nimport { startWaapiAnimation } from '../animators/waapi/index.mjs';\nimport { optimizedAppearDataId } from './data-id.mjs';\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\nimport { appearAnimationStore, appearComplete } from './store.mjs';\nimport { noop } from 'motion-utils';\nimport { getOptimisedAppearId } from './get-appear-id.mjs';\n\n/**\n * A single time to use across all animations to manually set startTime\n * and ensure they're all in sync.\n */\nlet startFrameTime;\n/**\n * A dummy animation to detect when Chrome is ready to start\n * painting the page and hold off from triggering the real animation\n * until then. We only need one animation to detect paint ready.\n *\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\n */\nlet readyAnimation;\n/**\n * Keep track of animations that were suspended vs cancelled so we\n * can easily resume them when we're done measuring layout.\n */\nconst suspendedAnimations = new Set();\nfunction resumeSuspendedAnimations() {\n    suspendedAnimations.forEach((data) => {\n        data.animation.play();\n        data.animation.startTime = data.startTime;\n    });\n    suspendedAnimations.clear();\n}\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n    // Prevent optimised appear animations if Motion has already started animating.\n    if (window.MotionIsMounted) {\n        return;\n    }\n    const id = element.dataset[optimizedAppearDataId];\n    if (!id)\n        return;\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n    const storeId = appearStoreId(id, name);\n    if (!readyAnimation) {\n        readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]], \n        /**\n         * 10 secs is basically just a super-safe duration to give Chrome\n         * long enough to get the animation ready.\n         */\n        { duration: 10000, ease: \"linear\" });\n        appearAnimationStore.set(storeId, {\n            animation: readyAnimation,\n            startTime: null,\n        });\n        /**\n         * If there's no readyAnimation then there's been no instantiation\n         * of handoff animations.\n         */\n        window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n        window.MotionHasOptimisedAnimation = (elementId, valueName) => {\n            if (!elementId)\n                return false;\n            /**\n             * Keep a map of elementIds that have started animating. We check\n             * via ID instead of Element because of hydration errors and\n             * pre-hydration checks. We also actively record IDs as they start\n             * animating rather than simply checking for data-appear-id as\n             * this attrbute might be present but not lead to an animation, for\n             * instance if the element's appear animation is on a different\n             * breakpoint.\n             */\n            if (!valueName) {\n                return appearComplete.has(elementId);\n            }\n            const animationId = appearStoreId(elementId, valueName);\n            return Boolean(appearAnimationStore.get(animationId));\n        };\n        window.MotionHandoffMarkAsComplete = (elementId) => {\n            if (appearComplete.has(elementId)) {\n                appearComplete.set(elementId, true);\n            }\n        };\n        window.MotionHandoffIsComplete = (elementId) => {\n            return appearComplete.get(elementId) === true;\n        };\n        /**\n         * We only need to cancel transform animations as\n         * they're the ones that will interfere with the\n         * layout animation measurements.\n         */\n        window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\n            const animationId = appearStoreId(elementId, valueName);\n            const data = appearAnimationStore.get(animationId);\n            if (!data)\n                return;\n            if (frame && canResume === undefined) {\n                /**\n                 * Wait until the end of the subsequent frame to cancel the animation\n                 * to ensure we don't remove the animation before the main thread has\n                 * had a chance to resolve keyframes and render.\n                 */\n                frame.postRender(() => {\n                    frame.postRender(() => {\n                        data.animation.cancel();\n                    });\n                });\n            }\n            else {\n                data.animation.cancel();\n            }\n            if (frame && canResume) {\n                suspendedAnimations.add(data);\n                frame.render(resumeSuspendedAnimations);\n            }\n            else {\n                appearAnimationStore.delete(animationId);\n                /**\n                 * If there are no more animations left, we can remove the cancel function.\n                 * This will let us know when we can stop checking for conflicting layout animations.\n                 */\n                if (!appearAnimationStore.size) {\n                    window.MotionCancelOptimisedAnimation = undefined;\n                }\n            }\n        };\n        window.MotionCheckAppearSync = (visualElement, valueName, value) => {\n            var _a, _b;\n            const appearId = getOptimisedAppearId(visualElement);\n            if (!appearId)\n                return;\n            const valueIsOptimised = (_a = window.MotionHasOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n            const externalAnimationValue = (_b = visualElement.props.values) === null || _b === void 0 ? void 0 : _b[valueName];\n            if (!valueIsOptimised || !externalAnimationValue)\n                return;\n            const removeSyncCheck = value.on(\"change\", (latestValue) => {\n                var _a;\n                if (externalAnimationValue.get() !== latestValue) {\n                    (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n                    removeSyncCheck();\n                }\n            });\n            return removeSyncCheck;\n        };\n    }\n    const startAnimation = () => {\n        readyAnimation.cancel();\n        const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\n        /**\n         * Record the time of the first started animation. We call performance.now() once\n         * here and once in handoff to ensure we're getting\n         * close to a frame-locked time. This keeps all animations in sync.\n         */\n        if (startFrameTime === undefined) {\n            startFrameTime = performance.now();\n        }\n        appearAnimation.startTime = startFrameTime;\n        appearAnimationStore.set(storeId, {\n            animation: appearAnimation,\n            startTime: startFrameTime,\n        });\n        if (onReady)\n            onReady(appearAnimation);\n    };\n    appearComplete.set(id, false);\n    if (readyAnimation.ready) {\n        readyAnimation.ready.then(startAnimation).catch(noop);\n    }\n    else {\n        startAnimation();\n    }\n}\n\nexport { startOptimizedAppearAnimation };\n"]},"metadata":{},"sourceType":"module"}