{"ast":null,"code":"\"use client\"; // packages/react/presence/src/Presence.tsx\n\nimport * as React2 from \"react\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\"; // packages/react/presence/src/useStateMachine.tsx\n\nimport * as React from \"react\";\n\nfunction useStateMachine(initialState, machine) {\n  return React.useReducer((state, event) => {\n    const nextState = machine[state][event];\n    return nextState ?? state;\n  }, initialState);\n} // packages/react/presence/src/Presence.tsx\n\n\nvar Presence = props => {\n  const {\n    present,\n    children\n  } = props;\n  const presence = usePresence(present);\n  const child = typeof children === \"function\" ? children({\n    present: presence.isPresent\n  }) : React2.Children.only(children);\n  const ref = useComposedRefs(presence.ref, getElementRef(child));\n  const forceMount = typeof children === \"function\";\n  return forceMount || presence.isPresent ? React2.cloneElement(child, {\n    ref\n  }) : null;\n};\n\nPresence.displayName = \"Presence\";\n\nfunction usePresence(present) {\n  const [node, setNode] = React2.useState();\n  const stylesRef = React2.useRef({});\n  const prevPresentRef = React2.useRef(present);\n  const prevAnimationNameRef = React2.useRef(\"none\");\n  const initialState = present ? \"mounted\" : \"unmounted\";\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: \"unmounted\",\n      ANIMATION_OUT: \"unmountSuspended\"\n    },\n    unmountSuspended: {\n      MOUNT: \"mounted\",\n      ANIMATION_END: \"unmounted\"\n    },\n    unmounted: {\n      MOUNT: \"mounted\"\n    }\n  });\n  React2.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === \"mounted\" ? currentAnimationName : \"none\";\n  }, [state]);\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send(\"MOUNT\");\n      } else if (currentAnimationName === \"none\" || styles?.display === \"none\") {\n        send(\"UNMOUNT\");\n      } else {\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send(\"ANIMATION_OUT\");\n        } else {\n          send(\"UNMOUNT\");\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n  useLayoutEffect(() => {\n    if (node) {\n      let timeoutId;\n      const ownerWindow = node.ownerDocument.defaultView ?? window;\n\n      const handleAnimationEnd = event => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n\n        if (event.target === node && isCurrentAnimation) {\n          send(\"ANIMATION_END\");\n\n          if (!prevPresentRef.current) {\n            const currentFillMode = node.style.animationFillMode;\n            node.style.animationFillMode = \"forwards\";\n            timeoutId = ownerWindow.setTimeout(() => {\n              if (node.style.animationFillMode === \"forwards\") {\n                node.style.animationFillMode = currentFillMode;\n              }\n            });\n          }\n        }\n      };\n\n      const handleAnimationStart = event => {\n        if (event.target === node) {\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n\n      node.addEventListener(\"animationstart\", handleAnimationStart);\n      node.addEventListener(\"animationcancel\", handleAnimationEnd);\n      node.addEventListener(\"animationend\", handleAnimationEnd);\n      return () => {\n        ownerWindow.clearTimeout(timeoutId);\n        node.removeEventListener(\"animationstart\", handleAnimationStart);\n        node.removeEventListener(\"animationcancel\", handleAnimationEnd);\n        node.removeEventListener(\"animationend\", handleAnimationEnd);\n      };\n    } else {\n      send(\"ANIMATION_END\");\n    }\n  }, [node, send]);\n  return {\n    isPresent: [\"mounted\", \"unmountSuspended\"].includes(state),\n    ref: React2.useCallback(node2 => {\n      if (node2) stylesRef.current = getComputedStyle(node2);\n      setNode(node2);\n    }, [])\n  };\n}\n\nfunction getAnimationName(styles) {\n  return styles?.animationName || \"none\";\n}\n\nfunction getElementRef(element) {\n  let getter = Object.getOwnPropertyDescriptor(element.props, \"ref\")?.get;\n  let mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n\n  if (mayWarn) {\n    return element.ref;\n  }\n\n  getter = Object.getOwnPropertyDescriptor(element, \"ref\")?.get;\n  mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n\n  if (mayWarn) {\n    return element.props.ref;\n  }\n\n  return element.props.ref || element.ref;\n}\n\nexport { Presence };","map":{"version":3,"mappings":"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","names":["React","useComposedRefs","useLayoutEffect","useStateMachine","initialState","machine","state","event","nextState","Presence","props","present","children","presence","usePresence","child","isPresent","React2","only","ref","getElementRef","forceMount","displayName","node","setNode","stylesRef","prevPresentRef","prevAnimationNameRef","send","mounted","UNMOUNT","ANIMATION_OUT","unmountSuspended","MOUNT","ANIMATION_END","unmounted","currentAnimationName","getAnimationName","current","styles","wasPresent","hasPresentChanged","prevAnimationName","display","isAnimating","timeoutId","ownerWindow","ownerDocument","defaultView","window","handleAnimationEnd","isCurrentAnimation","includes","animationName","target","currentFillMode","style","animationFillMode","setTimeout","handleAnimationStart","addEventListener","clearTimeout","removeEventListener","getComputedStyle","element","getter","Object","getOwnPropertyDescriptor","get","mayWarn","isReactWarning"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-presence/src/Presence.tsx","/home/bahari/vl-web-fe/node_modules/@radix-ui/react-presence/src/useStateMachine.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './useStateMachine';\n\ninterface PresenceProps {\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n  present: boolean;\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement<{ ref?: React.Ref<HTMLElement> }>;\n\n  const ref = useComposedRefs(presence.ref, getElementRef(child));\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration>({} as any);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      let timeoutId: number;\n      const ownerWindow = node.ownerDocument.defaultView ?? window;\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          // With React 18 concurrency this update is applied a frame after the\n          // animation ends, creating a flash of visible content. By setting the\n          // animation fill mode to \"forwards\", we force the node to keep the\n          // styles of the last keyframe, removing the flash.\n          //\n          // Previously we flushed the update via ReactDom.flushSync, but with\n          // exit animations this resulted in the node being removed from the\n          // DOM before the synthetic animationEnd event was dispatched, meaning\n          // user-provided event handlers would not be called.\n          // https://github.com/radix-ui/primitives/pull/1849\n          send('ANIMATION_END');\n          if (!prevPresentRef.current) {\n            const currentFillMode = node.style.animationFillMode;\n            node.style.animationFillMode = 'forwards';\n            // Reset the style after the node had time to unmount (for cases\n            // where the component chooses not to unmount). Doing this any\n            // sooner than `setTimeout` (e.g. with `requestAnimationFrame`)\n            // still causes a flash.\n            timeoutId = ownerWindow.setTimeout(() => {\n              if (node.style.animationFillMode === 'forwards') {\n                node.style.animationFillMode = currentFillMode;\n              }\n            });\n          }\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        ownerWindow.clearTimeout(timeoutId);\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      if (node) stylesRef.current = getComputedStyle(node);\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles?: CSSStyleDeclaration) {\n  return styles?.animationName || 'none';\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement<{ ref?: React.Ref<unknown> }>) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n\n  // Not DEV\n  return element.props.ref || (element as any).ref;\n}\n\nexport { Presence };\nexport type { PresenceProps };\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// 🤯 https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n"]},"metadata":{},"sourceType":"module"}