{"ast":null,"code":"import _slicedToArray from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { isNone } from '../../animation/utils/is-none.mjs';\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\nimport { positionalKeys, isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\n\nvar DOMKeyframesResolver = /*#__PURE__*/function (_KeyframeResolver) {\n  _inherits(DOMKeyframesResolver, _KeyframeResolver);\n\n  var _super = _createSuper(DOMKeyframesResolver);\n\n  function DOMKeyframesResolver(unresolvedKeyframes, onComplete, name, motionValue, element) {\n    _classCallCheck(this, DOMKeyframesResolver);\n\n    return _super.call(this, unresolvedKeyframes, onComplete, name, motionValue, element, true);\n  }\n\n  _createClass(DOMKeyframesResolver, [{\n    key: \"readKeyframes\",\n    value: function readKeyframes() {\n      var unresolvedKeyframes = this.unresolvedKeyframes,\n          element = this.element,\n          name = this.name;\n      if (!element || !element.current) return;\n\n      _get(_getPrototypeOf(DOMKeyframesResolver.prototype), \"readKeyframes\", this).call(this);\n      /**\n       * If any keyframe is a CSS variable, we need to find its value by sampling the element\n       */\n\n\n      for (var i = 0; i < unresolvedKeyframes.length; i++) {\n        var keyframe = unresolvedKeyframes[i];\n\n        if (typeof keyframe === \"string\") {\n          keyframe = keyframe.trim();\n\n          if (isCSSVariableToken(keyframe)) {\n            var resolved = getVariableValue(keyframe, element.current);\n\n            if (resolved !== undefined) {\n              unresolvedKeyframes[i] = resolved;\n            }\n\n            if (i === unresolvedKeyframes.length - 1) {\n              this.finalKeyframe = keyframe;\n            }\n          }\n        }\n      }\n      /**\n       * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n       * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n       * have a far bigger performance impact.\n       */\n\n\n      this.resolveNoneKeyframes();\n      /**\n       * Check to see if unit type has changed. If so schedule jobs that will\n       * temporarily set styles to the destination keyframes.\n       * Skip if we have more than two keyframes or this isn't a positional value.\n       * TODO: We can throw if there are multiple keyframes and the value type changes.\n       */\n\n      if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n        return;\n      }\n\n      var _unresolvedKeyframes = _slicedToArray(unresolvedKeyframes, 2),\n          origin = _unresolvedKeyframes[0],\n          target = _unresolvedKeyframes[1];\n\n      var originType = findDimensionValueType(origin);\n      var targetType = findDimensionValueType(target);\n      /**\n       * Either we don't recognise these value types or we can animate between them.\n       */\n\n      if (originType === targetType) return;\n      /**\n       * If both values are numbers or pixels, we can animate between them by\n       * converting them to numbers.\n       */\n\n      if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n        for (var _i = 0; _i < unresolvedKeyframes.length; _i++) {\n          var value = unresolvedKeyframes[_i];\n\n          if (typeof value === \"string\") {\n            unresolvedKeyframes[_i] = parseFloat(value);\n          }\n        }\n      } else {\n        /**\n         * Else, the only way to resolve this is by measuring the element.\n         */\n        this.needsMeasurement = true;\n      }\n    }\n  }, {\n    key: \"resolveNoneKeyframes\",\n    value: function resolveNoneKeyframes() {\n      var unresolvedKeyframes = this.unresolvedKeyframes,\n          name = this.name;\n      var noneKeyframeIndexes = [];\n\n      for (var i = 0; i < unresolvedKeyframes.length; i++) {\n        if (isNone(unresolvedKeyframes[i])) {\n          noneKeyframeIndexes.push(i);\n        }\n      }\n\n      if (noneKeyframeIndexes.length) {\n        makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n      }\n    }\n  }, {\n    key: \"measureInitialState\",\n    value: function measureInitialState() {\n      var element = this.element,\n          unresolvedKeyframes = this.unresolvedKeyframes,\n          name = this.name;\n      if (!element || !element.current) return;\n\n      if (name === \"height\") {\n        this.suspendedScrollY = window.pageYOffset;\n      }\n\n      this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n      unresolvedKeyframes[0] = this.measuredOrigin; // Set final key frame to measure after next render\n\n      var measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n\n      if (measureKeyframe !== undefined) {\n        element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n      }\n    }\n  }, {\n    key: \"measureEndState\",\n    value: function measureEndState() {\n      var _a;\n\n      var element = this.element,\n          name = this.name,\n          unresolvedKeyframes = this.unresolvedKeyframes;\n      if (!element || !element.current) return;\n      var value = element.getValue(name);\n      value && value.jump(this.measuredOrigin, false);\n      var finalKeyframeIndex = unresolvedKeyframes.length - 1;\n      var finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n      unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n\n      if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n        this.finalKeyframe = finalKeyframe;\n      } // If we removed transform values, reapply them before the next render\n\n\n      if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n        this.removedTransforms.forEach(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 2),\n              unsetTransformName = _ref2[0],\n              unsetTransformValue = _ref2[1];\n\n          element.getValue(unsetTransformName).set(unsetTransformValue);\n        });\n      }\n\n      this.resolveNoneKeyframes();\n    }\n  }]);\n\n  return DOMKeyframesResolver;\n}(KeyframeResolver);\n\nexport { DOMKeyframesResolver };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs"],"names":["isNone","getVariableValue","isCSSVariableToken","positionalKeys","isNumOrPxType","positionalValues","findDimensionValueType","KeyframeResolver","makeNoneKeyframesAnimatable","DOMKeyframesResolver","unresolvedKeyframes","onComplete","name","motionValue","element","current","i","length","keyframe","trim","resolved","undefined","finalKeyframe","resolveNoneKeyframes","has","origin","target","originType","targetType","value","parseFloat","needsMeasurement","noneKeyframeIndexes","push","suspendedScrollY","window","pageYOffset","measuredOrigin","measureViewportBox","getComputedStyle","measureKeyframe","getValue","jump","_a","finalKeyframeIndex","removedTransforms","forEach","unsetTransformName","unsetTransformValue","set"],"mappings":"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","sourcesContent":["import { isNone } from '../../animation/utils/is-none.mjs';\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\nimport { positionalKeys, isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n    }\n    readKeyframes() {\n        const { unresolvedKeyframes, element, name } = this;\n        if (!element || !element.current)\n            return;\n        super.readKeyframes();\n        /**\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\n         */\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            let keyframe = unresolvedKeyframes[i];\n            if (typeof keyframe === \"string\") {\n                keyframe = keyframe.trim();\n                if (isCSSVariableToken(keyframe)) {\n                    const resolved = getVariableValue(keyframe, element.current);\n                    if (resolved !== undefined) {\n                        unresolvedKeyframes[i] = resolved;\n                    }\n                    if (i === unresolvedKeyframes.length - 1) {\n                        this.finalKeyframe = keyframe;\n                    }\n                }\n            }\n        }\n        /**\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\n         * have a far bigger performance impact.\n         */\n        this.resolveNoneKeyframes();\n        /**\n         * Check to see if unit type has changed. If so schedule jobs that will\n         * temporarily set styles to the destination keyframes.\n         * Skip if we have more than two keyframes or this isn't a positional value.\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\n         */\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n            return;\n        }\n        const [origin, target] = unresolvedKeyframes;\n        const originType = findDimensionValueType(origin);\n        const targetType = findDimensionValueType(target);\n        /**\n         * Either we don't recognise these value types or we can animate between them.\n         */\n        if (originType === targetType)\n            return;\n        /**\n         * If both values are numbers or pixels, we can animate between them by\n         * converting them to numbers.\n         */\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\n                const value = unresolvedKeyframes[i];\n                if (typeof value === \"string\") {\n                    unresolvedKeyframes[i] = parseFloat(value);\n                }\n            }\n        }\n        else {\n            /**\n             * Else, the only way to resolve this is by measuring the element.\n             */\n            this.needsMeasurement = true;\n        }\n    }\n    resolveNoneKeyframes() {\n        const { unresolvedKeyframes, name } = this;\n        const noneKeyframeIndexes = [];\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\n            if (isNone(unresolvedKeyframes[i])) {\n                noneKeyframeIndexes.push(i);\n            }\n        }\n        if (noneKeyframeIndexes.length) {\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n        }\n    }\n    measureInitialState() {\n        const { element, unresolvedKeyframes, name } = this;\n        if (!element || !element.current)\n            return;\n        if (name === \"height\") {\n            this.suspendedScrollY = window.pageYOffset;\n        }\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        unresolvedKeyframes[0] = this.measuredOrigin;\n        // Set final key frame to measure after next render\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n        if (measureKeyframe !== undefined) {\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n        }\n    }\n    measureEndState() {\n        var _a;\n        const { element, name, unresolvedKeyframes } = this;\n        if (!element || !element.current)\n            return;\n        const value = element.getValue(name);\n        value && value.jump(this.measuredOrigin, false);\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n            this.finalKeyframe = finalKeyframe;\n        }\n        // If we removed transform values, reapply them before the next render\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\n                element\n                    .getValue(unsetTransformName)\n                    .set(unsetTransformValue);\n            });\n        }\n        this.resolveNoneKeyframes();\n    }\n}\n\nexport { DOMKeyframesResolver };\n"]},"metadata":{},"sourceType":"module"}