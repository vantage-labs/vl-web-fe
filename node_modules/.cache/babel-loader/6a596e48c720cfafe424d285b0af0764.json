{"ast":null,"code":"import _objectSpread from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { mixNumber as mixNumber$1 } from './number.mjs';\nimport { mixColor } from './color.mjs';\nimport { pipe } from '../pipe.mjs';\nimport { warning } from 'motion-utils';\nimport { color } from '../../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\nimport { isCSSVariableToken } from '../../render/dom/utils/is-css-variable.mjs';\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\nimport { mixImmediate } from './immediate.mjs';\n\nfunction mixNumber(a, b) {\n  return function (p) {\n    return mixNumber$1(a, b, p);\n  };\n}\n\nfunction getMixer(a) {\n  if (typeof a === \"number\") {\n    return mixNumber;\n  } else if (typeof a === \"string\") {\n    return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;\n  } else if (Array.isArray(a)) {\n    return mixArray;\n  } else if (typeof a === \"object\") {\n    return color.test(a) ? mixColor : mixObject;\n  }\n\n  return mixImmediate;\n}\n\nfunction mixArray(a, b) {\n  var output = _toConsumableArray(a);\n\n  var numValues = output.length;\n  var blendValue = a.map(function (v, i) {\n    return getMixer(v)(v, b[i]);\n  });\n  return function (p) {\n    for (var i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](p);\n    }\n\n    return output;\n  };\n}\n\nfunction mixObject(a, b) {\n  var output = _objectSpread(_objectSpread({}, a), b);\n\n  var blendValue = {};\n\n  for (var key in output) {\n    if (a[key] !== undefined && b[key] !== undefined) {\n      blendValue[key] = getMixer(a[key])(a[key], b[key]);\n    }\n  }\n\n  return function (v) {\n    for (var _key in blendValue) {\n      output[_key] = blendValue[_key](v);\n    }\n\n    return output;\n  };\n}\n\nfunction matchOrder(origin, target) {\n  var _a;\n\n  var orderedOrigin = [];\n  var pointers = {\n    color: 0,\n    var: 0,\n    number: 0\n  };\n\n  for (var i = 0; i < target.values.length; i++) {\n    var type = target.types[i];\n    var originIndex = origin.indexes[type][pointers[type]];\n    var originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;\n    orderedOrigin[i] = originValue;\n    pointers[type]++;\n  }\n\n  return orderedOrigin;\n}\n\nvar mixComplex = function mixComplex(origin, target) {\n  var template = complex.createTransformer(target);\n  var originStats = analyseComplexValue(origin);\n  var targetStats = analyseComplexValue(target);\n  var canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;\n\n  if (canInterpolate) {\n    if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {\n      return mixVisibility(origin, target);\n    }\n\n    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n  } else {\n    warning(true, \"Complex values '\".concat(origin, \"' and '\").concat(target, \"' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.\"));\n    return mixImmediate(origin, target);\n  }\n};\n\nexport { getMixer, mixArray, mixComplex, mixObject };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/utils/mix/complex.mjs"],"names":["mixNumber","mixNumber$1","mixColor","pipe","warning","color","complex","analyseComplexValue","isCSSVariableToken","invisibleValues","mixVisibility","mixImmediate","a","b","p","getMixer","test","mixComplex","Array","isArray","mixArray","mixObject","output","numValues","length","blendValue","map","v","i","key","undefined","matchOrder","origin","target","_a","orderedOrigin","pointers","var","number","values","type","types","originIndex","indexes","originValue","template","createTransformer","originStats","targetStats","canInterpolate","has"],"mappings":"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","sourcesContent":["import { mixNumber as mixNumber$1 } from './number.mjs';\nimport { mixColor } from './color.mjs';\nimport { pipe } from '../pipe.mjs';\nimport { warning } from 'motion-utils';\nimport { color } from '../../value/types/color/index.mjs';\nimport { complex, analyseComplexValue } from '../../value/types/complex/index.mjs';\nimport { isCSSVariableToken } from '../../render/dom/utils/is-css-variable.mjs';\nimport { invisibleValues, mixVisibility } from './visibility.mjs';\nimport { mixImmediate } from './immediate.mjs';\n\nfunction mixNumber(a, b) {\n    return (p) => mixNumber$1(a, b, p);\n}\nfunction getMixer(a) {\n    if (typeof a === \"number\") {\n        return mixNumber;\n    }\n    else if (typeof a === \"string\") {\n        return isCSSVariableToken(a)\n            ? mixImmediate\n            : color.test(a)\n                ? mixColor\n                : mixComplex;\n    }\n    else if (Array.isArray(a)) {\n        return mixArray;\n    }\n    else if (typeof a === \"object\") {\n        return color.test(a) ? mixColor : mixObject;\n    }\n    return mixImmediate;\n}\nfunction mixArray(a, b) {\n    const output = [...a];\n    const numValues = output.length;\n    const blendValue = a.map((v, i) => getMixer(v)(v, b[i]));\n    return (p) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](p);\n        }\n        return output;\n    };\n}\nfunction mixObject(a, b) {\n    const output = { ...a, ...b };\n    const blendValue = {};\n    for (const key in output) {\n        if (a[key] !== undefined && b[key] !== undefined) {\n            blendValue[key] = getMixer(a[key])(a[key], b[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n}\nfunction matchOrder(origin, target) {\n    var _a;\n    const orderedOrigin = [];\n    const pointers = { color: 0, var: 0, number: 0 };\n    for (let i = 0; i < target.values.length; i++) {\n        const type = target.types[i];\n        const originIndex = origin.indexes[type][pointers[type]];\n        const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;\n        orderedOrigin[i] = originValue;\n        pointers[type]++;\n    }\n    return orderedOrigin;\n}\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = analyseComplexValue(origin);\n    const targetStats = analyseComplexValue(target);\n    const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length &&\n        originStats.indexes.color.length === targetStats.indexes.color.length &&\n        originStats.indexes.number.length >= targetStats.indexes.number.length;\n    if (canInterpolate) {\n        if ((invisibleValues.has(origin) &&\n            !targetStats.values.length) ||\n            (invisibleValues.has(target) &&\n                !originStats.values.length)) {\n            return mixVisibility(origin, target);\n        }\n        return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);\n    }\n    else {\n        warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return mixImmediate(origin, target);\n    }\n};\n\nexport { getMixer, mixArray, mixComplex, mixObject };\n"]},"metadata":{},"sourceType":"module"}