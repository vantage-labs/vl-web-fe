{"ast":null,"code":"import _objectWithoutProperties from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _classCallCheck from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _objectSpread from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"onComplete\", \"onUpdate\", \"motionValue\", \"element\"],\n    _excluded2 = [\"motionValue\", \"onUpdate\", \"onComplete\", \"element\"];\nimport { supportsLinearEasing, attachTimeline as _attachTimeline, isGenerator, isWaapiSupportedEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { anticipate } from '../../easing/anticipate.mjs';\nimport { backInOut } from '../../easing/back.mjs';\nimport { circInOut } from '../../easing/circ.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\nimport { startWaapiAnimation } from './waapi/index.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nimport { supportsWaapi } from './waapi/utils/supports-waapi.mjs';\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\n\nvar sampleDelta = 10; //ms\n\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\n\nvar maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\n\nfunction requiresPregeneratedKeyframes(options) {\n  return isGenerator(options.type) || options.type === \"spring\" || !isWaapiSupportedEasing(options.ease);\n}\n\nfunction pregenerateKeyframes(keyframes, options) {\n  /**\n   * Create a main-thread animation to pregenerate keyframes.\n   * We sample this at regular intervals to generate keyframes that we then\n   * linearly interpolate between.\n   */\n  var sampleAnimation = new MainThreadAnimation(_objectSpread(_objectSpread({}, options), {}, {\n    keyframes: keyframes,\n    repeat: 0,\n    delay: 0,\n    isGenerator: true\n  }));\n  var state = {\n    done: false,\n    value: keyframes[0]\n  };\n  var pregeneratedKeyframes = [];\n  /**\n   * Bail after 20 seconds of pre-generated keyframes as it's likely\n   * we're heading for an infinite loop.\n   */\n\n  var t = 0;\n\n  while (!state.done && t < maxDuration) {\n    state = sampleAnimation.sample(t);\n    pregeneratedKeyframes.push(state.value);\n    t += sampleDelta;\n  }\n\n  return {\n    times: undefined,\n    keyframes: pregeneratedKeyframes,\n    duration: t - sampleDelta,\n    ease: \"linear\"\n  };\n}\n\nvar unsupportedEasingFunctions = {\n  anticipate: anticipate,\n  backInOut: backInOut,\n  circInOut: circInOut\n};\n\nfunction isUnsupportedEase(key) {\n  return key in unsupportedEasingFunctions;\n}\n\nvar AcceleratedAnimation = /*#__PURE__*/function (_BaseAnimation) {\n  _inherits(AcceleratedAnimation, _BaseAnimation);\n\n  var _super = _createSuper(AcceleratedAnimation);\n\n  function AcceleratedAnimation(options) {\n    var _this;\n\n    _classCallCheck(this, AcceleratedAnimation);\n\n    _this = _super.call(this, options);\n    var _this$options = _this.options,\n        name = _this$options.name,\n        motionValue = _this$options.motionValue,\n        element = _this$options.element,\n        keyframes = _this$options.keyframes;\n    _this.resolver = new DOMKeyframesResolver(keyframes, function (resolvedKeyframes, finalKeyframe) {\n      return _this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n    }, name, motionValue, element);\n\n    _this.resolver.scheduleResolve();\n\n    return _this;\n  }\n\n  _createClass(AcceleratedAnimation, [{\n    key: \"initPlayback\",\n    value: function initPlayback(keyframes, finalKeyframe) {\n      var _this2 = this;\n\n      var _a;\n\n      var _this$options2 = this.options,\n          _this$options2$durati = _this$options2.duration,\n          duration = _this$options2$durati === void 0 ? 300 : _this$options2$durati,\n          times = _this$options2.times,\n          ease = _this$options2.ease,\n          type = _this$options2.type,\n          motionValue = _this$options2.motionValue,\n          name = _this$options2.name,\n          startTime = _this$options2.startTime;\n      /**\n       * If element has since been unmounted, return false to indicate\n       * the animation failed to initialised.\n       */\n\n      if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n        return false;\n      }\n      /**\n       * If the user has provided an easing function name that isn't supported\n       * by WAAPI (like \"anticipate\"), we need to provide the corressponding\n       * function. This will later get converted to a linear() easing function.\n       */\n\n\n      if (typeof ease === \"string\" && supportsLinearEasing() && isUnsupportedEase(ease)) {\n        ease = unsupportedEasingFunctions[ease];\n      }\n      /**\n       * If this animation needs pre-generated keyframes then generate.\n       */\n\n\n      if (requiresPregeneratedKeyframes(this.options)) {\n        var _this$options3 = this.options,\n            onComplete = _this$options3.onComplete,\n            onUpdate = _this$options3.onUpdate,\n            _motionValue = _this$options3.motionValue,\n            element = _this$options3.element,\n            options = _objectWithoutProperties(_this$options3, _excluded);\n\n        var pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n        keyframes = pregeneratedAnimation.keyframes; // If this is a very short animation, ensure we have\n        // at least two keyframes to animate between as older browsers\n        // can't animate between a single keyframe.\n\n        if (keyframes.length === 1) {\n          keyframes[1] = keyframes[0];\n        }\n\n        duration = pregeneratedAnimation.duration;\n        times = pregeneratedAnimation.times;\n        ease = pregeneratedAnimation.ease;\n        type = \"keyframes\";\n      }\n\n      var animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, _objectSpread(_objectSpread({}, this.options), {}, {\n        duration: duration,\n        times: times,\n        ease: ease\n      })); // Override the browser calculated startTime with one synchronised to other JS\n      // and WAAPI animations starting this event loop.\n\n      animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n\n      if (this.pendingTimeline) {\n        _attachTimeline(animation, this.pendingTimeline);\n\n        this.pendingTimeline = undefined;\n      } else {\n        /**\n         * Prefer the `onfinish` prop as it's more widely supported than\n         * the `finished` promise.\n         *\n         * Here, we synchronously set the provided MotionValue to the end\n         * keyframe. If we didn't, when the WAAPI animation is finished it would\n         * be removed from the element which would then revert to its old styles.\n         */\n        animation.onfinish = function () {\n          var onComplete = _this2.options.onComplete;\n          motionValue.set(getFinalKeyframe(keyframes, _this2.options, finalKeyframe));\n          onComplete && onComplete();\n\n          _this2.cancel();\n\n          _this2.resolveFinishedPromise();\n        };\n      }\n\n      return {\n        animation: animation,\n        duration: duration,\n        times: times,\n        type: type,\n        ease: ease,\n        keyframes: keyframes\n      };\n    }\n  }, {\n    key: \"duration\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 0;\n      var duration = resolved.duration;\n      return millisecondsToSeconds(duration);\n    }\n  }, {\n    key: \"time\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 0;\n      var animation = resolved.animation;\n      return millisecondsToSeconds(animation.currentTime || 0);\n    },\n    set: function set(newTime) {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.currentTime = secondsToMilliseconds(newTime);\n    }\n  }, {\n    key: \"speed\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return 1;\n      var animation = resolved.animation;\n      return animation.playbackRate;\n    },\n    set: function set(newSpeed) {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.playbackRate = newSpeed;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return \"idle\";\n      var animation = resolved.animation;\n      return animation.playState;\n    }\n  }, {\n    key: \"startTime\",\n    get: function get() {\n      var resolved = this.resolved;\n      if (!resolved) return null;\n      var animation = resolved.animation; // Coerce to number as TypeScript incorrectly types this\n      // as CSSNumberish\n\n      return animation.startTime;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n\n  }, {\n    key: \"attachTimeline\",\n    value: function attachTimeline(timeline) {\n      if (!this._resolved) {\n        this.pendingTimeline = timeline;\n      } else {\n        var resolved = this.resolved;\n        if (!resolved) return noop;\n        var animation = resolved.animation;\n\n        _attachTimeline(animation, timeline);\n      }\n\n      return noop;\n    }\n  }, {\n    key: \"play\",\n    value: function play() {\n      if (this.isStopped) return;\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n\n      if (animation.playState === \"finished\") {\n        this.updateFinishedPromise();\n      }\n\n      animation.play();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation;\n      animation.pause();\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.resolver.cancel();\n      this.isStopped = true;\n      if (this.state === \"idle\") return;\n      this.resolveFinishedPromise();\n      this.updateFinishedPromise();\n      var resolved = this.resolved;\n      if (!resolved) return;\n      var animation = resolved.animation,\n          keyframes = resolved.keyframes,\n          duration = resolved.duration,\n          type = resolved.type,\n          ease = resolved.ease,\n          times = resolved.times;\n\n      if (animation.playState === \"idle\" || animation.playState === \"finished\") {\n        return;\n      }\n      /**\n       * WAAPI doesn't natively have any interruption capabilities.\n       *\n       * Rather than read commited styles back out of the DOM, we can\n       * create a renderless JS animation and sample it twice to calculate\n       * its current value, \"previous\" value, and therefore allow\n       * Motion to calculate velocity for any subsequent animation.\n       */\n\n\n      if (this.time) {\n        var _this$options4 = this.options,\n            motionValue = _this$options4.motionValue,\n            onUpdate = _this$options4.onUpdate,\n            onComplete = _this$options4.onComplete,\n            element = _this$options4.element,\n            options = _objectWithoutProperties(_this$options4, _excluded2);\n\n        var sampleAnimation = new MainThreadAnimation(_objectSpread(_objectSpread({}, options), {}, {\n          keyframes: keyframes,\n          duration: duration,\n          type: type,\n          ease: ease,\n          times: times,\n          isGenerator: true\n        }));\n        var sampleTime = secondsToMilliseconds(this.time);\n        motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n      }\n\n      var onStop = this.options.onStop;\n      onStop && onStop();\n      this.cancel();\n    }\n  }, {\n    key: \"complete\",\n    value: function complete() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      resolved.animation.finish();\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var resolved = this.resolved;\n      if (!resolved) return;\n      resolved.animation.cancel();\n    }\n  }], [{\n    key: \"supports\",\n    value: function supports(options) {\n      var motionValue = options.motionValue,\n          name = options.name,\n          repeatDelay = options.repeatDelay,\n          repeatType = options.repeatType,\n          damping = options.damping,\n          type = options.type;\n      return supportsWaapi() && name && acceleratedValues.has(name) && motionValue && motionValue.owner && motionValue.owner.current instanceof HTMLElement &&\n      /**\n       * If we're outputting values to onUpdate then we can't use WAAPI as there's\n       * no way to read the value from WAAPI every frame.\n       */\n      !motionValue.owner.getProps().onUpdate && !repeatDelay && repeatType !== \"mirror\" && damping !== 0 && type !== \"inertia\";\n    }\n  }]);\n\n  return AcceleratedAnimation;\n}(BaseAnimation);\n\nexport { AcceleratedAnimation };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs"],"names":["supportsLinearEasing","attachTimeline","isGenerator","isWaapiSupportedEasing","millisecondsToSeconds","secondsToMilliseconds","noop","anticipate","backInOut","circInOut","DOMKeyframesResolver","BaseAnimation","MainThreadAnimation","acceleratedValues","startWaapiAnimation","getFinalKeyframe","supportsWaapi","sampleDelta","maxDuration","requiresPregeneratedKeyframes","options","type","ease","pregenerateKeyframes","keyframes","sampleAnimation","repeat","delay","state","done","value","pregeneratedKeyframes","t","sample","push","times","undefined","duration","unsupportedEasingFunctions","isUnsupportedEase","key","AcceleratedAnimation","name","motionValue","element","resolver","resolvedKeyframes","finalKeyframe","onKeyframesResolved","scheduleResolve","_a","startTime","owner","current","onComplete","onUpdate","pregeneratedAnimation","length","animation","calcStartTime","pendingTimeline","onfinish","set","cancel","resolveFinishedPromise","resolved","currentTime","newTime","playbackRate","newSpeed","playState","timeline","_resolved","isStopped","updateFinishedPromise","play","pause","time","sampleTime","setWithVelocity","onStop","finish","repeatDelay","repeatType","damping","has","HTMLElement","getProps"],"mappings":"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","sourcesContent":["import { supportsLinearEasing, attachTimeline, isGenerator, isWaapiSupportedEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds, noop } from 'motion-utils';\nimport { anticipate } from '../../easing/anticipate.mjs';\nimport { backInOut } from '../../easing/back.mjs';\nimport { circInOut } from '../../easing/circ.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\nimport { startWaapiAnimation } from './waapi/index.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nimport { supportsWaapi } from './waapi/utils/supports-waapi.mjs';\n\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n    return (isGenerator(options.type) ||\n        options.type === \"spring\" ||\n        !isWaapiSupportedEasing(options.ease));\n}\nfunction pregenerateKeyframes(keyframes, options) {\n    /**\n     * Create a main-thread animation to pregenerate keyframes.\n     * We sample this at regular intervals to generate keyframes that we then\n     * linearly interpolate between.\n     */\n    const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes,\n        repeat: 0,\n        delay: 0,\n        isGenerator: true,\n    });\n    let state = { done: false, value: keyframes[0] };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n        state = sampleAnimation.sample(t);\n        pregeneratedKeyframes.push(state.value);\n        t += sampleDelta;\n    }\n    return {\n        times: undefined,\n        keyframes: pregeneratedKeyframes,\n        duration: t - sampleDelta,\n        ease: \"linear\",\n    };\n}\nconst unsupportedEasingFunctions = {\n    anticipate,\n    backInOut,\n    circInOut,\n};\nfunction isUnsupportedEase(key) {\n    return key in unsupportedEasingFunctions;\n}\nclass AcceleratedAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        const { name, motionValue, element, keyframes } = this.options;\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes, finalKeyframe) {\n        var _a;\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\n        /**\n         * If element has since been unmounted, return false to indicate\n         * the animation failed to initialised.\n         */\n        if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n            return false;\n        }\n        /**\n         * If the user has provided an easing function name that isn't supported\n         * by WAAPI (like \"anticipate\"), we need to provide the corressponding\n         * function. This will later get converted to a linear() easing function.\n         */\n        if (typeof ease === \"string\" &&\n            supportsLinearEasing() &&\n            isUnsupportedEase(ease)) {\n            ease = unsupportedEasingFunctions[ease];\n        }\n        /**\n         * If this animation needs pre-generated keyframes then generate.\n         */\n        if (requiresPregeneratedKeyframes(this.options)) {\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n            keyframes = pregeneratedAnimation.keyframes;\n            // If this is a very short animation, ensure we have\n            // at least two keyframes to animate between as older browsers\n            // can't animate between a single keyframe.\n            if (keyframes.length === 1) {\n                keyframes[1] = keyframes[0];\n            }\n            duration = pregeneratedAnimation.duration;\n            times = pregeneratedAnimation.times;\n            ease = pregeneratedAnimation.ease;\n            type = \"keyframes\";\n        }\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\n        // Override the browser calculated startTime with one synchronised to other JS\n        // and WAAPI animations starting this event loop.\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        if (this.pendingTimeline) {\n            attachTimeline(animation, this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        else {\n            /**\n             * Prefer the `onfinish` prop as it's more widely supported than\n             * the `finished` promise.\n             *\n             * Here, we synchronously set the provided MotionValue to the end\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\n             * be removed from the element which would then revert to its old styles.\n             */\n            animation.onfinish = () => {\n                const { onComplete } = this.options;\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.cancel();\n                this.resolveFinishedPromise();\n            };\n        }\n        return {\n            animation,\n            duration,\n            times,\n            type,\n            ease,\n            keyframes: keyframes,\n        };\n    }\n    get duration() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { duration } = resolved;\n        return millisecondsToSeconds(duration);\n    }\n    get time() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { animation } = resolved;\n        return millisecondsToSeconds(animation.currentTime || 0);\n    }\n    set time(newTime) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    get speed() {\n        const { resolved } = this;\n        if (!resolved)\n            return 1;\n        const { animation } = resolved;\n        return animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.playbackRate = newSpeed;\n    }\n    get state() {\n        const { resolved } = this;\n        if (!resolved)\n            return \"idle\";\n        const { animation } = resolved;\n        return animation.playState;\n    }\n    get startTime() {\n        const { resolved } = this;\n        if (!resolved)\n            return null;\n        const { animation } = resolved;\n        // Coerce to number as TypeScript incorrectly types this\n        // as CSSNumberish\n        return animation.startTime;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n    attachTimeline(timeline) {\n        if (!this._resolved) {\n            this.pendingTimeline = timeline;\n        }\n        else {\n            const { resolved } = this;\n            if (!resolved)\n                return noop;\n            const { animation } = resolved;\n            attachTimeline(animation, timeline);\n        }\n        return noop;\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        if (animation.playState === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        animation.play();\n    }\n    pause() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.pause();\n    }\n    stop() {\n        this.resolver.cancel();\n        this.isStopped = true;\n        if (this.state === \"idle\")\n            return;\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation, keyframes, duration, type, ease, times } = resolved;\n        if (animation.playState === \"idle\" ||\n            animation.playState === \"finished\") {\n            return;\n        }\n        /**\n         * WAAPI doesn't natively have any interruption capabilities.\n         *\n         * Rather than read commited styles back out of the DOM, we can\n         * create a renderless JS animation and sample it twice to calculate\n         * its current value, \"previous\" value, and therefore allow\n         * Motion to calculate velocity for any subsequent animation.\n         */\n        if (this.time) {\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\n            const sampleAnimation = new MainThreadAnimation({\n                ...options,\n                keyframes,\n                duration,\n                type,\n                ease,\n                times,\n                isGenerator: true,\n            });\n            const sampleTime = secondsToMilliseconds(this.time);\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        }\n        const { onStop } = this.options;\n        onStop && onStop();\n        this.cancel();\n    }\n    complete() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.finish();\n    }\n    cancel() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.cancel();\n    }\n    static supports(options) {\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n        return (supportsWaapi() &&\n            name &&\n            acceleratedValues.has(name) &&\n            motionValue &&\n            motionValue.owner &&\n            motionValue.owner.current instanceof HTMLElement &&\n            /**\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\n             * no way to read the value from WAAPI every frame.\n             */\n            !motionValue.owner.getProps().onUpdate &&\n            !repeatDelay &&\n            repeatType !== \"mirror\" &&\n            damping !== 0 &&\n            type !== \"inertia\");\n    }\n}\n\nexport { AcceleratedAnimation };\n"]},"metadata":{},"sourceType":"module"}