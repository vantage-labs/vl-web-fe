{"ast":null,"code":"import _objectSpread from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\n\nfunction animateVariant(visualElement, variant) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  var resolved = resolveVariant(visualElement, variant, options.type === \"exit\" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : undefined);\n\n  var _ref = resolved || {},\n      _ref$transition = _ref.transition,\n      transition = _ref$transition === void 0 ? visualElement.getDefaultTransition() || {} : _ref$transition;\n\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n\n\n  var getAnimation = resolved ? function () {\n    return Promise.all(animateTarget(visualElement, resolved, options));\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n\n  var getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? function () {\n    var forwardDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var _transition = transition,\n        _transition$delayChil = _transition.delayChildren,\n        delayChildren = _transition$delayChil === void 0 ? 0 : _transition$delayChil,\n        staggerChildren = _transition.staggerChildren,\n        staggerDirection = _transition.staggerDirection;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n\n  var _transition2 = transition,\n      when = _transition2.when;\n\n  if (when) {\n    var _ref2 = when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation],\n        _ref3 = _slicedToArray(_ref2, 2),\n        first = _ref3[0],\n        last = _ref3[1];\n\n    return first().then(function () {\n      return last();\n    });\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\n\nfunction animateChildren(visualElement, variant) {\n  var delayChildren = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var staggerChildren = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var staggerDirection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var options = arguments.length > 5 ? arguments[5] : undefined;\n  var animations = [];\n  var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  var generateStaggerDuration = staggerDirection === 1 ? function () {\n    var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return i * staggerChildren;\n  } : function () {\n    var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return maxStaggerDuration - i * staggerChildren;\n  };\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function (child, i) {\n    child.notify(\"AnimationStart\", variant);\n    animations.push(animateVariant(child, variant, _objectSpread(_objectSpread({}, options), {}, {\n      delay: delayChildren + generateStaggerDuration(i)\n    })).then(function () {\n      return child.notify(\"AnimationComplete\", variant);\n    }));\n  });\n  return Promise.all(animations);\n}\n\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}\n\nexport { animateVariant, sortByTreeOrder };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs"],"names":["resolveVariant","animateTarget","animateVariant","visualElement","variant","options","_a","resolved","type","presenceContext","custom","undefined","transition","getDefaultTransition","transitionOverride","getAnimation","Promise","all","resolve","getChildAnimations","variantChildren","size","forwardDelay","delayChildren","staggerChildren","staggerDirection","animateChildren","when","first","last","then","delay","animations","maxStaggerDuration","generateStaggerDuration","i","Array","from","sort","sortByTreeOrder","forEach","child","notify","push","a","b","sortNodePosition"],"mappings":";;AAAA,SAASA,cAAT,QAA+B,iDAA/B;AACA,SAASC,aAAT,QAA8B,6BAA9B;;AAEA,SAASC,cAAT,CAAwBC,aAAxB,EAAuCC,OAAvC,EAA8D;AAAA,MAAdC,OAAc,uEAAJ,EAAI;;AAC1D,MAAIC,EAAJ;;AACA,MAAMC,QAAQ,GAAGP,cAAc,CAACG,aAAD,EAAgBC,OAAhB,EAAyBC,OAAO,CAACG,IAAR,KAAiB,MAAjB,GAClD,CAACF,EAAE,GAAGH,aAAa,CAACM,eAApB,MAAyC,IAAzC,IAAiDH,EAAE,KAAK,KAAK,CAA7D,GAAiE,KAAK,CAAtE,GAA0EA,EAAE,CAACI,MAD3B,GAElDC,SAFyB,CAA/B;;AAGA,aAAkEJ,QAAQ,IAAI,EAA9E;AAAA,6BAAMK,UAAN;AAAA,MAAMA,UAAN,gCAAmBT,aAAa,CAACU,oBAAd,MAAwC,EAA3D;;AACA,MAAIR,OAAO,CAACS,kBAAZ,EAAgC;AAC5BF,IAAAA,UAAU,GAAGP,OAAO,CAACS,kBAArB;AACH;AACD;AACJ;AACA;AACA;;;AACI,MAAMC,YAAY,GAAGR,QAAQ,GACvB;AAAA,WAAMS,OAAO,CAACC,GAAR,CAAYhB,aAAa,CAACE,aAAD,EAAgBI,QAAhB,EAA0BF,OAA1B,CAAzB,CAAN;AAAA,GADuB,GAEvB;AAAA,WAAMW,OAAO,CAACE,OAAR,EAAN;AAAA,GAFN;AAGA;AACJ;AACA;AACA;;AACI,MAAMC,kBAAkB,GAAGhB,aAAa,CAACiB,eAAd,IAAiCjB,aAAa,CAACiB,eAAd,CAA8BC,IAA/D,GACrB,YAAsB;AAAA,QAArBC,YAAqB,uEAAN,CAAM;AACpB,sBAAkEV,UAAlE;AAAA,4CAAQW,aAAR;AAAA,QAAQA,aAAR,sCAAwB,CAAxB;AAAA,QAA2BC,eAA3B,eAA2BA,eAA3B;AAAA,QAA4CC,gBAA5C,eAA4CA,gBAA5C;AACA,WAAOC,eAAe,CAACvB,aAAD,EAAgBC,OAAhB,EAAyBmB,aAAa,GAAGD,YAAzC,EAAuDE,eAAvD,EAAwEC,gBAAxE,EAA0FpB,OAA1F,CAAtB;AACH,GAJsB,GAKrB;AAAA,WAAMW,OAAO,CAACE,OAAR,EAAN;AAAA,GALN;AAMA;AACJ;AACA;AACA;;AACI,qBAAiBN,UAAjB;AAAA,MAAQe,IAAR,gBAAQA,IAAR;;AACA,MAAIA,IAAJ,EAAU;AACN,gBAAsBA,IAAI,KAAK,gBAAT,GAChB,CAACZ,YAAD,EAAeI,kBAAf,CADgB,GAEhB,CAACA,kBAAD,EAAqBJ,YAArB,CAFN;AAAA;AAAA,QAAOa,KAAP;AAAA,QAAcC,IAAd;;AAGA,WAAOD,KAAK,GAAGE,IAAR,CAAa;AAAA,aAAMD,IAAI,EAAV;AAAA,KAAb,CAAP;AACH,GALD,MAMK;AACD,WAAOb,OAAO,CAACC,GAAR,CAAY,CAACF,YAAY,EAAb,EAAiBI,kBAAkB,CAACd,OAAO,CAAC0B,KAAT,CAAnC,CAAZ,CAAP;AACH;AACJ;;AACD,SAASL,eAAT,CAAyBvB,aAAzB,EAAwCC,OAAxC,EAAwH;AAAA,MAAvEmB,aAAuE,uEAAvD,CAAuD;AAAA,MAApDC,eAAoD,uEAAlC,CAAkC;AAAA,MAA/BC,gBAA+B,uEAAZ,CAAY;AAAA,MAATpB,OAAS;AACpH,MAAM2B,UAAU,GAAG,EAAnB;AACA,MAAMC,kBAAkB,GAAG,CAAC9B,aAAa,CAACiB,eAAd,CAA8BC,IAA9B,GAAqC,CAAtC,IAA2CG,eAAtE;AACA,MAAMU,uBAAuB,GAAGT,gBAAgB,KAAK,CAArB,GAC1B;AAAA,QAACU,CAAD,uEAAK,CAAL;AAAA,WAAWA,CAAC,GAAGX,eAAf;AAAA,GAD0B,GAE1B;AAAA,QAACW,CAAD,uEAAK,CAAL;AAAA,WAAWF,kBAAkB,GAAGE,CAAC,GAAGX,eAApC;AAAA,GAFN;AAGAY,EAAAA,KAAK,CAACC,IAAN,CAAWlC,aAAa,CAACiB,eAAzB,EACKkB,IADL,CACUC,eADV,EAEKC,OAFL,CAEa,UAACC,KAAD,EAAQN,CAAR,EAAc;AACvBM,IAAAA,KAAK,CAACC,MAAN,CAAa,gBAAb,EAA+BtC,OAA/B;AACA4B,IAAAA,UAAU,CAACW,IAAX,CAAgBzC,cAAc,CAACuC,KAAD,EAAQrC,OAAR,kCACvBC,OADuB;AAE1B0B,MAAAA,KAAK,EAAER,aAAa,GAAGW,uBAAuB,CAACC,CAAD;AAFpB,OAAd,CAGbL,IAHa,CAGR;AAAA,aAAMW,KAAK,CAACC,MAAN,CAAa,mBAAb,EAAkCtC,OAAlC,CAAN;AAAA,KAHQ,CAAhB;AAIH,GARD;AASA,SAAOY,OAAO,CAACC,GAAR,CAAYe,UAAZ,CAAP;AACH;;AACD,SAASO,eAAT,CAAyBK,CAAzB,EAA4BC,CAA5B,EAA+B;AAC3B,SAAOD,CAAC,CAACE,gBAAF,CAAmBD,CAAnB,CAAP;AACH;;AAED,SAAS3C,cAAT,EAAyBqC,eAAzB","sourcesContent":["import { resolveVariant } from '../../render/utils/resolve-dynamic-variants.mjs';\nimport { animateTarget } from './visual-element-target.mjs';\n\nfunction animateVariant(visualElement, variant, options = {}) {\n    var _a;\n    const resolved = resolveVariant(visualElement, variant, options.type === \"exit\"\n        ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\n        : undefined);\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation = resolved\n        ? () => Promise.all(animateTarget(visualElement, resolved, options))\n        : () => Promise.resolve();\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size\n        ? (forwardDelay = 0) => {\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : () => Promise.resolve();\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition;\n    if (when) {\n        const [first, last] = when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation];\n        return first().then(() => last());\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [];\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    const generateStaggerDuration = staggerDirection === 1\n        ? (i = 0) => i * staggerChildren\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach((child, i) => {\n        child.notify(\"AnimationStart\", variant);\n        animations.push(animateVariant(child, variant, {\n            ...options,\n            delay: delayChildren + generateStaggerDuration(i),\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\n    });\n    return Promise.all(animations);\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n\nexport { animateVariant, sortByTreeOrder };\n"]},"metadata":{},"sourceType":"module"}