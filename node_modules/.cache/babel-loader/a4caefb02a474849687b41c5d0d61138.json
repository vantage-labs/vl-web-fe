{"ast":null,"code":"import _objectSpread from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _classCallCheck from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar _excluded = [\"autoplay\", \"delay\", \"type\", \"repeat\", \"repeatDelay\", \"repeatType\"];\nimport { time } from '../../frameloop/sync-time.mjs';\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\n\nvar MAX_RESOLVE_DELAY = 40;\n\nvar BaseAnimation = /*#__PURE__*/function () {\n  function BaseAnimation(_ref) {\n    var _ref$autoplay = _ref.autoplay,\n        autoplay = _ref$autoplay === void 0 ? true : _ref$autoplay,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === void 0 ? 0 : _ref$delay,\n        _ref$type = _ref.type,\n        type = _ref$type === void 0 ? \"keyframes\" : _ref$type,\n        _ref$repeat = _ref.repeat,\n        repeat = _ref$repeat === void 0 ? 0 : _ref$repeat,\n        _ref$repeatDelay = _ref.repeatDelay,\n        repeatDelay = _ref$repeatDelay === void 0 ? 0 : _ref$repeatDelay,\n        _ref$repeatType = _ref.repeatType,\n        repeatType = _ref$repeatType === void 0 ? \"loop\" : _ref$repeatType,\n        options = _objectWithoutProperties(_ref, _excluded);\n\n    _classCallCheck(this, BaseAnimation);\n\n    // Track whether the animation has been stopped. Stopped animations won't restart.\n    this.isStopped = false;\n    this.hasAttemptedResolve = false;\n    this.createdAt = time.now();\n    this.options = _objectSpread({\n      autoplay: autoplay,\n      delay: delay,\n      type: type,\n      repeat: repeat,\n      repeatDelay: repeatDelay,\n      repeatType: repeatType\n    }, options);\n    this.updateFinishedPromise();\n  }\n  /**\n   * This method uses the createdAt and resolvedAt to calculate the\n   * animation startTime. *Ideally*, we would use the createdAt time as t=0\n   * as the following frame would then be the first frame of the animation in\n   * progress, which would feel snappier.\n   *\n   * However, if there's a delay (main thread work) between the creation of\n   * the animation and the first commited frame, we prefer to use resolvedAt\n   * to avoid a sudden jump into the animation.\n   */\n\n\n  _createClass(BaseAnimation, [{\n    key: \"calcStartTime\",\n    value: function calcStartTime() {\n      if (!this.resolvedAt) return this.createdAt;\n      return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n\n  }, {\n    key: \"resolved\",\n    get: function get() {\n      if (!this._resolved && !this.hasAttemptedResolve) {\n        flushKeyframeResolvers();\n      }\n\n      return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n\n  }, {\n    key: \"onKeyframesResolved\",\n    value: function onKeyframesResolved(keyframes, finalKeyframe) {\n      this.resolvedAt = time.now();\n      this.hasAttemptedResolve = true;\n      var _this$options = this.options,\n          name = _this$options.name,\n          type = _this$options.type,\n          velocity = _this$options.velocity,\n          delay = _this$options.delay,\n          onComplete = _this$options.onComplete,\n          onUpdate = _this$options.onUpdate,\n          isGenerator = _this$options.isGenerator;\n      /**\n       * If we can't animate this value with the resolved keyframes\n       * then we should complete it immediately.\n       */\n\n      if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n        // Finish immediately\n        if (instantAnimationState.current || !delay) {\n          onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n          onComplete === null || onComplete === void 0 ? void 0 : onComplete();\n          this.resolveFinishedPromise();\n          return;\n        } // Finish after a delay\n        else {\n          this.options.duration = 0;\n        }\n      }\n\n      var resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n      if (resolvedAnimation === false) return;\n      this._resolved = _objectSpread({\n        keyframes: keyframes,\n        finalKeyframe: finalKeyframe\n      }, resolvedAnimation);\n      this.onPostResolved();\n    }\n  }, {\n    key: \"onPostResolved\",\n    value: function onPostResolved() {}\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n\n  }, {\n    key: \"then\",\n    value: function then(resolve, reject) {\n      return this.currentFinishedPromise.then(resolve, reject);\n    }\n  }, {\n    key: \"flatten\",\n    value: function flatten() {\n      this.options.type = \"keyframes\";\n      this.options.ease = \"linear\";\n    }\n  }, {\n    key: \"updateFinishedPromise\",\n    value: function updateFinishedPromise() {\n      var _this = this;\n\n      this.currentFinishedPromise = new Promise(function (resolve) {\n        _this.resolveFinishedPromise = resolve;\n      });\n    }\n  }]);\n\n  return BaseAnimation;\n}();\n\nexport { BaseAnimation };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs"],"names":["time","flushKeyframeResolvers","instantAnimationState","canAnimate","getFinalKeyframe","MAX_RESOLVE_DELAY","BaseAnimation","autoplay","delay","type","repeat","repeatDelay","repeatType","options","isStopped","hasAttemptedResolve","createdAt","now","updateFinishedPromise","resolvedAt","_resolved","keyframes","finalKeyframe","name","velocity","onComplete","onUpdate","isGenerator","current","resolveFinishedPromise","duration","resolvedAnimation","initPlayback","onPostResolved","resolve","reject","currentFinishedPromise","then","ease","Promise"],"mappings":";;;;;AAAA,SAASA,IAAT,QAAqB,+BAArB;AACA,SAASC,sBAAT,QAAuC,0CAAvC;AACA,SAASC,qBAAT,QAAsC,8CAAtC;AACA,SAASC,UAAT,QAA2B,yBAA3B;AACA,SAASC,gBAAT,QAAiC,sCAAjC;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,iBAAiB,GAAG,EAA1B;;IACMC,a;AACF,+BAA8H;AAAA,6BAAhHC,QAAgH;AAAA,QAAhHA,QAAgH,8BAArG,IAAqG;AAAA,0BAA/FC,KAA+F;AAAA,QAA/FA,KAA+F,2BAAvF,CAAuF;AAAA,yBAApFC,IAAoF;AAAA,QAApFA,IAAoF,0BAA7E,WAA6E;AAAA,2BAAhEC,MAAgE;AAAA,QAAhEA,MAAgE,4BAAvD,CAAuD;AAAA,gCAApDC,WAAoD;AAAA,QAApDA,WAAoD,iCAAtC,CAAsC;AAAA,+BAAnCC,UAAmC;AAAA,QAAnCA,UAAmC,gCAAtB,MAAsB;AAAA,QAAXC,OAAW;;AAAA;;AAC1H;AACA,SAAKC,SAAL,GAAiB,KAAjB;AACA,SAAKC,mBAAL,GAA2B,KAA3B;AACA,SAAKC,SAAL,GAAiBhB,IAAI,CAACiB,GAAL,EAAjB;AACA,SAAKJ,OAAL;AACIN,MAAAA,QAAQ,EAARA,QADJ;AAEIC,MAAAA,KAAK,EAALA,KAFJ;AAGIC,MAAAA,IAAI,EAAJA,IAHJ;AAIIC,MAAAA,MAAM,EAANA,MAJJ;AAKIC,MAAAA,WAAW,EAAXA,WALJ;AAMIC,MAAAA,UAAU,EAAVA;AANJ,OAOOC,OAPP;AASA,SAAKK,qBAAL;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACI,yBAAgB;AACZ,UAAI,CAAC,KAAKC,UAAV,EACI,OAAO,KAAKH,SAAZ;AACJ,aAAO,KAAKG,UAAL,GAAkB,KAAKH,SAAvB,GAAmCX,iBAAnC,GACD,KAAKc,UADJ,GAED,KAAKH,SAFX;AAGH;AACD;AACJ;AACA;AACA;AACA;;;;SACI,eAAe;AACX,UAAI,CAAC,KAAKI,SAAN,IAAmB,CAAC,KAAKL,mBAA7B,EAAkD;AAC9Cd,QAAAA,sBAAsB;AACzB;;AACD,aAAO,KAAKmB,SAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;;;;WACI,6BAAoBC,SAApB,EAA+BC,aAA/B,EAA8C;AAC1C,WAAKH,UAAL,GAAkBnB,IAAI,CAACiB,GAAL,EAAlB;AACA,WAAKF,mBAAL,GAA2B,IAA3B;AACA,0BAA4E,KAAKF,OAAjF;AAAA,UAAQU,IAAR,iBAAQA,IAAR;AAAA,UAAcd,IAAd,iBAAcA,IAAd;AAAA,UAAoBe,QAApB,iBAAoBA,QAApB;AAAA,UAA8BhB,KAA9B,iBAA8BA,KAA9B;AAAA,UAAqCiB,UAArC,iBAAqCA,UAArC;AAAA,UAAiDC,QAAjD,iBAAiDA,QAAjD;AAAA,UAA2DC,WAA3D,iBAA2DA,WAA3D;AACA;AACR;AACA;AACA;;AACQ,UAAI,CAACA,WAAD,IAAgB,CAACxB,UAAU,CAACkB,SAAD,EAAYE,IAAZ,EAAkBd,IAAlB,EAAwBe,QAAxB,CAA/B,EAAkE;AAC9D;AACA,YAAItB,qBAAqB,CAAC0B,OAAtB,IAAiC,CAACpB,KAAtC,EAA6C;AACzCkB,UAAAA,QAAQ,KAAK,IAAb,IAAqBA,QAAQ,KAAK,KAAK,CAAvC,GAA2C,KAAK,CAAhD,GAAoDA,QAAQ,CAACtB,gBAAgB,CAACiB,SAAD,EAAY,KAAKR,OAAjB,EAA0BS,aAA1B,CAAjB,CAA5D;AACAG,UAAAA,UAAU,KAAK,IAAf,IAAuBA,UAAU,KAAK,KAAK,CAA3C,GAA+C,KAAK,CAApD,GAAwDA,UAAU,EAAlE;AACA,eAAKI,sBAAL;AACA;AACH,SALD,CAMA;AANA,aAOK;AACD,eAAKhB,OAAL,CAAaiB,QAAb,GAAwB,CAAxB;AACH;AACJ;;AACD,UAAMC,iBAAiB,GAAG,KAAKC,YAAL,CAAkBX,SAAlB,EAA6BC,aAA7B,CAA1B;AACA,UAAIS,iBAAiB,KAAK,KAA1B,EACI;AACJ,WAAKX,SAAL;AACIC,QAAAA,SAAS,EAATA,SADJ;AAEIC,QAAAA,aAAa,EAAbA;AAFJ,SAGOS,iBAHP;AAKA,WAAKE,cAAL;AACH;;;WACD,0BAAiB,CAAG;AACpB;AACJ;AACA;AACA;AACA;;;;WACI,cAAKC,OAAL,EAAcC,MAAd,EAAsB;AAClB,aAAO,KAAKC,sBAAL,CAA4BC,IAA5B,CAAiCH,OAAjC,EAA0CC,MAA1C,CAAP;AACH;;;WACD,mBAAU;AACN,WAAKtB,OAAL,CAAaJ,IAAb,GAAoB,WAApB;AACA,WAAKI,OAAL,CAAayB,IAAb,GAAoB,QAApB;AACH;;;WACD,iCAAwB;AAAA;;AACpB,WAAKF,sBAAL,GAA8B,IAAIG,OAAJ,CAAY,UAACL,OAAD,EAAa;AACnD,QAAA,KAAI,CAACL,sBAAL,GAA8BK,OAA9B;AACH,OAF6B,CAA9B;AAGH;;;;;;AAGL,SAAS5B,aAAT","sourcesContent":["import { time } from '../../frameloop/sync-time.mjs';\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n\n/**\n * Maximum time allowed between an animation being created and it being\n * resolved for us to use the latter as the start time.\n *\n * This is to ensure that while we prefer to \"start\" an animation as soon\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\n * between these two moments.\n */\nconst MAX_RESOLVE_DELAY = 40;\nclass BaseAnimation {\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\n        // Track whether the animation has been stopped. Stopped animations won't restart.\n        this.isStopped = false;\n        this.hasAttemptedResolve = false;\n        this.createdAt = time.now();\n        this.options = {\n            autoplay,\n            delay,\n            type,\n            repeat,\n            repeatDelay,\n            repeatType,\n            ...options,\n        };\n        this.updateFinishedPromise();\n    }\n    /**\n     * This method uses the createdAt and resolvedAt to calculate the\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\n     * as the following frame would then be the first frame of the animation in\n     * progress, which would feel snappier.\n     *\n     * However, if there's a delay (main thread work) between the creation of\n     * the animation and the first commited frame, we prefer to use resolvedAt\n     * to avoid a sudden jump into the animation.\n     */\n    calcStartTime() {\n        if (!this.resolvedAt)\n            return this.createdAt;\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\n            ? this.resolvedAt\n            : this.createdAt;\n    }\n    /**\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\n     * this.resolved will synchronously flush all pending keyframe resolvers.\n     * This is a deoptimisation, but at its worst still batches read/writes.\n     */\n    get resolved() {\n        if (!this._resolved && !this.hasAttemptedResolve) {\n            flushKeyframeResolvers();\n        }\n        return this._resolved;\n    }\n    /**\n     * A method to be called when the keyframes resolver completes. This method\n     * will check if its possible to run the animation and, if not, skip it.\n     * Otherwise, it will call initPlayback on the implementing class.\n     */\n    onKeyframesResolved(keyframes, finalKeyframe) {\n        this.resolvedAt = time.now();\n        this.hasAttemptedResolve = true;\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\n        /**\n         * If we can't animate this value with the resolved keyframes\n         * then we should complete it immediately.\n         */\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n            // Finish immediately\n            if (instantAnimationState.current || !delay) {\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete === null || onComplete === void 0 ? void 0 : onComplete();\n                this.resolveFinishedPromise();\n                return;\n            }\n            // Finish after a delay\n            else {\n                this.options.duration = 0;\n            }\n        }\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n        if (resolvedAnimation === false)\n            return;\n        this._resolved = {\n            keyframes,\n            finalKeyframe,\n            ...resolvedAnimation,\n        };\n        this.onPostResolved();\n    }\n    onPostResolved() { }\n    /**\n     * Allows the returned animation to be awaited or promise-chained. Currently\n     * resolves when the animation finishes at all but in a future update could/should\n     * reject if its cancels.\n     */\n    then(resolve, reject) {\n        return this.currentFinishedPromise.then(resolve, reject);\n    }\n    flatten() {\n        this.options.type = \"keyframes\";\n        this.options.ease = \"linear\";\n    }\n    updateFinishedPromise() {\n        this.currentFinishedPromise = new Promise((resolve) => {\n            this.resolveFinishedPromise = resolve;\n        });\n    }\n}\n\nexport { BaseAnimation };\n"]},"metadata":{},"sourceType":"module"}