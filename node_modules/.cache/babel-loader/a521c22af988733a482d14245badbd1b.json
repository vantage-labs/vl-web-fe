{"ast":null,"code":"import { progress, noop } from 'motion-utils';\nimport { circOut } from '../../easing/circ.mjs';\nimport { mixNumber } from '../../utils/mix/number.mjs';\nimport { percent, px } from '../../value/types/numbers/units.mjs';\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\n\nvar asNumber = function asNumber(value) {\n  return typeof value === \"string\" ? parseFloat(value) : value;\n};\n\nvar isPx = function isPx(value) {\n  return typeof value === \"number\" || px.test(value);\n};\n\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n  if (shouldCrossfadeOpacity) {\n    target.opacity = mixNumber(0, // TODO Reinstate this if only child\n    lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));\n    target.opacityExit = mixNumber(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));\n  } else if (isOnlyMember) {\n    target.opacity = mixNumber(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);\n  }\n  /**\n   * Mix border radius\n   */\n\n\n  for (var i = 0; i < numBorders; i++) {\n    var borderLabel = \"border\".concat(borders[i], \"Radius\");\n    var followRadius = getRadius(follow, borderLabel);\n    var leadRadius = getRadius(lead, borderLabel);\n    if (followRadius === undefined && leadRadius === undefined) continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    var canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);\n\n    if (canMix) {\n      target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n\n      if (percent.test(leadRadius) || percent.test(followRadius)) {\n        target[borderLabel] += \"%\";\n      }\n    } else {\n      target[borderLabel] = leadRadius;\n    }\n  }\n  /**\n   * Mix rotation\n   */\n\n\n  if (follow.rotate || lead.rotate) {\n    target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);\n  }\n}\n\nfunction getRadius(values, radiusName) {\n  return values[radiusName] !== undefined ? values[radiusName] : values.borderRadius;\n} // /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\n\n\nvar easeCrossfadeIn = /*@__PURE__*/compress(0, 0.5, circOut);\nvar easeCrossfadeOut = /*@__PURE__*/compress(0.5, 0.95, noop);\n\nfunction compress(min, max, easing) {\n  return function (p) {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(progress(min, max, p));\n  };\n}\n\nexport { mixValues };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs"],"names":["progress","noop","circOut","mixNumber","percent","px","borders","numBorders","length","asNumber","value","parseFloat","isPx","test","mixValues","target","follow","lead","shouldCrossfadeOpacity","isOnlyMember","opacity","undefined","easeCrossfadeIn","opacityExit","easeCrossfadeOut","i","borderLabel","followRadius","getRadius","leadRadius","canMix","Math","max","rotate","values","radiusName","borderRadius","compress","min","easing","p"],"mappings":"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","sourcesContent":["import { progress, noop } from 'motion-utils';\nimport { circOut } from '../../easing/circ.mjs';\nimport { mixNumber } from '../../utils/mix/number.mjs';\nimport { percent, px } from '../../value/types/numbers/units.mjs';\n\nconst borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nconst numBorders = borders.length;\nconst asNumber = (value) => typeof value === \"string\" ? parseFloat(value) : value;\nconst isPx = (value) => typeof value === \"number\" || px.test(value);\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mixNumber(0, \n        // TODO Reinstate this if only child\n        lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));\n        target.opacityExit = mixNumber(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));\n    }\n    else if (isOnlyMember) {\n        target.opacity = mixNumber(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);\n    }\n    /**\n     * Mix border radius\n     */\n    for (let i = 0; i < numBorders; i++) {\n        const borderLabel = `border${borders[i]}Radius`;\n        let followRadius = getRadius(follow, borderLabel);\n        let leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        const canMix = followRadius === 0 ||\n            leadRadius === 0 ||\n            isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += \"%\";\n            }\n        }\n        else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    return values[radiusName] !== undefined\n        ? values[radiusName]\n        : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there's a follow element\n//  * that we're not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nconst easeCrossfadeIn = /*@__PURE__*/ compress(0, 0.5, circOut);\nconst easeCrossfadeOut = /*@__PURE__*/ compress(0.5, 0.95, noop);\nfunction compress(min, max, easing) {\n    return (p) => {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\n\nexport { mixValues };\n"]},"metadata":{},"sourceType":"module"}