{"ast":null,"code":"\"use client\"; // packages/react/menu/src/Menu.tsx\n\nimport * as React from \"react\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { useComposedRefs, composeRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { useDirection } from \"@radix-ui/react-direction\";\nimport { DismissableLayer } from \"@radix-ui/react-dismissable-layer\";\nimport { useFocusGuards } from \"@radix-ui/react-focus-guards\";\nimport { FocusScope } from \"@radix-ui/react-focus-scope\";\nimport { useId } from \"@radix-ui/react-id\";\nimport * as PopperPrimitive from \"@radix-ui/react-popper\";\nimport { createPopperScope } from \"@radix-ui/react-popper\";\nimport { Portal as PortalPrimitive } from \"@radix-ui/react-portal\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { Primitive, dispatchDiscreteCustomEvent } from \"@radix-ui/react-primitive\";\nimport * as RovingFocusGroup from \"@radix-ui/react-roving-focus\";\nimport { createRovingFocusGroupScope } from \"@radix-ui/react-roving-focus\";\nimport { Slot } from \"@radix-ui/react-slot\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { hideOthers } from \"aria-hidden\";\nimport { RemoveScroll } from \"react-remove-scroll\";\nimport { jsx } from \"react/jsx-runtime\";\nvar SELECTION_KEYS = [\"Enter\", \" \"];\nvar FIRST_KEYS = [\"ArrowDown\", \"PageUp\", \"Home\"];\nvar LAST_KEYS = [\"ArrowUp\", \"PageDown\", \"End\"];\nvar FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nvar SUB_OPEN_KEYS = {\n  ltr: [...SELECTION_KEYS, \"ArrowRight\"],\n  rtl: [...SELECTION_KEYS, \"ArrowLeft\"]\n};\nvar SUB_CLOSE_KEYS = {\n  ltr: [\"ArrowLeft\"],\n  rtl: [\"ArrowRight\"]\n};\nvar MENU_NAME = \"Menu\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(MENU_NAME);\nvar [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [createCollectionScope, createPopperScope, createRovingFocusGroupScope]);\nvar usePopperScope = createPopperScope();\nvar useRovingFocusGroupScope = createRovingFocusGroupScope();\nvar [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);\nvar [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);\n\nvar Menu = props => {\n  const {\n    __scopeMenu,\n    open = false,\n    children,\n    dir,\n    onOpenChange,\n    modal = true\n  } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  const [content, setContent] = React.useState(null);\n  const isUsingKeyboardRef = React.useRef(false);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  const direction = useDirection(dir);\n  React.useEffect(() => {\n    const handleKeyDown = () => {\n      isUsingKeyboardRef.current = true;\n      document.addEventListener(\"pointerdown\", handlePointer, {\n        capture: true,\n        once: true\n      });\n      document.addEventListener(\"pointermove\", handlePointer, {\n        capture: true,\n        once: true\n      });\n    };\n\n    const handlePointer = () => isUsingKeyboardRef.current = false;\n\n    document.addEventListener(\"keydown\", handleKeyDown, {\n      capture: true\n    });\n    return () => {\n      document.removeEventListener(\"keydown\", handleKeyDown, {\n        capture: true\n      });\n      document.removeEventListener(\"pointerdown\", handlePointer, {\n        capture: true\n      });\n      document.removeEventListener(\"pointermove\", handlePointer, {\n        capture: true\n      });\n    };\n  }, []);\n  return /* @__PURE__ */jsx(PopperPrimitive.Root, { ...popperScope,\n    children: /* @__PURE__ */jsx(MenuProvider, {\n      scope: __scopeMenu,\n      open,\n      onOpenChange: handleOpenChange,\n      content,\n      onContentChange: setContent,\n      children: /* @__PURE__ */jsx(MenuRootProvider, {\n        scope: __scopeMenu,\n        onClose: React.useCallback(() => handleOpenChange(false), [handleOpenChange]),\n        isUsingKeyboardRef,\n        dir: direction,\n        modal,\n        children\n      })\n    })\n  });\n};\n\nMenu.displayName = MENU_NAME;\nvar ANCHOR_NAME = \"MenuAnchor\";\nvar MenuAnchor = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...anchorProps\n  } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  return /* @__PURE__ */jsx(PopperPrimitive.Anchor, { ...popperScope,\n    ...anchorProps,\n    ref: forwardedRef\n  });\n});\nMenuAnchor.displayName = ANCHOR_NAME;\nvar PORTAL_NAME = \"MenuPortal\";\nvar [PortalProvider, usePortalContext] = createMenuContext(PORTAL_NAME, {\n  forceMount: void 0\n});\n\nvar MenuPortal = props => {\n  const {\n    __scopeMenu,\n    forceMount,\n    children,\n    container\n  } = props;\n  const context = useMenuContext(PORTAL_NAME, __scopeMenu);\n  return /* @__PURE__ */jsx(PortalProvider, {\n    scope: __scopeMenu,\n    forceMount,\n    children: /* @__PURE__ */jsx(Presence, {\n      present: forceMount || context.open,\n      children: /* @__PURE__ */jsx(PortalPrimitive, {\n        asChild: true,\n        container,\n        children\n      })\n    })\n  });\n};\n\nMenuPortal.displayName = PORTAL_NAME;\nvar CONTENT_NAME = \"MenuContent\";\nvar [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME);\nvar MenuContent = React.forwardRef((props, forwardedRef) => {\n  const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n  const {\n    forceMount = portalContext.forceMount,\n    ...contentProps\n  } = props;\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n  return /* @__PURE__ */jsx(Collection.Provider, {\n    scope: props.__scopeMenu,\n    children: /* @__PURE__ */jsx(Presence, {\n      present: forceMount || context.open,\n      children: /* @__PURE__ */jsx(Collection.Slot, {\n        scope: props.__scopeMenu,\n        children: rootContext.modal ? /* @__PURE__ */jsx(MenuRootContentModal, { ...contentProps,\n          ref: forwardedRef\n        }) : /* @__PURE__ */jsx(MenuRootContentNonModal, { ...contentProps,\n          ref: forwardedRef\n        })\n      })\n    })\n  });\n});\nvar MenuRootContentModal = React.forwardRef((props, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  React.useEffect(() => {\n    const content = ref.current;\n    if (content) return hideOthers(content);\n  }, []);\n  return /* @__PURE__ */jsx(MenuContentImpl, { ...props,\n    ref: composedRefs,\n    trapFocus: context.open,\n    disableOutsidePointerEvents: context.open,\n    disableOutsideScroll: true,\n    onFocusOutside: composeEventHandlers(props.onFocusOutside, event => event.preventDefault(), {\n      checkForDefaultPrevented: false\n    }),\n    onDismiss: () => context.onOpenChange(false)\n  });\n});\nvar MenuRootContentNonModal = React.forwardRef((props, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  return /* @__PURE__ */jsx(MenuContentImpl, { ...props,\n    ref: forwardedRef,\n    trapFocus: false,\n    disableOutsidePointerEvents: false,\n    disableOutsideScroll: false,\n    onDismiss: () => context.onOpenChange(false)\n  });\n});\nvar MenuContentImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    loop = false,\n    trapFocus,\n    onOpenAutoFocus,\n    onCloseAutoFocus,\n    disableOutsidePointerEvents,\n    onEntryFocus,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    onDismiss,\n    disableOutsideScroll,\n    ...contentProps\n  } = props;\n  const context = useMenuContext(CONTENT_NAME, __scopeMenu);\n  const rootContext = useMenuRootContext(CONTENT_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n  const getItems = useCollection(__scopeMenu);\n  const [currentItemId, setCurrentItemId] = React.useState(null);\n  const contentRef = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);\n  const timerRef = React.useRef(0);\n  const searchRef = React.useRef(\"\");\n  const pointerGraceTimerRef = React.useRef(0);\n  const pointerGraceIntentRef = React.useRef(null);\n  const pointerDirRef = React.useRef(\"right\");\n  const lastPointerXRef = React.useRef(0);\n  const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n  const scrollLockWrapperProps = disableOutsideScroll ? {\n    as: Slot,\n    allowPinchZoom: true\n  } : void 0;\n\n  const handleTypeaheadSearch = key => {\n    const search = searchRef.current + key;\n    const items = getItems().filter(item => !item.disabled);\n    const currentItem = document.activeElement;\n    const currentMatch = items.find(item => item.ref.current === currentItem)?.textValue;\n    const values = items.map(item => item.textValue);\n    const nextMatch = getNextMatch(values, search, currentMatch);\n    const newItem = items.find(item => item.textValue === nextMatch)?.ref.current;\n\n    (function updateSearch(value) {\n      searchRef.current = value;\n      window.clearTimeout(timerRef.current);\n      if (value !== \"\") timerRef.current = window.setTimeout(() => updateSearch(\"\"), 1e3);\n    })(search);\n\n    if (newItem) {\n      setTimeout(() => newItem.focus());\n    }\n  };\n\n  React.useEffect(() => {\n    return () => window.clearTimeout(timerRef.current);\n  }, []);\n  useFocusGuards();\n  const isPointerMovingToSubmenu = React.useCallback(event => {\n    const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;\n    return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);\n  }, []);\n  return /* @__PURE__ */jsx(MenuContentProvider, {\n    scope: __scopeMenu,\n    searchRef,\n    onItemEnter: React.useCallback(event => {\n      if (isPointerMovingToSubmenu(event)) event.preventDefault();\n    }, [isPointerMovingToSubmenu]),\n    onItemLeave: React.useCallback(event => {\n      if (isPointerMovingToSubmenu(event)) return;\n      contentRef.current?.focus();\n      setCurrentItemId(null);\n    }, [isPointerMovingToSubmenu]),\n    onTriggerLeave: React.useCallback(event => {\n      if (isPointerMovingToSubmenu(event)) event.preventDefault();\n    }, [isPointerMovingToSubmenu]),\n    pointerGraceTimerRef,\n    onPointerGraceIntentChange: React.useCallback(intent => {\n      pointerGraceIntentRef.current = intent;\n    }, []),\n    children: /* @__PURE__ */jsx(ScrollLockWrapper, { ...scrollLockWrapperProps,\n      children: /* @__PURE__ */jsx(FocusScope, {\n        asChild: true,\n        trapped: trapFocus,\n        onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, event => {\n          event.preventDefault();\n          contentRef.current?.focus({\n            preventScroll: true\n          });\n        }),\n        onUnmountAutoFocus: onCloseAutoFocus,\n        children: /* @__PURE__ */jsx(DismissableLayer, {\n          asChild: true,\n          disableOutsidePointerEvents,\n          onEscapeKeyDown,\n          onPointerDownOutside,\n          onFocusOutside,\n          onInteractOutside,\n          onDismiss,\n          children: /* @__PURE__ */jsx(RovingFocusGroup.Root, {\n            asChild: true,\n            ...rovingFocusGroupScope,\n            dir: rootContext.dir,\n            orientation: \"vertical\",\n            loop,\n            currentTabStopId: currentItemId,\n            onCurrentTabStopIdChange: setCurrentItemId,\n            onEntryFocus: composeEventHandlers(onEntryFocus, event => {\n              if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();\n            }),\n            preventScrollOnEntryFocus: true,\n            children: /* @__PURE__ */jsx(PopperPrimitive.Content, {\n              role: \"menu\",\n              \"aria-orientation\": \"vertical\",\n              \"data-state\": getOpenState(context.open),\n              \"data-radix-menu-content\": \"\",\n              dir: rootContext.dir,\n              ...popperScope,\n              ...contentProps,\n              ref: composedRefs,\n              style: {\n                outline: \"none\",\n                ...contentProps.style\n              },\n              onKeyDown: composeEventHandlers(contentProps.onKeyDown, event => {\n                const target = event.target;\n                const isKeyDownInside = target.closest(\"[data-radix-menu-content]\") === event.currentTarget;\n                const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                const isCharacterKey = event.key.length === 1;\n\n                if (isKeyDownInside) {\n                  if (event.key === \"Tab\") event.preventDefault();\n                  if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);\n                }\n\n                const content = contentRef.current;\n                if (event.target !== content) return;\n                if (!FIRST_LAST_KEYS.includes(event.key)) return;\n                event.preventDefault();\n                const items = getItems().filter(item => !item.disabled);\n                const candidateNodes = items.map(item => item.ref.current);\n                if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                focusFirst(candidateNodes);\n              }),\n              onBlur: composeEventHandlers(props.onBlur, event => {\n                if (!event.currentTarget.contains(event.target)) {\n                  window.clearTimeout(timerRef.current);\n                  searchRef.current = \"\";\n                }\n              }),\n              onPointerMove: composeEventHandlers(props.onPointerMove, whenMouse(event => {\n                const target = event.target;\n                const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n\n                if (event.currentTarget.contains(target) && pointerXHasChanged) {\n                  const newDir = event.clientX > lastPointerXRef.current ? \"right\" : \"left\";\n                  pointerDirRef.current = newDir;\n                  lastPointerXRef.current = event.clientX;\n                }\n              }))\n            })\n          })\n        })\n      })\n    })\n  });\n});\nMenuContent.displayName = CONTENT_NAME;\nvar GROUP_NAME = \"MenuGroup\";\nvar MenuGroup = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...groupProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    role: \"group\",\n    ...groupProps,\n    ref: forwardedRef\n  });\n});\nMenuGroup.displayName = GROUP_NAME;\nvar LABEL_NAME = \"MenuLabel\";\nvar MenuLabel = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...labelProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, { ...labelProps,\n    ref: forwardedRef\n  });\n});\nMenuLabel.displayName = LABEL_NAME;\nvar ITEM_NAME = \"MenuItem\";\nvar ITEM_SELECT = \"menu.itemSelect\";\nvar MenuItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    disabled = false,\n    onSelect,\n    ...itemProps\n  } = props;\n  const ref = React.useRef(null);\n  const rootContext = useMenuRootContext(ITEM_NAME, props.__scopeMenu);\n  const contentContext = useMenuContentContext(ITEM_NAME, props.__scopeMenu);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const isPointerDownRef = React.useRef(false);\n\n  const handleSelect = () => {\n    const menuItem = ref.current;\n\n    if (!disabled && menuItem) {\n      const itemSelectEvent = new CustomEvent(ITEM_SELECT, {\n        bubbles: true,\n        cancelable: true\n      });\n      menuItem.addEventListener(ITEM_SELECT, event => onSelect?.(event), {\n        once: true\n      });\n      dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);\n\n      if (itemSelectEvent.defaultPrevented) {\n        isPointerDownRef.current = false;\n      } else {\n        rootContext.onClose();\n      }\n    }\n  };\n\n  return /* @__PURE__ */jsx(MenuItemImpl, { ...itemProps,\n    ref: composedRefs,\n    disabled,\n    onClick: composeEventHandlers(props.onClick, handleSelect),\n    onPointerDown: event => {\n      props.onPointerDown?.(event);\n      isPointerDownRef.current = true;\n    },\n    onPointerUp: composeEventHandlers(props.onPointerUp, event => {\n      if (!isPointerDownRef.current) event.currentTarget?.click();\n    }),\n    onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n      const isTypingAhead = contentContext.searchRef.current !== \"\";\n      if (disabled || isTypingAhead && event.key === \" \") return;\n\n      if (SELECTION_KEYS.includes(event.key)) {\n        event.currentTarget.click();\n        event.preventDefault();\n      }\n    })\n  });\n});\nMenuItem.displayName = ITEM_NAME;\nvar MenuItemImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    disabled = false,\n    textValue,\n    ...itemProps\n  } = props;\n  const contentContext = useMenuContentContext(ITEM_NAME, __scopeMenu);\n  const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const [isFocused, setIsFocused] = React.useState(false);\n  const [textContent, setTextContent] = React.useState(\"\");\n  React.useEffect(() => {\n    const menuItem = ref.current;\n\n    if (menuItem) {\n      setTextContent((menuItem.textContent ?? \"\").trim());\n    }\n  }, [itemProps.children]);\n  return /* @__PURE__ */jsx(Collection.ItemSlot, {\n    scope: __scopeMenu,\n    disabled,\n    textValue: textValue ?? textContent,\n    children: /* @__PURE__ */jsx(RovingFocusGroup.Item, {\n      asChild: true,\n      ...rovingFocusGroupScope,\n      focusable: !disabled,\n      children: /* @__PURE__ */jsx(Primitive.div, {\n        role: \"menuitem\",\n        \"data-highlighted\": isFocused ? \"\" : void 0,\n        \"aria-disabled\": disabled || void 0,\n        \"data-disabled\": disabled ? \"\" : void 0,\n        ...itemProps,\n        ref: composedRefs,\n        onPointerMove: composeEventHandlers(props.onPointerMove, whenMouse(event => {\n          if (disabled) {\n            contentContext.onItemLeave(event);\n          } else {\n            contentContext.onItemEnter(event);\n\n            if (!event.defaultPrevented) {\n              const item = event.currentTarget;\n              item.focus({\n                preventScroll: true\n              });\n            }\n          }\n        })),\n        onPointerLeave: composeEventHandlers(props.onPointerLeave, whenMouse(event => contentContext.onItemLeave(event))),\n        onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),\n        onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))\n      })\n    })\n  });\n});\nvar CHECKBOX_ITEM_NAME = \"MenuCheckboxItem\";\nvar MenuCheckboxItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    checked = false,\n    onCheckedChange,\n    ...checkboxItemProps\n  } = props;\n  return /* @__PURE__ */jsx(ItemIndicatorProvider, {\n    scope: props.__scopeMenu,\n    checked,\n    children: /* @__PURE__ */jsx(MenuItem, {\n      role: \"menuitemcheckbox\",\n      \"aria-checked\": isIndeterminate(checked) ? \"mixed\" : checked,\n      ...checkboxItemProps,\n      ref: forwardedRef,\n      \"data-state\": getCheckedState(checked),\n      onSelect: composeEventHandlers(checkboxItemProps.onSelect, () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked), {\n        checkForDefaultPrevented: false\n      })\n    })\n  });\n});\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\nvar RADIO_GROUP_NAME = \"MenuRadioGroup\";\nvar [RadioGroupProvider, useRadioGroupContext] = createMenuContext(RADIO_GROUP_NAME, {\n  value: void 0,\n  onValueChange: () => {}\n});\nvar MenuRadioGroup = React.forwardRef((props, forwardedRef) => {\n  const {\n    value,\n    onValueChange,\n    ...groupProps\n  } = props;\n  const handleValueChange = useCallbackRef(onValueChange);\n  return /* @__PURE__ */jsx(RadioGroupProvider, {\n    scope: props.__scopeMenu,\n    value,\n    onValueChange: handleValueChange,\n    children: /* @__PURE__ */jsx(MenuGroup, { ...groupProps,\n      ref: forwardedRef\n    })\n  });\n});\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\nvar RADIO_ITEM_NAME = \"MenuRadioItem\";\nvar MenuRadioItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    value,\n    ...radioItemProps\n  } = props;\n  const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);\n  const checked = value === context.value;\n  return /* @__PURE__ */jsx(ItemIndicatorProvider, {\n    scope: props.__scopeMenu,\n    checked,\n    children: /* @__PURE__ */jsx(MenuItem, {\n      role: \"menuitemradio\",\n      \"aria-checked\": checked,\n      ...radioItemProps,\n      ref: forwardedRef,\n      \"data-state\": getCheckedState(checked),\n      onSelect: composeEventHandlers(radioItemProps.onSelect, () => context.onValueChange?.(value), {\n        checkForDefaultPrevented: false\n      })\n    })\n  });\n});\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\nvar ITEM_INDICATOR_NAME = \"MenuItemIndicator\";\nvar [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(ITEM_INDICATOR_NAME, {\n  checked: false\n});\nvar MenuItemIndicator = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    forceMount,\n    ...itemIndicatorProps\n  } = props;\n  const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || isIndeterminate(indicatorContext.checked) || indicatorContext.checked === true,\n    children: /* @__PURE__ */jsx(Primitive.span, { ...itemIndicatorProps,\n      ref: forwardedRef,\n      \"data-state\": getCheckedState(indicatorContext.checked)\n    })\n  });\n});\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\nvar SEPARATOR_NAME = \"MenuSeparator\";\nvar MenuSeparator = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...separatorProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    role: \"separator\",\n    \"aria-orientation\": \"horizontal\",\n    ...separatorProps,\n    ref: forwardedRef\n  });\n});\nMenuSeparator.displayName = SEPARATOR_NAME;\nvar ARROW_NAME = \"MenuArrow\";\nvar MenuArrow = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeMenu,\n    ...arrowProps\n  } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  return /* @__PURE__ */jsx(PopperPrimitive.Arrow, { ...popperScope,\n    ...arrowProps,\n    ref: forwardedRef\n  });\n});\nMenuArrow.displayName = ARROW_NAME;\nvar SUB_NAME = \"MenuSub\";\nvar [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);\n\nvar MenuSub = props => {\n  const {\n    __scopeMenu,\n    children,\n    open = false,\n    onOpenChange\n  } = props;\n  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = React.useState(null);\n  const [content, setContent] = React.useState(null);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  React.useEffect(() => {\n    if (parentMenuContext.open === false) handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [parentMenuContext.open, handleOpenChange]);\n  return /* @__PURE__ */jsx(PopperPrimitive.Root, { ...popperScope,\n    children: /* @__PURE__ */jsx(MenuProvider, {\n      scope: __scopeMenu,\n      open,\n      onOpenChange: handleOpenChange,\n      content,\n      onContentChange: setContent,\n      children: /* @__PURE__ */jsx(MenuSubProvider, {\n        scope: __scopeMenu,\n        contentId: useId(),\n        triggerId: useId(),\n        trigger,\n        onTriggerChange: setTrigger,\n        children\n      })\n    })\n  });\n};\n\nMenuSub.displayName = SUB_NAME;\nvar SUB_TRIGGER_NAME = \"MenuSubTrigger\";\nvar MenuSubTrigger = React.forwardRef((props, forwardedRef) => {\n  const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n  const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n  const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n  const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n  const openTimerRef = React.useRef(null);\n  const {\n    pointerGraceTimerRef,\n    onPointerGraceIntentChange\n  } = contentContext;\n  const scope = {\n    __scopeMenu: props.__scopeMenu\n  };\n  const clearOpenTimer = React.useCallback(() => {\n    if (openTimerRef.current) window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = null;\n  }, []);\n  React.useEffect(() => clearOpenTimer, [clearOpenTimer]);\n  React.useEffect(() => {\n    const pointerGraceTimer = pointerGraceTimerRef.current;\n    return () => {\n      window.clearTimeout(pointerGraceTimer);\n      onPointerGraceIntentChange(null);\n    };\n  }, [pointerGraceTimerRef, onPointerGraceIntentChange]);\n  return /* @__PURE__ */jsx(MenuAnchor, {\n    asChild: true,\n    ...scope,\n    children: /* @__PURE__ */jsx(MenuItemImpl, {\n      id: subContext.triggerId,\n      \"aria-haspopup\": \"menu\",\n      \"aria-expanded\": context.open,\n      \"aria-controls\": subContext.contentId,\n      \"data-state\": getOpenState(context.open),\n      ...props,\n      ref: composeRefs(forwardedRef, subContext.onTriggerChange),\n      onClick: event => {\n        props.onClick?.(event);\n        if (props.disabled || event.defaultPrevented) return;\n        event.currentTarget.focus();\n        if (!context.open) context.onOpenChange(true);\n      },\n      onPointerMove: composeEventHandlers(props.onPointerMove, whenMouse(event => {\n        contentContext.onItemEnter(event);\n        if (event.defaultPrevented) return;\n\n        if (!props.disabled && !context.open && !openTimerRef.current) {\n          contentContext.onPointerGraceIntentChange(null);\n          openTimerRef.current = window.setTimeout(() => {\n            context.onOpenChange(true);\n            clearOpenTimer();\n          }, 100);\n        }\n      })),\n      onPointerLeave: composeEventHandlers(props.onPointerLeave, whenMouse(event => {\n        clearOpenTimer();\n        const contentRect = context.content?.getBoundingClientRect();\n\n        if (contentRect) {\n          const side = context.content?.dataset.side;\n          const rightSide = side === \"right\";\n          const bleed = rightSide ? -5 : 5;\n          const contentNearEdge = contentRect[rightSide ? \"left\" : \"right\"];\n          const contentFarEdge = contentRect[rightSide ? \"right\" : \"left\"];\n          contentContext.onPointerGraceIntentChange({\n            area: [// Apply a bleed on clientX to ensure that our exit point is\n            // consistently within polygon bounds\n            {\n              x: event.clientX + bleed,\n              y: event.clientY\n            }, {\n              x: contentNearEdge,\n              y: contentRect.top\n            }, {\n              x: contentFarEdge,\n              y: contentRect.top\n            }, {\n              x: contentFarEdge,\n              y: contentRect.bottom\n            }, {\n              x: contentNearEdge,\n              y: contentRect.bottom\n            }],\n            side\n          });\n          window.clearTimeout(pointerGraceTimerRef.current);\n          pointerGraceTimerRef.current = window.setTimeout(() => contentContext.onPointerGraceIntentChange(null), 300);\n        } else {\n          contentContext.onTriggerLeave(event);\n          if (event.defaultPrevented) return;\n          contentContext.onPointerGraceIntentChange(null);\n        }\n      })),\n      onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n        const isTypingAhead = contentContext.searchRef.current !== \"\";\n        if (props.disabled || isTypingAhead && event.key === \" \") return;\n\n        if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {\n          context.onOpenChange(true);\n          context.content?.focus();\n          event.preventDefault();\n        }\n      })\n    })\n  });\n});\nMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\nvar SUB_CONTENT_NAME = \"MenuSubContent\";\nvar MenuSubContent = React.forwardRef((props, forwardedRef) => {\n  const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n  const {\n    forceMount = portalContext.forceMount,\n    ...subContentProps\n  } = props;\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n  const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  return /* @__PURE__ */jsx(Collection.Provider, {\n    scope: props.__scopeMenu,\n    children: /* @__PURE__ */jsx(Presence, {\n      present: forceMount || context.open,\n      children: /* @__PURE__ */jsx(Collection.Slot, {\n        scope: props.__scopeMenu,\n        children: /* @__PURE__ */jsx(MenuContentImpl, {\n          id: subContext.contentId,\n          \"aria-labelledby\": subContext.triggerId,\n          ...subContentProps,\n          ref: composedRefs,\n          align: \"start\",\n          side: rootContext.dir === \"rtl\" ? \"left\" : \"right\",\n          disableOutsidePointerEvents: false,\n          disableOutsideScroll: false,\n          trapFocus: false,\n          onOpenAutoFocus: event => {\n            if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();\n            event.preventDefault();\n          },\n          onCloseAutoFocus: event => event.preventDefault(),\n          onFocusOutside: composeEventHandlers(props.onFocusOutside, event => {\n            if (event.target !== subContext.trigger) context.onOpenChange(false);\n          }),\n          onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, event => {\n            rootContext.onClose();\n            event.preventDefault();\n          }),\n          onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n            const isKeyDownInside = event.currentTarget.contains(event.target);\n            const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);\n\n            if (isKeyDownInside && isCloseKey) {\n              context.onOpenChange(false);\n              subContext.trigger?.focus();\n              event.preventDefault();\n            }\n          })\n        })\n      })\n    })\n  });\n});\nMenuSubContent.displayName = SUB_CONTENT_NAME;\n\nfunction getOpenState(open) {\n  return open ? \"open\" : \"closed\";\n}\n\nfunction isIndeterminate(checked) {\n  return checked === \"indeterminate\";\n}\n\nfunction getCheckedState(checked) {\n  return isIndeterminate(checked) ? \"indeterminate\" : checked ? \"checked\" : \"unchecked\";\n}\n\nfunction focusFirst(candidates) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n\n  for (const candidate of candidates) {\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\nfunction wrapArray(array, startIndex) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nfunction getNextMatch(values, search, currentMatch) {\n  const isRepeated = search.length > 1 && Array.from(search).every(char => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter(v => v !== currentMatch);\n  const nextMatch = wrappedValues.find(value => value.toLowerCase().startsWith(normalizedSearch.toLowerCase()));\n  return nextMatch !== currentMatch ? nextMatch : void 0;\n}\n\nfunction isPointInPolygon(point, polygon) {\n  const {\n    x,\n    y\n  } = point;\n  let inside = false;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\nfunction isPointerInGraceArea(event, area) {\n  if (!area) return false;\n  const cursorPos = {\n    x: event.clientX,\n    y: event.clientY\n  };\n  return isPointInPolygon(cursorPos, area);\n}\n\nfunction whenMouse(handler) {\n  return event => event.pointerType === \"mouse\" ? handler(event) : void 0;\n}\n\nvar Root3 = Menu;\nvar Anchor2 = MenuAnchor;\nvar Portal = MenuPortal;\nvar Content2 = MenuContent;\nvar Group = MenuGroup;\nvar Label = MenuLabel;\nvar Item2 = MenuItem;\nvar CheckboxItem = MenuCheckboxItem;\nvar RadioGroup = MenuRadioGroup;\nvar RadioItem = MenuRadioItem;\nvar ItemIndicator = MenuItemIndicator;\nvar Separator = MenuSeparator;\nvar Arrow2 = MenuArrow;\nvar Sub = MenuSub;\nvar SubTrigger = MenuSubTrigger;\nvar SubContent = MenuSubContent;\nexport { Anchor2 as Anchor, Arrow2 as Arrow, CheckboxItem, Content2 as Content, Group, Item2 as Item, ItemIndicator, Label, Menu, MenuAnchor, MenuArrow, MenuCheckboxItem, MenuContent, MenuGroup, MenuItem, MenuItemIndicator, MenuLabel, MenuPortal, MenuRadioGroup, MenuRadioItem, MenuSeparator, MenuSub, MenuSubContent, MenuSubTrigger, Portal, RadioGroup, RadioItem, Root3 as Root, Separator, Sub, SubContent, SubTrigger, createMenuScope };","map":{"version":3,"mappings":"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","names":["React","composeEventHandlers","createCollection","useComposedRefs","composeRefs","createContextScope","useDirection","DismissableLayer","useFocusGuards","FocusScope","useId","PopperPrimitive","createPopperScope","Portal","PortalPrimitive","Presence","Primitive","dispatchDiscreteCustomEvent","RovingFocusGroup","createRovingFocusGroupScope","Slot","useCallbackRef","hideOthers","RemoveScroll","SELECTION_KEYS","FIRST_KEYS","LAST_KEYS","FIRST_LAST_KEYS","SUB_OPEN_KEYS","ltr","rtl","SUB_CLOSE_KEYS","MENU_NAME","Collection","useCollection","createCollectionScope","createMenuContext","createMenuScope","usePopperScope","useRovingFocusGroupScope","MenuProvider","useMenuContext","MenuRootProvider","useMenuRootContext","Menu","props","__scopeMenu","open","children","dir","onOpenChange","modal","popperScope","content","setContent","isUsingKeyboardRef","handleOpenChange","direction","handleKeyDown","current","document","addEventListener","handlePointer","capture","once","removeEventListener","scope","onContentChange","onClose","displayName","ANCHOR_NAME","MenuAnchor","forwardedRef","anchorProps","ref","PORTAL_NAME","PortalProvider","usePortalContext","forceMount","MenuPortal","container","context","present","asChild","CONTENT_NAME","MenuContentProvider","useMenuContentContext","MenuContent","portalContext","contentProps","rootContext","Provider","MenuRootContentModal","MenuRootContentNonModal","composedRefs","MenuContentImpl","trapFocus","disableOutsidePointerEvents","disableOutsideScroll","onFocusOutside","event","preventDefault","checkForDefaultPrevented","onDismiss","loop","onOpenAutoFocus","onCloseAutoFocus","onEntryFocus","onEscapeKeyDown","onPointerDownOutside","onInteractOutside","rovingFocusGroupScope","getItems","currentItemId","setCurrentItemId","contentRef","timerRef","searchRef","pointerGraceTimerRef","pointerGraceIntentRef","pointerDirRef","lastPointerXRef","ScrollLockWrapper","scrollLockWrapperProps","as","allowPinchZoom","handleTypeaheadSearch","key","search","items","filter","item","disabled","currentItem","activeElement","currentMatch","find","textValue","values","map","nextMatch","getNextMatch","newItem","updateSearch","value","window","clearTimeout","setTimeout","focus","isPointerMovingToSubmenu","isMovingTowards","side","isPointerInGraceArea","area","onItemEnter","onItemLeave","onTriggerLeave","onPointerGraceIntentChange","intent","trapped","onMountAutoFocus","preventScroll","onUnmountAutoFocus","orientation","currentTabStopId","onCurrentTabStopIdChange","preventScrollOnEntryFocus","role","getOpenState","style","outline","onKeyDown","target","isKeyDownInside","closest","currentTarget","isModifierKey","ctrlKey","altKey","metaKey","isCharacterKey","length","includes","candidateNodes","reverse","focusFirst","onBlur","contains","onPointerMove","whenMouse","pointerXHasChanged","clientX","newDir","GROUP_NAME","MenuGroup","groupProps","div","LABEL_NAME","MenuLabel","labelProps","ITEM_NAME","ITEM_SELECT","MenuItem","onSelect","itemProps","contentContext","isPointerDownRef","handleSelect","menuItem","itemSelectEvent","CustomEvent","bubbles","cancelable","defaultPrevented","MenuItemImpl","onClick","onPointerDown","onPointerUp","click","isTypingAhead","isFocused","setIsFocused","textContent","setTextContent","trim","ItemSlot","focusable","onPointerLeave","onFocus","CHECKBOX_ITEM_NAME","MenuCheckboxItem","checked","onCheckedChange","checkboxItemProps","ItemIndicatorProvider","isIndeterminate","getCheckedState","RADIO_GROUP_NAME","RadioGroupProvider","useRadioGroupContext","onValueChange","MenuRadioGroup","handleValueChange","RADIO_ITEM_NAME","MenuRadioItem","radioItemProps","ITEM_INDICATOR_NAME","useItemIndicatorContext","MenuItemIndicator","itemIndicatorProps","indicatorContext","span","SEPARATOR_NAME","MenuSeparator","separatorProps","ARROW_NAME","MenuArrow","arrowProps","SUB_NAME","MenuSubProvider","useMenuSubContext","MenuSub","parentMenuContext","trigger","setTrigger","contentId","triggerId","onTriggerChange","SUB_TRIGGER_NAME","MenuSubTrigger","subContext","openTimerRef","clearOpenTimer","pointerGraceTimer","id","contentRect","getBoundingClientRect","dataset","rightSide","bleed","contentNearEdge","contentFarEdge","x","y","clientY","top","bottom","SUB_CONTENT_NAME","MenuSubContent","subContentProps","align","isCloseKey","candidates","PREVIOUSLY_FOCUSED_ELEMENT","candidate","wrapArray","array","startIndex","_","index","isRepeated","Array","from","every","char","normalizedSearch","currentMatchIndex","indexOf","wrappedValues","Math","max","excludeCurrentMatch","v","toLowerCase","startsWith","isPointInPolygon","point","polygon","inside","i","j","xi","yi","xj","yj","intersect","cursorPos","handler","pointerType","Root","Anchor","Content","Group","Label","Item","CheckboxItem","RadioGroup","RadioItem","ItemIndicator","Separator","Arrow","Sub","SubTrigger","SubContent"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-menu/src/Menu.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs, composeRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { useId } from '@radix-ui/react-id';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { Slot } from '@radix-ui/react-slot';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { hideOthers } from 'aria-hidden';\nimport { RemoveScroll } from 'react-remove-scroll';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst SELECTION_KEYS = ['Enter', ' '];\nconst FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home'];\nconst LAST_KEYS = ['ArrowUp', 'PageDown', 'End'];\nconst FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nconst SUB_OPEN_KEYS: Record<Direction, string[]> = {\n  ltr: [...SELECTION_KEYS, 'ArrowRight'],\n  rtl: [...SELECTION_KEYS, 'ArrowLeft'],\n};\nconst SUB_CLOSE_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowLeft'],\n  rtl: ['ArrowRight'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Menu\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENU_NAME = 'Menu';\n\ntype ItemData = { disabled: boolean; textValue: string };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  MenuItemElement,\n  ItemData\n>(MENU_NAME);\n\ntype ScopedProps<P> = P & { __scopeMenu?: Scope };\nconst [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [\n  createCollectionScope,\n  createPopperScope,\n  createRovingFocusGroupScope,\n]);\nconst usePopperScope = createPopperScope();\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype MenuContextValue = {\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  content: MenuContentElement | null;\n  onContentChange(content: MenuContentElement | null): void;\n};\n\nconst [MenuProvider, useMenuContext] = createMenuContext<MenuContextValue>(MENU_NAME);\n\ntype MenuRootContextValue = {\n  onClose(): void;\n  isUsingKeyboardRef: React.RefObject<boolean>;\n  dir: Direction;\n  modal: boolean;\n};\n\nconst [MenuRootProvider, useMenuRootContext] = createMenuContext<MenuRootContextValue>(MENU_NAME);\n\ninterface MenuProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n  dir?: Direction;\n  modal?: boolean;\n}\n\nconst Menu: React.FC<MenuProps> = (props: ScopedProps<MenuProps>) => {\n  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const isUsingKeyboardRef = React.useRef(false);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  const direction = useDirection(dir);\n\n  React.useEffect(() => {\n    // Capture phase ensures we set the boolean before any side effects execute\n    // in response to the key or pointer event as they might depend on this value.\n    const handleKeyDown = () => {\n      isUsingKeyboardRef.current = true;\n      document.addEventListener('pointerdown', handlePointer, { capture: true, once: true });\n      document.addEventListener('pointermove', handlePointer, { capture: true, once: true });\n    };\n    const handlePointer = () => (isUsingKeyboardRef.current = false);\n    document.addEventListener('keydown', handleKeyDown, { capture: true });\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown, { capture: true });\n      document.removeEventListener('pointerdown', handlePointer, { capture: true });\n      document.removeEventListener('pointermove', handlePointer, { capture: true });\n    };\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuRootProvider\n          scope={__scopeMenu}\n          onClose={React.useCallback(() => handleOpenChange(false), [handleOpenChange])}\n          isUsingKeyboardRef={isUsingKeyboardRef}\n          dir={direction}\n          modal={modal}\n        >\n          {children}\n        </MenuRootProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenu.displayName = MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'MenuAnchor';\n\ntype MenuAnchorElement = React.ElementRef<typeof PopperPrimitive.Anchor>;\ntype PopperAnchorProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Anchor>;\ninterface MenuAnchorProps extends PopperAnchorProps {}\n\nconst MenuAnchor = React.forwardRef<MenuAnchorElement, MenuAnchorProps>(\n  (props: ScopedProps<MenuAnchorProps>, forwardedRef) => {\n    const { __scopeMenu, ...anchorProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Anchor {...popperScope} {...anchorProps} ref={forwardedRef} />;\n  }\n);\n\nMenuAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'MenuPortal';\n\ntype PortalContextValue = { forceMount?: true };\nconst [PortalProvider, usePortalContext] = createMenuContext<PortalContextValue>(PORTAL_NAME, {\n  forceMount: undefined,\n});\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface MenuPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuPortal: React.FC<MenuPortalProps> = (props: ScopedProps<MenuPortalProps>) => {\n  const { __scopeMenu, forceMount, children, container } = props;\n  const context = useMenuContext(PORTAL_NAME, __scopeMenu);\n  return (\n    <PortalProvider scope={__scopeMenu} forceMount={forceMount}>\n      <Presence present={forceMount || context.open}>\n        <PortalPrimitive asChild container={container}>\n          {children}\n        </PortalPrimitive>\n      </Presence>\n    </PortalProvider>\n  );\n};\n\nMenuPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'MenuContent';\n\ntype MenuContentContextValue = {\n  onItemEnter(event: React.PointerEvent): void;\n  onItemLeave(event: React.PointerEvent): void;\n  onTriggerLeave(event: React.PointerEvent): void;\n  searchRef: React.RefObject<string>;\n  pointerGraceTimerRef: React.MutableRefObject<number>;\n  onPointerGraceIntentChange(intent: GraceIntent | null): void;\n};\nconst [MenuContentProvider, useMenuContentContext] =\n  createMenuContext<MenuContentContextValue>(CONTENT_NAME);\n\ntype MenuContentElement = MenuRootContentTypeElement;\n/**\n * We purposefully don't union MenuRootContent and MenuSubContent props here because\n * they have conflicting prop types. We agreed that we would allow MenuSubContent to\n * accept props that it would just ignore.\n */\ninterface MenuContentProps extends MenuRootContentTypeProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuContent = React.forwardRef<MenuContentElement, MenuContentProps>(\n  (props: ScopedProps<MenuContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...contentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            {rootContext.modal ? (\n              <MenuRootContentModal {...contentProps} ref={forwardedRef} />\n            ) : (\n              <MenuRootContentNonModal {...contentProps} ref={forwardedRef} />\n            )}\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuRootContentTypeElement = MenuContentImplElement;\ninterface MenuRootContentTypeProps\n  extends Omit<MenuContentImplProps, keyof MenuContentImplPrivateProps> {}\n\nconst MenuRootContentModal = React.forwardRef<MenuRootContentTypeElement, MenuRootContentTypeProps>(\n  (props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuRootContentTypeElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    // Hide everything from ARIA except the `MenuContent`\n    React.useEffect(() => {\n      const content = ref.current;\n      if (content) return hideOthers(content);\n    }, []);\n\n    return (\n      <MenuContentImpl\n        {...props}\n        ref={composedRefs}\n        // we make sure we're not trapping once it's been closed\n        // (closed !== unmounted when animating out)\n        trapFocus={context.open}\n        // make sure to only disable pointer events when open\n        // this avoids blocking interactions while animating out\n        disableOutsidePointerEvents={context.open}\n        disableOutsideScroll\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        onFocusOutside={composeEventHandlers(\n          props.onFocusOutside,\n          (event) => event.preventDefault(),\n          { checkForDefaultPrevented: false }\n        )}\n        onDismiss={() => context.onOpenChange(false)}\n      />\n    );\n  }\n);\n\nconst MenuRootContentNonModal = React.forwardRef<\n  MenuRootContentTypeElement,\n  MenuRootContentTypeProps\n>((props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  return (\n    <MenuContentImpl\n      {...props}\n      ref={forwardedRef}\n      trapFocus={false}\n      disableOutsidePointerEvents={false}\n      disableOutsideScroll={false}\n      onDismiss={() => context.onOpenChange(false)}\n    />\n  );\n});\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype FocusScopeProps = React.ComponentPropsWithoutRef<typeof FocusScope>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype RovingFocusGroupProps = React.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PopperContentProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ntype MenuContentImplPrivateProps = {\n  onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n  onDismiss?: DismissableLayerProps['onDismiss'];\n  disableOutsidePointerEvents?: DismissableLayerProps['disableOutsidePointerEvents'];\n\n  /**\n   * Whether scrolling outside the `MenuContent` should be prevented\n   * (default: `false`)\n   */\n  disableOutsideScroll?: boolean;\n\n  /**\n   * Whether focus should be trapped within the `MenuContent`\n   * (default: false)\n   */\n  trapFocus?: FocusScopeProps['trapped'];\n};\ninterface MenuContentImplProps\n  extends MenuContentImplPrivateProps,\n    Omit<PopperContentProps, 'dir' | 'onPlaced'> {\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: RovingFocusGroupProps['loop'];\n\n  onEntryFocus?: RovingFocusGroupProps['onEntryFocus'];\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n  onFocusOutside?: DismissableLayerProps['onFocusOutside'];\n  onInteractOutside?: DismissableLayerProps['onInteractOutside'];\n}\n\nconst MenuContentImpl = React.forwardRef<MenuContentImplElement, MenuContentImplProps>(\n  (props: ScopedProps<MenuContentImplProps>, forwardedRef) => {\n    const {\n      __scopeMenu,\n      loop = false,\n      trapFocus,\n      onOpenAutoFocus,\n      onCloseAutoFocus,\n      disableOutsidePointerEvents,\n      onEntryFocus,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      disableOutsideScroll,\n      ...contentProps\n    } = props;\n    const context = useMenuContext(CONTENT_NAME, __scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, __scopeMenu);\n    const popperScope = usePopperScope(__scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const getItems = useCollection(__scopeMenu);\n    const [currentItemId, setCurrentItemId] = React.useState<string | null>(null);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);\n    const timerRef = React.useRef(0);\n    const searchRef = React.useRef('');\n    const pointerGraceTimerRef = React.useRef(0);\n    const pointerGraceIntentRef = React.useRef<GraceIntent | null>(null);\n    const pointerDirRef = React.useRef<Side>('right');\n    const lastPointerXRef = React.useRef(0);\n\n    const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n    const scrollLockWrapperProps = disableOutsideScroll\n      ? { as: Slot, allowPinchZoom: true }\n      : undefined;\n\n    const handleTypeaheadSearch = (key: string) => {\n      const search = searchRef.current + key;\n      const items = getItems().filter((item) => !item.disabled);\n      const currentItem = document.activeElement;\n      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;\n      const values = items.map((item) => item.textValue);\n      const nextMatch = getNextMatch(values, search, currentMatch);\n      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;\n\n      // Reset `searchRef` 1 second after it was last updated\n      (function updateSearch(value: string) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1000);\n      })(search);\n\n      if (newItem) {\n        /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */\n        setTimeout(() => (newItem as HTMLElement).focus());\n      }\n    };\n\n    React.useEffect(() => {\n      return () => window.clearTimeout(timerRef.current);\n    }, []);\n\n    // Make sure the whole tree has focus guards as our `MenuContent` may be\n    // the last element in the DOM (because of the `Portal`)\n    useFocusGuards();\n\n    const isPointerMovingToSubmenu = React.useCallback((event: React.PointerEvent) => {\n      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;\n      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);\n    }, []);\n\n    return (\n      <MenuContentProvider\n        scope={__scopeMenu}\n        searchRef={searchRef}\n        onItemEnter={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onItemLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) return;\n            contentRef.current?.focus();\n            setCurrentItemId(null);\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onTriggerLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        pointerGraceTimerRef={pointerGraceTimerRef}\n        onPointerGraceIntentChange={React.useCallback((intent) => {\n          pointerGraceIntentRef.current = intent;\n        }, [])}\n      >\n        <ScrollLockWrapper {...scrollLockWrapperProps}>\n          <FocusScope\n            asChild\n            trapped={trapFocus}\n            onMountAutoFocus={composeEventHandlers(onOpenAutoFocus, (event) => {\n              // when opening, explicitly focus the content area only and leave\n              // `onEntryFocus` in  control of focusing first item\n              event.preventDefault();\n              contentRef.current?.focus({ preventScroll: true });\n            })}\n            onUnmountAutoFocus={onCloseAutoFocus}\n          >\n            <DismissableLayer\n              asChild\n              disableOutsidePointerEvents={disableOutsidePointerEvents}\n              onEscapeKeyDown={onEscapeKeyDown}\n              onPointerDownOutside={onPointerDownOutside}\n              onFocusOutside={onFocusOutside}\n              onInteractOutside={onInteractOutside}\n              onDismiss={onDismiss}\n            >\n              <RovingFocusGroup.Root\n                asChild\n                {...rovingFocusGroupScope}\n                dir={rootContext.dir}\n                orientation=\"vertical\"\n                loop={loop}\n                currentTabStopId={currentItemId}\n                onCurrentTabStopIdChange={setCurrentItemId}\n                onEntryFocus={composeEventHandlers(onEntryFocus, (event) => {\n                  // only focus first item when using keyboard\n                  if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();\n                })}\n                preventScrollOnEntryFocus\n              >\n                <PopperPrimitive.Content\n                  role=\"menu\"\n                  aria-orientation=\"vertical\"\n                  data-state={getOpenState(context.open)}\n                  data-radix-menu-content=\"\"\n                  dir={rootContext.dir}\n                  {...popperScope}\n                  {...contentProps}\n                  ref={composedRefs}\n                  style={{ outline: 'none', ...contentProps.style }}\n                  onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                    // submenu key events bubble through portals. We only care about keys in this menu.\n                    const target = event.target as HTMLElement;\n                    const isKeyDownInside =\n                      target.closest('[data-radix-menu-content]') === event.currentTarget;\n                    const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                    const isCharacterKey = event.key.length === 1;\n                    if (isKeyDownInside) {\n                      // menus should not be navigated using tab key so we prevent it\n                      if (event.key === 'Tab') event.preventDefault();\n                      if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);\n                    }\n                    // focus first/last item based on key pressed\n                    const content = contentRef.current;\n                    if (event.target !== content) return;\n                    if (!FIRST_LAST_KEYS.includes(event.key)) return;\n                    event.preventDefault();\n                    const items = getItems().filter((item) => !item.disabled);\n                    const candidateNodes = items.map((item) => item.ref.current!);\n                    if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                    focusFirst(candidateNodes);\n                  })}\n                  onBlur={composeEventHandlers(props.onBlur, (event) => {\n                    // clear search buffer when leaving the menu\n                    if (!event.currentTarget.contains(event.target)) {\n                      window.clearTimeout(timerRef.current);\n                      searchRef.current = '';\n                    }\n                  })}\n                  onPointerMove={composeEventHandlers(\n                    props.onPointerMove,\n                    whenMouse((event) => {\n                      const target = event.target as HTMLElement;\n                      const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n\n                      // We don't use `event.movementX` for this check because Safari will\n                      // always return `0` on a pointer event.\n                      if (event.currentTarget.contains(target) && pointerXHasChanged) {\n                        const newDir = event.clientX > lastPointerXRef.current ? 'right' : 'left';\n                        pointerDirRef.current = newDir;\n                        lastPointerXRef.current = event.clientX;\n                      }\n                    })\n                  )}\n                />\n              </RovingFocusGroup.Root>\n            </DismissableLayer>\n          </FocusScope>\n        </ScrollLockWrapper>\n      </MenuContentProvider>\n    );\n  }\n);\n\nMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'MenuGroup';\n\ntype MenuGroupElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface MenuGroupProps extends PrimitiveDivProps {}\n\nconst MenuGroup = React.forwardRef<MenuGroupElement, MenuGroupProps>(\n  (props: ScopedProps<MenuGroupProps>, forwardedRef) => {\n    const { __scopeMenu, ...groupProps } = props;\n    return <Primitive.div role=\"group\" {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nMenuGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'MenuLabel';\n\ntype MenuLabelElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuLabelProps extends PrimitiveDivProps {}\n\nconst MenuLabel = React.forwardRef<MenuLabelElement, MenuLabelProps>(\n  (props: ScopedProps<MenuLabelProps>, forwardedRef) => {\n    const { __scopeMenu, ...labelProps } = props;\n    return <Primitive.div {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nMenuLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'MenuItem';\nconst ITEM_SELECT = 'menu.itemSelect';\n\ntype MenuItemElement = MenuItemImplElement;\ninterface MenuItemProps extends Omit<MenuItemImplProps, 'onSelect'> {\n  onSelect?: (event: Event) => void;\n}\n\nconst MenuItem = React.forwardRef<MenuItemElement, MenuItemProps>(\n  (props: ScopedProps<MenuItemProps>, forwardedRef) => {\n    const { disabled = false, onSelect, ...itemProps } = props;\n    const ref = React.useRef<HTMLDivElement>(null);\n    const rootContext = useMenuRootContext(ITEM_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(ITEM_NAME, props.__scopeMenu);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const isPointerDownRef = React.useRef(false);\n\n    const handleSelect = () => {\n      const menuItem = ref.current;\n      if (!disabled && menuItem) {\n        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });\n        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });\n        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);\n        if (itemSelectEvent.defaultPrevented) {\n          isPointerDownRef.current = false;\n        } else {\n          rootContext.onClose();\n        }\n      }\n    };\n\n    return (\n      <MenuItemImpl\n        {...itemProps}\n        ref={composedRefs}\n        disabled={disabled}\n        onClick={composeEventHandlers(props.onClick, handleSelect)}\n        onPointerDown={(event) => {\n          props.onPointerDown?.(event);\n          isPointerDownRef.current = true;\n        }}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          // Pointer down can move to a different menu item which should activate it on pointer up.\n          // We dispatch a click for selection to allow composition with click based triggers and to\n          // prevent Firefox from getting stuck in text selection mode when the menu closes.\n          if (!isPointerDownRef.current) event.currentTarget?.click();\n        })}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          const isTypingAhead = contentContext.searchRef.current !== '';\n          if (disabled || (isTypingAhead && event.key === ' ')) return;\n          if (SELECTION_KEYS.includes(event.key)) {\n            event.currentTarget.click();\n            /**\n             * We prevent default browser behaviour for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            event.preventDefault();\n          }\n        })}\n      />\n    );\n  }\n);\n\nMenuItem.displayName = ITEM_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuItemImplElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuItemImplProps extends PrimitiveDivProps {\n  disabled?: boolean;\n  textValue?: string;\n}\n\nconst MenuItemImpl = React.forwardRef<MenuItemImplElement, MenuItemImplProps>(\n  (props: ScopedProps<MenuItemImplProps>, forwardedRef) => {\n    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;\n    const contentContext = useMenuContentContext(ITEM_NAME, __scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const ref = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const [isFocused, setIsFocused] = React.useState(false);\n\n    // get the item's `.textContent` as default strategy for typeahead `textValue`\n    const [textContent, setTextContent] = React.useState('');\n    React.useEffect(() => {\n      const menuItem = ref.current;\n      if (menuItem) {\n        setTextContent((menuItem.textContent ?? '').trim());\n      }\n    }, [itemProps.children]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeMenu}\n        disabled={disabled}\n        textValue={textValue ?? textContent}\n      >\n        <RovingFocusGroup.Item asChild {...rovingFocusGroupScope} focusable={!disabled}>\n          <Primitive.div\n            role=\"menuitem\"\n            data-highlighted={isFocused ? '' : undefined}\n            aria-disabled={disabled || undefined}\n            data-disabled={disabled ? '' : undefined}\n            {...itemProps}\n            ref={composedRefs}\n            /**\n             * We focus items on `pointerMove` to achieve the following:\n             *\n             * - Mouse over an item (it focuses)\n             * - Leave mouse where it is and use keyboard to focus a different item\n             * - Wiggle mouse without it leaving previously focused item\n             * - Previously focused item should re-focus\n             *\n             * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse\n             * wiggles. This is to match native menu implementation.\n             */\n            onPointerMove={composeEventHandlers(\n              props.onPointerMove,\n              whenMouse((event) => {\n                if (disabled) {\n                  contentContext.onItemLeave(event);\n                } else {\n                  contentContext.onItemEnter(event);\n                  if (!event.defaultPrevented) {\n                    const item = event.currentTarget;\n                    item.focus({ preventScroll: true });\n                  }\n                }\n              })\n            )}\n            onPointerLeave={composeEventHandlers(\n              props.onPointerLeave,\n              whenMouse((event) => contentContext.onItemLeave(event))\n            )}\n            onFocus={composeEventHandlers(props.onFocus, () => setIsFocused(true))}\n            onBlur={composeEventHandlers(props.onBlur, () => setIsFocused(false))}\n          />\n        </RovingFocusGroup.Item>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * MenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'MenuCheckboxItem';\n\ntype MenuCheckboxItemElement = MenuItemElement;\n\ntype CheckedState = boolean | 'indeterminate';\n\ninterface MenuCheckboxItemProps extends MenuItemProps {\n  checked?: CheckedState;\n  // `onCheckedChange` can never be called with `\"indeterminate\"` from the inside\n  onCheckedChange?: (checked: boolean) => void;\n}\n\nconst MenuCheckboxItem = React.forwardRef<MenuCheckboxItemElement, MenuCheckboxItemProps>(\n  (props: ScopedProps<MenuCheckboxItemProps>, forwardedRef) => {\n    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemcheckbox\"\n          aria-checked={isIndeterminate(checked) ? 'mixed' : checked}\n          {...checkboxItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            checkboxItemProps.onSelect,\n            () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'MenuRadioGroup';\n\nconst [RadioGroupProvider, useRadioGroupContext] = createMenuContext<MenuRadioGroupProps>(\n  RADIO_GROUP_NAME,\n  { value: undefined, onValueChange: () => {} }\n);\n\ntype MenuRadioGroupElement = React.ElementRef<typeof MenuGroup>;\ninterface MenuRadioGroupProps extends MenuGroupProps {\n  value?: string;\n  onValueChange?: (value: string) => void;\n}\n\nconst MenuRadioGroup = React.forwardRef<MenuRadioGroupElement, MenuRadioGroupProps>(\n  (props: ScopedProps<MenuRadioGroupProps>, forwardedRef) => {\n    const { value, onValueChange, ...groupProps } = props;\n    const handleValueChange = useCallbackRef(onValueChange);\n    return (\n      <RadioGroupProvider scope={props.__scopeMenu} value={value} onValueChange={handleValueChange}>\n        <MenuGroup {...groupProps} ref={forwardedRef} />\n      </RadioGroupProvider>\n    );\n  }\n);\n\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'MenuRadioItem';\n\ntype MenuRadioItemElement = React.ElementRef<typeof MenuItem>;\ninterface MenuRadioItemProps extends MenuItemProps {\n  value: string;\n}\n\nconst MenuRadioItem = React.forwardRef<MenuRadioItemElement, MenuRadioItemProps>(\n  (props: ScopedProps<MenuRadioItemProps>, forwardedRef) => {\n    const { value, ...radioItemProps } = props;\n    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);\n    const checked = value === context.value;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemradio\"\n          aria-checked={checked}\n          {...radioItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            radioItemProps.onSelect,\n            () => context.onValueChange?.(value),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'MenuItemIndicator';\n\ntype CheckboxContextValue = { checked: CheckedState };\n\nconst [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext<CheckboxContextValue>(\n  ITEM_INDICATOR_NAME,\n  { checked: false }\n);\n\ntype MenuItemIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface MenuItemIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuItemIndicator = React.forwardRef<MenuItemIndicatorElement, MenuItemIndicatorProps>(\n  (props: ScopedProps<MenuItemIndicatorProps>, forwardedRef) => {\n    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;\n    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);\n    return (\n      <Presence\n        present={\n          forceMount ||\n          isIndeterminate(indicatorContext.checked) ||\n          indicatorContext.checked === true\n        }\n      >\n        <Primitive.span\n          {...itemIndicatorProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(indicatorContext.checked)}\n        />\n      </Presence>\n    );\n  }\n);\n\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'MenuSeparator';\n\ntype MenuSeparatorElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuSeparatorProps extends PrimitiveDivProps {}\n\nconst MenuSeparator = React.forwardRef<MenuSeparatorElement, MenuSeparatorProps>(\n  (props: ScopedProps<MenuSeparatorProps>, forwardedRef) => {\n    const { __scopeMenu, ...separatorProps } = props;\n    return (\n      <Primitive.div\n        role=\"separator\"\n        aria-orientation=\"horizontal\"\n        {...separatorProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nMenuSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'MenuArrow';\n\ntype MenuArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface MenuArrowProps extends PopperArrowProps {}\n\nconst MenuArrow = React.forwardRef<MenuArrowElement, MenuArrowProps>(\n  (props: ScopedProps<MenuArrowProps>, forwardedRef) => {\n    const { __scopeMenu, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nMenuArrow.displayName = ARROW_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSub\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_NAME = 'MenuSub';\n\ntype MenuSubContextValue = {\n  contentId: string;\n  triggerId: string;\n  trigger: MenuSubTriggerElement | null;\n  onTriggerChange(trigger: MenuSubTriggerElement | null): void;\n};\n\nconst [MenuSubProvider, useMenuSubContext] = createMenuContext<MenuSubContextValue>(SUB_NAME);\n\ninterface MenuSubProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n}\n\nconst MenuSub: React.FC<MenuSubProps> = (props: ScopedProps<MenuSubProps>) => {\n  const { __scopeMenu, children, open = false, onOpenChange } = props;\n  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = React.useState<MenuSubTriggerElement | null>(null);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n\n  // Prevent the parent menu from reopening with open submenus.\n  React.useEffect(() => {\n    if (parentMenuContext.open === false) handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [parentMenuContext.open, handleOpenChange]);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuSubProvider\n          scope={__scopeMenu}\n          contentId={useId()}\n          triggerId={useId()}\n          trigger={trigger}\n          onTriggerChange={setTrigger}\n        >\n          {children}\n        </MenuSubProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenuSub.displayName = SUB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_TRIGGER_NAME = 'MenuSubTrigger';\n\ntype MenuSubTriggerElement = MenuItemImplElement;\ninterface MenuSubTriggerProps extends MenuItemImplProps {}\n\nconst MenuSubTrigger = React.forwardRef<MenuSubTriggerElement, MenuSubTriggerProps>(\n  (props: ScopedProps<MenuSubTriggerProps>, forwardedRef) => {\n    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const openTimerRef = React.useRef<number | null>(null);\n    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;\n    const scope = { __scopeMenu: props.__scopeMenu };\n\n    const clearOpenTimer = React.useCallback(() => {\n      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);\n      openTimerRef.current = null;\n    }, []);\n\n    React.useEffect(() => clearOpenTimer, [clearOpenTimer]);\n\n    React.useEffect(() => {\n      const pointerGraceTimer = pointerGraceTimerRef.current;\n      return () => {\n        window.clearTimeout(pointerGraceTimer);\n        onPointerGraceIntentChange(null);\n      };\n    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);\n\n    return (\n      <MenuAnchor asChild {...scope}>\n        <MenuItemImpl\n          id={subContext.triggerId}\n          aria-haspopup=\"menu\"\n          aria-expanded={context.open}\n          aria-controls={subContext.contentId}\n          data-state={getOpenState(context.open)}\n          {...props}\n          ref={composeRefs(forwardedRef, subContext.onTriggerChange)}\n          // This is redundant for mouse users but we cannot determine pointer type from\n          // click event and we cannot use pointerup event (see git history for reasons why)\n          onClick={(event) => {\n            props.onClick?.(event);\n            if (props.disabled || event.defaultPrevented) return;\n            /**\n             * We manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n             * and we rely heavily on `onFocusOutside` for submenus to close when switching\n             * between separate submenus.\n             */\n            event.currentTarget.focus();\n            if (!context.open) context.onOpenChange(true);\n          }}\n          onPointerMove={composeEventHandlers(\n            props.onPointerMove,\n            whenMouse((event) => {\n              contentContext.onItemEnter(event);\n              if (event.defaultPrevented) return;\n              if (!props.disabled && !context.open && !openTimerRef.current) {\n                contentContext.onPointerGraceIntentChange(null);\n                openTimerRef.current = window.setTimeout(() => {\n                  context.onOpenChange(true);\n                  clearOpenTimer();\n                }, 100);\n              }\n            })\n          )}\n          onPointerLeave={composeEventHandlers(\n            props.onPointerLeave,\n            whenMouse((event) => {\n              clearOpenTimer();\n\n              const contentRect = context.content?.getBoundingClientRect();\n              if (contentRect) {\n                // TODO: make sure to update this when we change positioning logic\n                const side = context.content?.dataset.side as Side;\n                const rightSide = side === 'right';\n                const bleed = rightSide ? -5 : +5;\n                const contentNearEdge = contentRect[rightSide ? 'left' : 'right'];\n                const contentFarEdge = contentRect[rightSide ? 'right' : 'left'];\n\n                contentContext.onPointerGraceIntentChange({\n                  area: [\n                    // Apply a bleed on clientX to ensure that our exit point is\n                    // consistently within polygon bounds\n                    { x: event.clientX + bleed, y: event.clientY },\n                    { x: contentNearEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.bottom },\n                    { x: contentNearEdge, y: contentRect.bottom },\n                  ],\n                  side,\n                });\n\n                window.clearTimeout(pointerGraceTimerRef.current);\n                pointerGraceTimerRef.current = window.setTimeout(\n                  () => contentContext.onPointerGraceIntentChange(null),\n                  300\n                );\n              } else {\n                contentContext.onTriggerLeave(event);\n                if (event.defaultPrevented) return;\n\n                // There's 100ms where the user may leave an item before the submenu was opened.\n                contentContext.onPointerGraceIntentChange(null);\n              }\n            })\n          )}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            const isTypingAhead = contentContext.searchRef.current !== '';\n            if (props.disabled || (isTypingAhead && event.key === ' ')) return;\n            if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {\n              context.onOpenChange(true);\n              // The trigger may hold focus if opened via pointer interaction\n              // so we ensure content is given focus again when switching to keyboard.\n              context.content?.focus();\n              // prevent window from scrolling\n              event.preventDefault();\n            }\n          })}\n        />\n      </MenuAnchor>\n    );\n  }\n);\n\nMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_CONTENT_NAME = 'MenuSubContent';\n\ntype MenuSubContentElement = MenuContentImplElement;\ninterface MenuSubContentProps\n  extends Omit<\n    MenuContentImplProps,\n    keyof MenuContentImplPrivateProps | 'onCloseAutoFocus' | 'onEntryFocus' | 'side' | 'align'\n  > {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuSubContent = React.forwardRef<MenuSubContentElement, MenuSubContentProps>(\n  (props: ScopedProps<MenuSubContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...subContentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuSubContentElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            <MenuContentImpl\n              id={subContext.contentId}\n              aria-labelledby={subContext.triggerId}\n              {...subContentProps}\n              ref={composedRefs}\n              align=\"start\"\n              side={rootContext.dir === 'rtl' ? 'left' : 'right'}\n              disableOutsidePointerEvents={false}\n              disableOutsideScroll={false}\n              trapFocus={false}\n              onOpenAutoFocus={(event) => {\n                // when opening a submenu, focus content for keyboard users only\n                if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();\n                event.preventDefault();\n              }}\n              // The menu might close because of focusing another menu item in the parent menu. We\n              // don't want it to refocus the trigger in that case so we handle trigger focus ourselves.\n              onCloseAutoFocus={(event) => event.preventDefault()}\n              onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n                // We prevent closing when the trigger is focused to avoid triggering a re-open animation\n                // on pointer interaction.\n                if (event.target !== subContext.trigger) context.onOpenChange(false);\n              })}\n              onEscapeKeyDown={composeEventHandlers(props.onEscapeKeyDown, (event) => {\n                rootContext.onClose();\n                // ensure pressing escape in submenu doesn't escape full screen mode\n                event.preventDefault();\n              })}\n              onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                // Submenu key events bubble through portals. We only care about keys in this menu.\n                const isKeyDownInside = event.currentTarget.contains(event.target as HTMLElement);\n                const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);\n                if (isKeyDownInside && isCloseKey) {\n                  context.onOpenChange(false);\n                  // We focus manually because we prevented it in `onCloseAutoFocus`\n                  subContext.trigger?.focus();\n                  // prevent window from scrolling\n                  event.preventDefault();\n                }\n              })}\n            />\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\nMenuSubContent.displayName = SUB_CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction isIndeterminate(checked?: CheckedState): checked is 'indeterminate' {\n  return checked === 'indeterminate';\n}\n\nfunction getCheckedState(checked: CheckedState) {\n  return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nfunction getNextMatch(values: string[], search: string, currentMatch?: string) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);\n  const nextMatch = wrappedValues.find((value) =>\n    value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : undefined;\n}\n\ntype Point = { x: number; y: number };\ntype Polygon = Point[];\ntype Side = 'left' | 'right';\ntype GraceIntent = { area: Polygon; side: Side };\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\nfunction isPointerInGraceArea(event: React.PointerEvent, area?: Polygon) {\n  if (!area) return false;\n  const cursorPos = { x: event.clientX, y: event.clientY };\n  return isPointInPolygon(cursorPos, area);\n}\n\nfunction whenMouse<E>(handler: React.PointerEventHandler<E>): React.PointerEventHandler<E> {\n  return (event) => (event.pointerType === 'mouse' ? handler(event) : undefined);\n}\n\nconst Root = Menu;\nconst Anchor = MenuAnchor;\nconst Portal = MenuPortal;\nconst Content = MenuContent;\nconst Group = MenuGroup;\nconst Label = MenuLabel;\nconst Item = MenuItem;\nconst CheckboxItem = MenuCheckboxItem;\nconst RadioGroup = MenuRadioGroup;\nconst RadioItem = MenuRadioItem;\nconst ItemIndicator = MenuItemIndicator;\nconst Separator = MenuSeparator;\nconst Arrow = MenuArrow;\nconst Sub = MenuSub;\nconst SubTrigger = MenuSubTrigger;\nconst SubContent = MenuSubContent;\n\nexport {\n  createMenuScope,\n  //\n  Menu,\n  MenuAnchor,\n  MenuPortal,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  MenuSub,\n  MenuSubTrigger,\n  MenuSubContent,\n  //\n  Root,\n  Anchor,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n};\nexport type {\n  MenuProps,\n  MenuAnchorProps,\n  MenuPortalProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n  MenuSubProps,\n  MenuSubTriggerProps,\n  MenuSubContentProps,\n};\n"]},"metadata":{},"sourceType":"module"}