{"ast":null,"code":"\"use client\";\n\nimport { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport { useId, useCallback, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\n\nconst PresenceChild = _ref => {\n  let {\n    children,\n    initial,\n    isPresent,\n    onExitComplete,\n    custom,\n    presenceAffectsLayout,\n    mode\n  } = _ref;\n  const presenceChildren = useConstant(newChildrenMap);\n  const id = useId();\n  const memoizedOnExitComplete = useCallback(childId => {\n    presenceChildren.set(childId, true);\n\n    for (const isComplete of presenceChildren.values()) {\n      if (!isComplete) return; // can stop searching when any is incomplete\n    }\n\n    onExitComplete && onExitComplete();\n  }, [presenceChildren, onExitComplete]);\n  const context = useMemo(() => ({\n    id,\n    initial,\n    isPresent,\n    custom,\n    onExitComplete: memoizedOnExitComplete,\n    register: childId => {\n      presenceChildren.set(childId, false);\n      return () => presenceChildren.delete(childId);\n    }\n  }),\n  /**\n   * If the presence of a child affects the layout of the components around it,\n   * we want to make a new context value to ensure they get re-rendered\n   * so they can detect that layout change.\n   */\n  presenceAffectsLayout ? [Math.random(), memoizedOnExitComplete] : [isPresent, memoizedOnExitComplete]);\n  useMemo(() => {\n    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n  }, [isPresent]);\n  /**\n   * If there's no `motion` components to fire exit animations, we want to remove this\n   * component immediately.\n   */\n\n  React.useEffect(() => {\n    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();\n  }, [isPresent]);\n\n  if (mode === \"popLayout\") {\n    children = jsx(PopChild, {\n      isPresent: isPresent,\n      children: children\n    });\n  }\n\n  return jsx(PresenceContext.Provider, {\n    value: context,\n    children: children\n  });\n};\n\nfunction newChildrenMap() {\n  return new Map();\n}\n\nexport { PresenceChild };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs"],"names":["jsx","React","useId","useCallback","useMemo","PresenceContext","useConstant","PopChild","PresenceChild","children","initial","isPresent","onExitComplete","custom","presenceAffectsLayout","mode","presenceChildren","newChildrenMap","id","memoizedOnExitComplete","childId","set","isComplete","values","context","register","delete","Math","random","forEach","_","key","useEffect","size","Provider","value","Map"],"mappings":"AAAA;;AACA,SAASA,GAAT,QAAoB,mBAApB;AACA,OAAO,KAAKC,KAAZ,MAAuB,OAAvB;AACA,SAASC,KAAT,EAAgBC,WAAhB,EAA6BC,OAA7B,QAA4C,OAA5C;AACA,SAASC,eAAT,QAAgC,mCAAhC;AACA,SAASC,WAAT,QAA4B,8BAA5B;AACA,SAASC,QAAT,QAAyB,gBAAzB;;AAEA,MAAMC,aAAa,GAAG,QAA4F;AAAA,MAA3F;AAAEC,IAAAA,QAAF;AAAYC,IAAAA,OAAZ;AAAqBC,IAAAA,SAArB;AAAgCC,IAAAA,cAAhC;AAAgDC,IAAAA,MAAhD;AAAwDC,IAAAA,qBAAxD;AAA+EC,IAAAA;AAA/E,GAA2F;AAC9G,QAAMC,gBAAgB,GAAGV,WAAW,CAACW,cAAD,CAApC;AACA,QAAMC,EAAE,GAAGhB,KAAK,EAAhB;AACA,QAAMiB,sBAAsB,GAAGhB,WAAW,CAAEiB,OAAD,IAAa;AACpDJ,IAAAA,gBAAgB,CAACK,GAAjB,CAAqBD,OAArB,EAA8B,IAA9B;;AACA,SAAK,MAAME,UAAX,IAAyBN,gBAAgB,CAACO,MAAjB,EAAzB,EAAoD;AAChD,UAAI,CAACD,UAAL,EACI,OAF4C,CAEpC;AACf;;AACDV,IAAAA,cAAc,IAAIA,cAAc,EAAhC;AACH,GAPyC,EAOvC,CAACI,gBAAD,EAAmBJ,cAAnB,CAPuC,CAA1C;AAQA,QAAMY,OAAO,GAAGpB,OAAO,CAAC,OAAO;AAC3Bc,IAAAA,EAD2B;AAE3BR,IAAAA,OAF2B;AAG3BC,IAAAA,SAH2B;AAI3BE,IAAAA,MAJ2B;AAK3BD,IAAAA,cAAc,EAAEO,sBALW;AAM3BM,IAAAA,QAAQ,EAAGL,OAAD,IAAa;AACnBJ,MAAAA,gBAAgB,CAACK,GAAjB,CAAqBD,OAArB,EAA8B,KAA9B;AACA,aAAO,MAAMJ,gBAAgB,CAACU,MAAjB,CAAwBN,OAAxB,CAAb;AACH;AAT0B,GAAP,CAAD;AAWvB;AACJ;AACA;AACA;AACA;AACIN,EAAAA,qBAAqB,GACf,CAACa,IAAI,CAACC,MAAL,EAAD,EAAgBT,sBAAhB,CADe,GAEf,CAACR,SAAD,EAAYQ,sBAAZ,CAlBiB,CAAvB;AAmBAf,EAAAA,OAAO,CAAC,MAAM;AACVY,IAAAA,gBAAgB,CAACa,OAAjB,CAAyB,CAACC,CAAD,EAAIC,GAAJ,KAAYf,gBAAgB,CAACK,GAAjB,CAAqBU,GAArB,EAA0B,KAA1B,CAArC;AACH,GAFM,EAEJ,CAACpB,SAAD,CAFI,CAAP;AAGA;AACJ;AACA;AACA;;AACIV,EAAAA,KAAK,CAAC+B,SAAN,CAAgB,MAAM;AAClB,KAACrB,SAAD,IACI,CAACK,gBAAgB,CAACiB,IADtB,IAEIrB,cAFJ,IAGIA,cAAc,EAHlB;AAIH,GALD,EAKG,CAACD,SAAD,CALH;;AAMA,MAAII,IAAI,KAAK,WAAb,EAA0B;AACtBN,IAAAA,QAAQ,GAAGT,GAAG,CAACO,QAAD,EAAW;AAAEI,MAAAA,SAAS,EAAEA,SAAb;AAAwBF,MAAAA,QAAQ,EAAEA;AAAlC,KAAX,CAAd;AACH;;AACD,SAAQT,GAAG,CAACK,eAAe,CAAC6B,QAAjB,EAA2B;AAAEC,IAAAA,KAAK,EAAEX,OAAT;AAAkBf,IAAAA,QAAQ,EAAEA;AAA5B,GAA3B,CAAX;AACH,CA/CD;;AAgDA,SAASQ,cAAT,GAA0B;AACtB,SAAO,IAAImB,GAAJ,EAAP;AACH;;AAED,SAAS5B,aAAT","sourcesContent":["\"use client\";\nimport { jsx } from 'react/jsx-runtime';\nimport * as React from 'react';\nimport { useId, useCallback, useMemo } from 'react';\nimport { PresenceContext } from '../../context/PresenceContext.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { PopChild } from './PopChild.mjs';\n\nconst PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, }) => {\n    const presenceChildren = useConstant(newChildrenMap);\n    const id = useId();\n    const memoizedOnExitComplete = useCallback((childId) => {\n        presenceChildren.set(childId, true);\n        for (const isComplete of presenceChildren.values()) {\n            if (!isComplete)\n                return; // can stop searching when any is incomplete\n        }\n        onExitComplete && onExitComplete();\n    }, [presenceChildren, onExitComplete]);\n    const context = useMemo(() => ({\n        id,\n        initial,\n        isPresent,\n        custom,\n        onExitComplete: memoizedOnExitComplete,\n        register: (childId) => {\n            presenceChildren.set(childId, false);\n            return () => presenceChildren.delete(childId);\n        },\n    }), \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout\n        ? [Math.random(), memoizedOnExitComplete]\n        : [isPresent, memoizedOnExitComplete]);\n    useMemo(() => {\n        presenceChildren.forEach((_, key) => presenceChildren.set(key, false));\n    }, [isPresent]);\n    /**\n     * If there's no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    React.useEffect(() => {\n        !isPresent &&\n            !presenceChildren.size &&\n            onExitComplete &&\n            onExitComplete();\n    }, [isPresent]);\n    if (mode === \"popLayout\") {\n        children = jsx(PopChild, { isPresent: isPresent, children: children });\n    }\n    return (jsx(PresenceContext.Provider, { value: context, children: children }));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\nexport { PresenceChild };\n"]},"metadata":{},"sourceType":"module"}