{"ast":null,"code":"\"use client\"; // packages/react/slider/src/Slider.tsx\n\nimport * as React from \"react\";\nimport { clamp } from \"@radix-ui/number\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useDirection } from \"@radix-ui/react-direction\";\nimport { usePrevious } from \"@radix-ui/react-use-previous\";\nimport { useSize } from \"@radix-ui/react-use-size\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { jsx, jsxs } from \"react/jsx-runtime\";\nvar PAGE_KEYS = [\"PageUp\", \"PageDown\"];\nvar ARROW_KEYS = [\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"];\nvar BACK_KEYS = {\n  \"from-left\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-right\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowRight\"],\n  \"from-bottom\": [\"Home\", \"PageDown\", \"ArrowDown\", \"ArrowLeft\"],\n  \"from-top\": [\"Home\", \"PageDown\", \"ArrowUp\", \"ArrowLeft\"]\n};\nvar SLIDER_NAME = \"Slider\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(SLIDER_NAME);\nvar [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [createCollectionScope]);\nvar [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);\nvar Slider = React.forwardRef((props, forwardedRef) => {\n  const {\n    name,\n    min = 0,\n    max = 100,\n    step = 1,\n    orientation = \"horizontal\",\n    disabled = false,\n    minStepsBetweenThumbs = 0,\n    defaultValue = [min],\n    value,\n    onValueChange = () => {},\n    onValueCommit = () => {},\n    inverted = false,\n    form,\n    ...sliderProps\n  } = props;\n  const thumbRefs = React.useRef( /* @__PURE__ */new Set());\n  const valueIndexToChangeRef = React.useRef(0);\n  const isHorizontal = orientation === \"horizontal\";\n  const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;\n  const [values = [], setValues] = useControllableState({\n    prop: value,\n    defaultProp: defaultValue,\n    onChange: value2 => {\n      const thumbs = [...thumbRefs.current];\n      thumbs[valueIndexToChangeRef.current]?.focus();\n      onValueChange(value2);\n    }\n  });\n  const valuesBeforeSlideStartRef = React.useRef(values);\n\n  function handleSlideStart(value2) {\n    const closestIndex = getClosestValueIndex(values, value2);\n    updateValues(value2, closestIndex);\n  }\n\n  function handleSlideMove(value2) {\n    updateValues(value2, valueIndexToChangeRef.current);\n  }\n\n  function handleSlideEnd() {\n    const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];\n    const nextValue = values[valueIndexToChangeRef.current];\n    const hasChanged = nextValue !== prevValue;\n    if (hasChanged) onValueCommit(values);\n  }\n\n  function updateValues(value2, atIndex) {\n    let {\n      commit\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      commit: false\n    };\n    const decimalCount = getDecimalCount(step);\n    const snapToStep = roundValue(Math.round((value2 - min) / step) * step + min, decimalCount);\n    const nextValue = clamp(snapToStep, [min, max]);\n    setValues(function () {\n      let prevValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);\n\n      if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {\n        valueIndexToChangeRef.current = nextValues.indexOf(nextValue);\n        const hasChanged = String(nextValues) !== String(prevValues);\n        if (hasChanged && commit) onValueCommit(nextValues);\n        return hasChanged ? nextValues : prevValues;\n      } else {\n        return prevValues;\n      }\n    });\n  }\n\n  return /* @__PURE__ */jsx(SliderProvider, {\n    scope: props.__scopeSlider,\n    name,\n    disabled,\n    min,\n    max,\n    valueIndexToChangeRef,\n    thumbs: thumbRefs.current,\n    values,\n    orientation,\n    form,\n    children: /* @__PURE__ */jsx(Collection.Provider, {\n      scope: props.__scopeSlider,\n      children: /* @__PURE__ */jsx(Collection.Slot, {\n        scope: props.__scopeSlider,\n        children: /* @__PURE__ */jsx(SliderOrientation, {\n          \"aria-disabled\": disabled,\n          \"data-disabled\": disabled ? \"\" : void 0,\n          ...sliderProps,\n          ref: forwardedRef,\n          onPointerDown: composeEventHandlers(sliderProps.onPointerDown, () => {\n            if (!disabled) valuesBeforeSlideStartRef.current = values;\n          }),\n          min,\n          max,\n          inverted,\n          onSlideStart: disabled ? void 0 : handleSlideStart,\n          onSlideMove: disabled ? void 0 : handleSlideMove,\n          onSlideEnd: disabled ? void 0 : handleSlideEnd,\n          onHomeKeyDown: () => !disabled && updateValues(min, 0, {\n            commit: true\n          }),\n          onEndKeyDown: () => !disabled && updateValues(max, values.length - 1, {\n            commit: true\n          }),\n          onStepKeyDown: _ref => {\n            let {\n              event,\n              direction: stepDirection\n            } = _ref;\n\n            if (!disabled) {\n              const isPageKey = PAGE_KEYS.includes(event.key);\n              const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);\n              const multiplier = isSkipKey ? 10 : 1;\n              const atIndex = valueIndexToChangeRef.current;\n              const value2 = values[atIndex];\n              const stepInDirection = step * multiplier * stepDirection;\n              updateValues(value2 + stepInDirection, atIndex, {\n                commit: true\n              });\n            }\n          }\n        })\n      })\n    })\n  });\n});\nSlider.displayName = SLIDER_NAME;\nvar [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {\n  startEdge: \"left\",\n  endEdge: \"right\",\n  size: \"width\",\n  direction: 1\n});\nvar SliderHorizontal = React.forwardRef((props, forwardedRef) => {\n  const {\n    min,\n    max,\n    dir,\n    inverted,\n    onSlideStart,\n    onSlideMove,\n    onSlideEnd,\n    onStepKeyDown,\n    ...sliderProps\n  } = props;\n  const [slider, setSlider] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setSlider(node));\n  const rectRef = React.useRef(void 0);\n  const direction = useDirection(dir);\n  const isDirectionLTR = direction === \"ltr\";\n  const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;\n\n  function getValueFromPointer(pointerPosition) {\n    const rect = rectRef.current || slider.getBoundingClientRect();\n    const input = [0, rect.width];\n    const output = isSlidingFromLeft ? [min, max] : [max, min];\n    const value = linearScale(input, output);\n    rectRef.current = rect;\n    return value(pointerPosition - rect.left);\n  }\n\n  return /* @__PURE__ */jsx(SliderOrientationProvider, {\n    scope: props.__scopeSlider,\n    startEdge: isSlidingFromLeft ? \"left\" : \"right\",\n    endEdge: isSlidingFromLeft ? \"right\" : \"left\",\n    direction: isSlidingFromLeft ? 1 : -1,\n    size: \"width\",\n    children: /* @__PURE__ */jsx(SliderImpl, {\n      dir: direction,\n      \"data-orientation\": \"horizontal\",\n      ...sliderProps,\n      ref: composedRefs,\n      style: { ...sliderProps.style,\n        [\"--radix-slider-thumb-transform\"]: \"translateX(-50%)\"\n      },\n      onSlideStart: event => {\n        const value = getValueFromPointer(event.clientX);\n        onSlideStart?.(value);\n      },\n      onSlideMove: event => {\n        const value = getValueFromPointer(event.clientX);\n        onSlideMove?.(value);\n      },\n      onSlideEnd: () => {\n        rectRef.current = void 0;\n        onSlideEnd?.();\n      },\n      onStepKeyDown: event => {\n        const slideDirection = isSlidingFromLeft ? \"from-left\" : \"from-right\";\n        const isBackKey = BACK_KEYS[slideDirection].includes(event.key);\n        onStepKeyDown?.({\n          event,\n          direction: isBackKey ? -1 : 1\n        });\n      }\n    })\n  });\n});\nvar SliderVertical = React.forwardRef((props, forwardedRef) => {\n  const {\n    min,\n    max,\n    inverted,\n    onSlideStart,\n    onSlideMove,\n    onSlideEnd,\n    onStepKeyDown,\n    ...sliderProps\n  } = props;\n  const sliderRef = React.useRef(null);\n  const ref = useComposedRefs(forwardedRef, sliderRef);\n  const rectRef = React.useRef(void 0);\n  const isSlidingFromBottom = !inverted;\n\n  function getValueFromPointer(pointerPosition) {\n    const rect = rectRef.current || sliderRef.current.getBoundingClientRect();\n    const input = [0, rect.height];\n    const output = isSlidingFromBottom ? [max, min] : [min, max];\n    const value = linearScale(input, output);\n    rectRef.current = rect;\n    return value(pointerPosition - rect.top);\n  }\n\n  return /* @__PURE__ */jsx(SliderOrientationProvider, {\n    scope: props.__scopeSlider,\n    startEdge: isSlidingFromBottom ? \"bottom\" : \"top\",\n    endEdge: isSlidingFromBottom ? \"top\" : \"bottom\",\n    size: \"height\",\n    direction: isSlidingFromBottom ? 1 : -1,\n    children: /* @__PURE__ */jsx(SliderImpl, {\n      \"data-orientation\": \"vertical\",\n      ...sliderProps,\n      ref,\n      style: { ...sliderProps.style,\n        [\"--radix-slider-thumb-transform\"]: \"translateY(50%)\"\n      },\n      onSlideStart: event => {\n        const value = getValueFromPointer(event.clientY);\n        onSlideStart?.(value);\n      },\n      onSlideMove: event => {\n        const value = getValueFromPointer(event.clientY);\n        onSlideMove?.(value);\n      },\n      onSlideEnd: () => {\n        rectRef.current = void 0;\n        onSlideEnd?.();\n      },\n      onStepKeyDown: event => {\n        const slideDirection = isSlidingFromBottom ? \"from-bottom\" : \"from-top\";\n        const isBackKey = BACK_KEYS[slideDirection].includes(event.key);\n        onStepKeyDown?.({\n          event,\n          direction: isBackKey ? -1 : 1\n        });\n      }\n    })\n  });\n});\nvar SliderImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSlider,\n    onSlideStart,\n    onSlideMove,\n    onSlideEnd,\n    onHomeKeyDown,\n    onEndKeyDown,\n    onStepKeyDown,\n    ...sliderProps\n  } = props;\n  const context = useSliderContext(SLIDER_NAME, __scopeSlider);\n  return /* @__PURE__ */jsx(Primitive.span, { ...sliderProps,\n    ref: forwardedRef,\n    onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n      if (event.key === \"Home\") {\n        onHomeKeyDown(event);\n        event.preventDefault();\n      } else if (event.key === \"End\") {\n        onEndKeyDown(event);\n        event.preventDefault();\n      } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {\n        onStepKeyDown(event);\n        event.preventDefault();\n      }\n    }),\n    onPointerDown: composeEventHandlers(props.onPointerDown, event => {\n      const target = event.target;\n      target.setPointerCapture(event.pointerId);\n      event.preventDefault();\n\n      if (context.thumbs.has(target)) {\n        target.focus();\n      } else {\n        onSlideStart(event);\n      }\n    }),\n    onPointerMove: composeEventHandlers(props.onPointerMove, event => {\n      const target = event.target;\n      if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);\n    }),\n    onPointerUp: composeEventHandlers(props.onPointerUp, event => {\n      const target = event.target;\n\n      if (target.hasPointerCapture(event.pointerId)) {\n        target.releasePointerCapture(event.pointerId);\n        onSlideEnd(event);\n      }\n    })\n  });\n});\nvar TRACK_NAME = \"SliderTrack\";\nvar SliderTrack = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSlider,\n    ...trackProps\n  } = props;\n  const context = useSliderContext(TRACK_NAME, __scopeSlider);\n  return /* @__PURE__ */jsx(Primitive.span, {\n    \"data-disabled\": context.disabled ? \"\" : void 0,\n    \"data-orientation\": context.orientation,\n    ...trackProps,\n    ref: forwardedRef\n  });\n});\nSliderTrack.displayName = TRACK_NAME;\nvar RANGE_NAME = \"SliderRange\";\nvar SliderRange = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSlider,\n    ...rangeProps\n  } = props;\n  const context = useSliderContext(RANGE_NAME, __scopeSlider);\n  const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const valuesCount = context.values.length;\n  const percentages = context.values.map(value => convertValueToPercentage(value, context.min, context.max));\n  const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;\n  const offsetEnd = 100 - Math.max(...percentages);\n  return /* @__PURE__ */jsx(Primitive.span, {\n    \"data-orientation\": context.orientation,\n    \"data-disabled\": context.disabled ? \"\" : void 0,\n    ...rangeProps,\n    ref: composedRefs,\n    style: { ...props.style,\n      [orientation.startEdge]: offsetStart + \"%\",\n      [orientation.endEdge]: offsetEnd + \"%\"\n    }\n  });\n});\nSliderRange.displayName = RANGE_NAME;\nvar THUMB_NAME = \"SliderThumb\";\nvar SliderThumb = React.forwardRef((props, forwardedRef) => {\n  const getItems = useCollection(props.__scopeSlider);\n  const [thumb, setThumb] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setThumb(node));\n  const index = React.useMemo(() => thumb ? getItems().findIndex(item => item.ref.current === thumb) : -1, [getItems, thumb]);\n  return /* @__PURE__ */jsx(SliderThumbImpl, { ...props,\n    ref: composedRefs,\n    index\n  });\n});\nvar SliderThumbImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSlider,\n    index,\n    name,\n    ...thumbProps\n  } = props;\n  const context = useSliderContext(THUMB_NAME, __scopeSlider);\n  const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);\n  const [thumb, setThumb] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setThumb(node));\n  const isFormControl = thumb ? context.form || !!thumb.closest(\"form\") : true;\n  const size = useSize(thumb);\n  const value = context.values[index];\n  const percent = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);\n  const label = getLabel(index, context.values.length);\n  const orientationSize = size?.[orientation.size];\n  const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction) : 0;\n  React.useEffect(() => {\n    if (thumb) {\n      context.thumbs.add(thumb);\n      return () => {\n        context.thumbs.delete(thumb);\n      };\n    }\n  }, [thumb, context.thumbs]);\n  return /* @__PURE__ */jsxs(\"span\", {\n    style: {\n      transform: \"var(--radix-slider-thumb-transform)\",\n      position: \"absolute\",\n      [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`\n    },\n    children: [/* @__PURE__ */jsx(Collection.ItemSlot, {\n      scope: props.__scopeSlider,\n      children: /* @__PURE__ */jsx(Primitive.span, {\n        role: \"slider\",\n        \"aria-label\": props[\"aria-label\"] || label,\n        \"aria-valuemin\": context.min,\n        \"aria-valuenow\": value,\n        \"aria-valuemax\": context.max,\n        \"aria-orientation\": context.orientation,\n        \"data-orientation\": context.orientation,\n        \"data-disabled\": context.disabled ? \"\" : void 0,\n        tabIndex: context.disabled ? void 0 : 0,\n        ...thumbProps,\n        ref: composedRefs,\n        style: value === void 0 ? {\n          display: \"none\"\n        } : props.style,\n        onFocus: composeEventHandlers(props.onFocus, () => {\n          context.valueIndexToChangeRef.current = index;\n        })\n      })\n    }), isFormControl && /* @__PURE__ */jsx(BubbleInput, {\n      name: name ?? (context.name ? context.name + (context.values.length > 1 ? \"[]\" : \"\") : void 0),\n      form: context.form,\n      value\n    }, index)]\n  });\n});\nSliderThumb.displayName = THUMB_NAME;\n\nvar BubbleInput = props => {\n  const {\n    value,\n    ...inputProps\n  } = props;\n  const ref = React.useRef(null);\n  const prevValue = usePrevious(value);\n  React.useEffect(() => {\n    const input = ref.current;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, \"value\");\n    const setValue = descriptor.set;\n\n    if (prevValue !== value && setValue) {\n      const event = new Event(\"input\", {\n        bubbles: true\n      });\n      setValue.call(input, value);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value]);\n  return /* @__PURE__ */jsx(\"input\", {\n    style: {\n      display: \"none\"\n    },\n    ...inputProps,\n    ref,\n    defaultValue: value\n  });\n};\n\nfunction getNextSortedValues() {\n  let prevValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  let nextValue = arguments.length > 1 ? arguments[1] : undefined;\n  let atIndex = arguments.length > 2 ? arguments[2] : undefined;\n  const nextValues = [...prevValues];\n  nextValues[atIndex] = nextValue;\n  return nextValues.sort((a, b) => a - b);\n}\n\nfunction convertValueToPercentage(value, min, max) {\n  const maxSteps = max - min;\n  const percentPerStep = 100 / maxSteps;\n  const percentage = percentPerStep * (value - min);\n  return clamp(percentage, [0, 100]);\n}\n\nfunction getLabel(index, totalValues) {\n  if (totalValues > 2) {\n    return `Value ${index + 1} of ${totalValues}`;\n  } else if (totalValues === 2) {\n    return [\"Minimum\", \"Maximum\"][index];\n  } else {\n    return void 0;\n  }\n}\n\nfunction getClosestValueIndex(values, nextValue) {\n  if (values.length === 1) return 0;\n  const distances = values.map(value => Math.abs(value - nextValue));\n  const closestDistance = Math.min(...distances);\n  return distances.indexOf(closestDistance);\n}\n\nfunction getThumbInBoundsOffset(width, left, direction) {\n  const halfWidth = width / 2;\n  const halfPercent = 50;\n  const offset = linearScale([0, halfPercent], [0, halfWidth]);\n  return (halfWidth - offset(left) * direction) * direction;\n}\n\nfunction getStepsBetweenValues(values) {\n  return values.slice(0, -1).map((value, index) => values[index + 1] - value);\n}\n\nfunction hasMinStepsBetweenValues(values, minStepsBetweenValues) {\n  if (minStepsBetweenValues > 0) {\n    const stepsBetweenValues = getStepsBetweenValues(values);\n    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);\n    return actualMinStepsBetweenValues >= minStepsBetweenValues;\n  }\n\n  return true;\n}\n\nfunction linearScale(input, output) {\n  return value => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\n\nfunction getDecimalCount(value) {\n  return (String(value).split(\".\")[1] || \"\").length;\n}\n\nfunction roundValue(value, decimalCount) {\n  const rounder = Math.pow(10, decimalCount);\n  return Math.round(value * rounder) / rounder;\n}\n\nvar Root = Slider;\nvar Track = SliderTrack;\nvar Range = SliderRange;\nvar Thumb = SliderThumb;\nexport { Range, Root, Slider, SliderRange, SliderThumb, SliderTrack, Thumb, Track, createSliderScope };","map":{"version":3,"mappings":"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","names":["React","clamp","composeEventHandlers","useComposedRefs","createContextScope","useControllableState","useDirection","usePrevious","useSize","Primitive","createCollection","jsxs","PAGE_KEYS","ARROW_KEYS","BACK_KEYS","SLIDER_NAME","Collection","useCollection","createCollectionScope","createSliderContext","createSliderScope","SliderProvider","useSliderContext","Slider","props","forwardedRef","name","min","max","step","orientation","disabled","minStepsBetweenThumbs","defaultValue","value","onValueChange","onValueCommit","inverted","form","sliderProps","thumbRefs","Set","valueIndexToChangeRef","isHorizontal","SliderOrientation","SliderHorizontal","SliderVertical","values","setValues","prop","defaultProp","onChange","thumbs","current","focus","valuesBeforeSlideStartRef","handleSlideStart","closestIndex","getClosestValueIndex","updateValues","handleSlideMove","handleSlideEnd","prevValue","nextValue","hasChanged","atIndex","commit","decimalCount","getDecimalCount","snapToStep","roundValue","Math","round","prevValues","nextValues","getNextSortedValues","hasMinStepsBetweenValues","indexOf","String","scope","__scopeSlider","children","Provider","Slot","ref","onPointerDown","onSlideStart","onSlideMove","onSlideEnd","onHomeKeyDown","onEndKeyDown","length","onStepKeyDown","event","direction","stepDirection","isPageKey","includes","key","isSkipKey","shiftKey","multiplier","stepInDirection","displayName","SliderOrientationProvider","useSliderOrientationContext","startEdge","endEdge","size","dir","slider","setSlider","composedRefs","node","rectRef","isDirectionLTR","isSlidingFromLeft","getValueFromPointer","pointerPosition","rect","getBoundingClientRect","input","width","output","linearScale","left","SliderImpl","style","clientX","slideDirection","isBackKey","sliderRef","isSlidingFromBottom","height","top","clientY","context","span","onKeyDown","preventDefault","concat","target","setPointerCapture","pointerId","has","onPointerMove","hasPointerCapture","onPointerUp","releasePointerCapture","TRACK_NAME","SliderTrack","trackProps","RANGE_NAME","SliderRange","rangeProps","valuesCount","percentages","map","convertValueToPercentage","offsetStart","offsetEnd","THUMB_NAME","SliderThumb","getItems","thumb","setThumb","index","findIndex","item","SliderThumbImpl","thumbProps","isFormControl","closest","percent","label","getLabel","orientationSize","thumbInBoundsOffset","getThumbInBoundsOffset","add","delete","transform","position","ItemSlot","role","tabIndex","display","onFocus","BubbleInput","inputProps","inputProto","window","HTMLInputElement","prototype","descriptor","Object","getOwnPropertyDescriptor","setValue","set","Event","bubbles","call","dispatchEvent","sort","a","b","maxSteps","percentPerStep","percentage","totalValues","distances","abs","closestDistance","halfWidth","halfPercent","offset","getStepsBetweenValues","slice","minStepsBetweenValues","stepsBetweenValues","actualMinStepsBetweenValues","ratio","split","rounder","pow","Root","Track","Range","Thumb"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-slider/src/Slider.tsx"],"sourcesContent":["import * as React from 'react';\nimport { clamp } from '@radix-ui/number';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { createCollection } from '@radix-ui/react-collection';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst PAGE_KEYS = ['PageUp', 'PageDown'];\nconst ARROW_KEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n\ntype SlideDirection = 'from-left' | 'from-right' | 'from-bottom' | 'from-top';\nconst BACK_KEYS: Record<SlideDirection, string[]> = {\n  'from-left': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],\n  'from-right': ['Home', 'PageDown', 'ArrowDown', 'ArrowRight'],\n  'from-bottom': ['Home', 'PageDown', 'ArrowDown', 'ArrowLeft'],\n  'from-top': ['Home', 'PageDown', 'ArrowUp', 'ArrowLeft'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Slider\n * -----------------------------------------------------------------------------------------------*/\n\nconst SLIDER_NAME = 'Slider';\n\nconst [Collection, useCollection, createCollectionScope] =\n  createCollection<SliderThumbElement>(SLIDER_NAME);\n\ntype ScopedProps<P> = P & { __scopeSlider?: Scope };\nconst [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [\n  createCollectionScope,\n]);\n\ntype SliderContextValue = {\n  name: string | undefined;\n  disabled: boolean | undefined;\n  min: number;\n  max: number;\n  values: number[];\n  valueIndexToChangeRef: React.MutableRefObject<number>;\n  thumbs: Set<SliderThumbElement>;\n  orientation: SliderProps['orientation'];\n  form: string | undefined;\n};\n\nconst [SliderProvider, useSliderContext] = createSliderContext<SliderContextValue>(SLIDER_NAME);\n\ntype SliderElement = SliderHorizontalElement | SliderVerticalElement;\ninterface SliderProps\n  extends Omit<\n    SliderHorizontalProps | SliderVerticalProps,\n    keyof SliderOrientationPrivateProps | 'defaultValue'\n  > {\n  name?: string;\n  disabled?: boolean;\n  orientation?: React.AriaAttributes['aria-orientation'];\n  dir?: Direction;\n  min?: number;\n  max?: number;\n  step?: number;\n  minStepsBetweenThumbs?: number;\n  value?: number[];\n  defaultValue?: number[];\n  onValueChange?(value: number[]): void;\n  onValueCommit?(value: number[]): void;\n  inverted?: boolean;\n  form?: string;\n}\n\nconst Slider = React.forwardRef<SliderElement, SliderProps>(\n  (props: ScopedProps<SliderProps>, forwardedRef) => {\n    const {\n      name,\n      min = 0,\n      max = 100,\n      step = 1,\n      orientation = 'horizontal',\n      disabled = false,\n      minStepsBetweenThumbs = 0,\n      defaultValue = [min],\n      value,\n      onValueChange = () => {},\n      onValueCommit = () => {},\n      inverted = false,\n      form,\n      ...sliderProps\n    } = props;\n    const thumbRefs = React.useRef<SliderContextValue['thumbs']>(new Set());\n    const valueIndexToChangeRef = React.useRef<number>(0);\n    const isHorizontal = orientation === 'horizontal';\n    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;\n\n    const [values = [], setValues] = useControllableState({\n      prop: value,\n      defaultProp: defaultValue,\n      onChange: (value) => {\n        const thumbs = [...thumbRefs.current];\n        thumbs[valueIndexToChangeRef.current]?.focus();\n        onValueChange(value);\n      },\n    });\n    const valuesBeforeSlideStartRef = React.useRef(values);\n\n    function handleSlideStart(value: number) {\n      const closestIndex = getClosestValueIndex(values, value);\n      updateValues(value, closestIndex);\n    }\n\n    function handleSlideMove(value: number) {\n      updateValues(value, valueIndexToChangeRef.current);\n    }\n\n    function handleSlideEnd() {\n      const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];\n      const nextValue = values[valueIndexToChangeRef.current];\n      const hasChanged = nextValue !== prevValue;\n      if (hasChanged) onValueCommit(values);\n    }\n\n    function updateValues(value: number, atIndex: number, { commit } = { commit: false }) {\n      const decimalCount = getDecimalCount(step);\n      const snapToStep = roundValue(Math.round((value - min) / step) * step + min, decimalCount);\n      const nextValue = clamp(snapToStep, [min, max]);\n\n      setValues((prevValues = []) => {\n        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);\n        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {\n          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);\n          const hasChanged = String(nextValues) !== String(prevValues);\n          if (hasChanged && commit) onValueCommit(nextValues);\n          return hasChanged ? nextValues : prevValues;\n        } else {\n          return prevValues;\n        }\n      });\n    }\n\n    return (\n      <SliderProvider\n        scope={props.__scopeSlider}\n        name={name}\n        disabled={disabled}\n        min={min}\n        max={max}\n        valueIndexToChangeRef={valueIndexToChangeRef}\n        thumbs={thumbRefs.current}\n        values={values}\n        orientation={orientation}\n        form={form}\n      >\n        <Collection.Provider scope={props.__scopeSlider}>\n          <Collection.Slot scope={props.__scopeSlider}>\n            <SliderOrientation\n              aria-disabled={disabled}\n              data-disabled={disabled ? '' : undefined}\n              {...sliderProps}\n              ref={forwardedRef}\n              onPointerDown={composeEventHandlers(sliderProps.onPointerDown, () => {\n                if (!disabled) valuesBeforeSlideStartRef.current = values;\n              })}\n              min={min}\n              max={max}\n              inverted={inverted}\n              onSlideStart={disabled ? undefined : handleSlideStart}\n              onSlideMove={disabled ? undefined : handleSlideMove}\n              onSlideEnd={disabled ? undefined : handleSlideEnd}\n              onHomeKeyDown={() => !disabled && updateValues(min, 0, { commit: true })}\n              onEndKeyDown={() =>\n                !disabled && updateValues(max, values.length - 1, { commit: true })\n              }\n              onStepKeyDown={({ event, direction: stepDirection }) => {\n                if (!disabled) {\n                  const isPageKey = PAGE_KEYS.includes(event.key);\n                  const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.includes(event.key));\n                  const multiplier = isSkipKey ? 10 : 1;\n                  const atIndex = valueIndexToChangeRef.current;\n                  const value = values[atIndex];\n                  const stepInDirection = step * multiplier * stepDirection;\n                  updateValues(value + stepInDirection, atIndex, { commit: true });\n                }\n              }}\n            />\n          </Collection.Slot>\n        </Collection.Provider>\n      </SliderProvider>\n    );\n  }\n);\n\nSlider.displayName = SLIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderHorizontal\n * -----------------------------------------------------------------------------------------------*/\n\ntype Side = 'top' | 'right' | 'bottom' | 'left';\n\nconst [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext<{\n  startEdge: Side;\n  endEdge: Side;\n  size: keyof NonNullable<ReturnType<typeof useSize>>;\n  direction: number;\n}>(SLIDER_NAME, {\n  startEdge: 'left',\n  endEdge: 'right',\n  size: 'width',\n  direction: 1,\n});\n\ntype SliderOrientationPrivateProps = {\n  min: number;\n  max: number;\n  inverted: boolean;\n  onSlideStart?(value: number): void;\n  onSlideMove?(value: number): void;\n  onSlideEnd?(): void;\n  onHomeKeyDown(event: React.KeyboardEvent): void;\n  onEndKeyDown(event: React.KeyboardEvent): void;\n  onStepKeyDown(step: { event: React.KeyboardEvent; direction: number }): void;\n};\ninterface SliderOrientationProps\n  extends Omit<SliderImplProps, keyof SliderImplPrivateProps>,\n    SliderOrientationPrivateProps {}\n\ntype SliderHorizontalElement = SliderImplElement;\ninterface SliderHorizontalProps extends SliderOrientationProps {\n  dir?: Direction;\n}\n\nconst SliderHorizontal = React.forwardRef<SliderHorizontalElement, SliderHorizontalProps>(\n  (props: ScopedProps<SliderHorizontalProps>, forwardedRef) => {\n    const {\n      min,\n      max,\n      dir,\n      inverted,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const [slider, setSlider] = React.useState<SliderImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));\n    const rectRef = React.useRef<DOMRect>(undefined);\n    const direction = useDirection(dir);\n    const isDirectionLTR = direction === 'ltr';\n    const isSlidingFromLeft = (isDirectionLTR && !inverted) || (!isDirectionLTR && inverted);\n\n    function getValueFromPointer(pointerPosition: number) {\n      const rect = rectRef.current || slider!.getBoundingClientRect();\n      const input: [number, number] = [0, rect.width];\n      const output: [number, number] = isSlidingFromLeft ? [min, max] : [max, min];\n      const value = linearScale(input, output);\n\n      rectRef.current = rect;\n      return value(pointerPosition - rect.left);\n    }\n\n    return (\n      <SliderOrientationProvider\n        scope={props.__scopeSlider}\n        startEdge={isSlidingFromLeft ? 'left' : 'right'}\n        endEdge={isSlidingFromLeft ? 'right' : 'left'}\n        direction={isSlidingFromLeft ? 1 : -1}\n        size=\"width\"\n      >\n        <SliderImpl\n          dir={direction}\n          data-orientation=\"horizontal\"\n          {...sliderProps}\n          ref={composedRefs}\n          style={{\n            ...sliderProps.style,\n            ['--radix-slider-thumb-transform' as any]: 'translateX(-50%)',\n          }}\n          onSlideStart={(event) => {\n            const value = getValueFromPointer(event.clientX);\n            onSlideStart?.(value);\n          }}\n          onSlideMove={(event) => {\n            const value = getValueFromPointer(event.clientX);\n            onSlideMove?.(value);\n          }}\n          onSlideEnd={() => {\n            rectRef.current = undefined;\n            onSlideEnd?.();\n          }}\n          onStepKeyDown={(event) => {\n            const slideDirection = isSlidingFromLeft ? 'from-left' : 'from-right';\n            const isBackKey = BACK_KEYS[slideDirection].includes(event.key);\n            onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });\n          }}\n        />\n      </SliderOrientationProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderVertical\n * -----------------------------------------------------------------------------------------------*/\n\ntype SliderVerticalElement = SliderImplElement;\ninterface SliderVerticalProps extends SliderOrientationProps {}\n\nconst SliderVertical = React.forwardRef<SliderVerticalElement, SliderVerticalProps>(\n  (props: ScopedProps<SliderVerticalProps>, forwardedRef) => {\n    const {\n      min,\n      max,\n      inverted,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const sliderRef = React.useRef<SliderImplElement>(null);\n    const ref = useComposedRefs(forwardedRef, sliderRef);\n    const rectRef = React.useRef<DOMRect>(undefined);\n    const isSlidingFromBottom = !inverted;\n\n    function getValueFromPointer(pointerPosition: number) {\n      const rect = rectRef.current || sliderRef.current!.getBoundingClientRect();\n      const input: [number, number] = [0, rect.height];\n      const output: [number, number] = isSlidingFromBottom ? [max, min] : [min, max];\n      const value = linearScale(input, output);\n\n      rectRef.current = rect;\n      return value(pointerPosition - rect.top);\n    }\n\n    return (\n      <SliderOrientationProvider\n        scope={props.__scopeSlider}\n        startEdge={isSlidingFromBottom ? 'bottom' : 'top'}\n        endEdge={isSlidingFromBottom ? 'top' : 'bottom'}\n        size=\"height\"\n        direction={isSlidingFromBottom ? 1 : -1}\n      >\n        <SliderImpl\n          data-orientation=\"vertical\"\n          {...sliderProps}\n          ref={ref}\n          style={{\n            ...sliderProps.style,\n            ['--radix-slider-thumb-transform' as any]: 'translateY(50%)',\n          }}\n          onSlideStart={(event) => {\n            const value = getValueFromPointer(event.clientY);\n            onSlideStart?.(value);\n          }}\n          onSlideMove={(event) => {\n            const value = getValueFromPointer(event.clientY);\n            onSlideMove?.(value);\n          }}\n          onSlideEnd={() => {\n            rectRef.current = undefined;\n            onSlideEnd?.();\n          }}\n          onStepKeyDown={(event) => {\n            const slideDirection = isSlidingFromBottom ? 'from-bottom' : 'from-top';\n            const isBackKey = BACK_KEYS[slideDirection].includes(event.key);\n            onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });\n          }}\n        />\n      </SliderOrientationProvider>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderImpl\n * -----------------------------------------------------------------------------------------------*/\n\ntype SliderImplElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ntype SliderImplPrivateProps = {\n  onSlideStart(event: React.PointerEvent): void;\n  onSlideMove(event: React.PointerEvent): void;\n  onSlideEnd(event: React.PointerEvent): void;\n  onHomeKeyDown(event: React.KeyboardEvent): void;\n  onEndKeyDown(event: React.KeyboardEvent): void;\n  onStepKeyDown(event: React.KeyboardEvent): void;\n};\ninterface SliderImplProps extends PrimitiveDivProps, SliderImplPrivateProps {}\n\nconst SliderImpl = React.forwardRef<SliderImplElement, SliderImplProps>(\n  (props: ScopedProps<SliderImplProps>, forwardedRef) => {\n    const {\n      __scopeSlider,\n      onSlideStart,\n      onSlideMove,\n      onSlideEnd,\n      onHomeKeyDown,\n      onEndKeyDown,\n      onStepKeyDown,\n      ...sliderProps\n    } = props;\n    const context = useSliderContext(SLIDER_NAME, __scopeSlider);\n\n    return (\n      <Primitive.span\n        {...sliderProps}\n        ref={forwardedRef}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          if (event.key === 'Home') {\n            onHomeKeyDown(event);\n            // Prevent scrolling to page start\n            event.preventDefault();\n          } else if (event.key === 'End') {\n            onEndKeyDown(event);\n            // Prevent scrolling to page end\n            event.preventDefault();\n          } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {\n            onStepKeyDown(event);\n            // Prevent scrolling for directional key presses\n            event.preventDefault();\n          }\n        })}\n        onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n          const target = event.target as HTMLElement;\n          target.setPointerCapture(event.pointerId);\n          // Prevent browser focus behaviour because we focus a thumb manually when values change.\n          event.preventDefault();\n          // Touch devices have a delay before focusing so won't focus if touch immediately moves\n          // away from target (sliding). We want thumb to focus regardless.\n          if (context.thumbs.has(target)) {\n            target.focus();\n          } else {\n            onSlideStart(event);\n          }\n        })}\n        onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);\n        })}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          const target = event.target as HTMLElement;\n          if (target.hasPointerCapture(event.pointerId)) {\n            target.releasePointerCapture(event.pointerId);\n            onSlideEnd(event);\n          }\n        })}\n      />\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * SliderTrack\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRACK_NAME = 'SliderTrack';\n\ntype SliderTrackElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface SliderTrackProps extends PrimitiveSpanProps {}\n\nconst SliderTrack = React.forwardRef<SliderTrackElement, SliderTrackProps>(\n  (props: ScopedProps<SliderTrackProps>, forwardedRef) => {\n    const { __scopeSlider, ...trackProps } = props;\n    const context = useSliderContext(TRACK_NAME, __scopeSlider);\n    return (\n      <Primitive.span\n        data-disabled={context.disabled ? '' : undefined}\n        data-orientation={context.orientation}\n        {...trackProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nSliderTrack.displayName = TRACK_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderRange\n * -----------------------------------------------------------------------------------------------*/\n\nconst RANGE_NAME = 'SliderRange';\n\ntype SliderRangeElement = React.ElementRef<typeof Primitive.span>;\ninterface SliderRangeProps extends PrimitiveSpanProps {}\n\nconst SliderRange = React.forwardRef<SliderRangeElement, SliderRangeProps>(\n  (props: ScopedProps<SliderRangeProps>, forwardedRef) => {\n    const { __scopeSlider, ...rangeProps } = props;\n    const context = useSliderContext(RANGE_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);\n    const ref = React.useRef<HTMLSpanElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const valuesCount = context.values.length;\n    const percentages = context.values.map((value) =>\n      convertValueToPercentage(value, context.min, context.max)\n    );\n    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;\n    const offsetEnd = 100 - Math.max(...percentages);\n\n    return (\n      <Primitive.span\n        data-orientation={context.orientation}\n        data-disabled={context.disabled ? '' : undefined}\n        {...rangeProps}\n        ref={composedRefs}\n        style={{\n          ...props.style,\n          [orientation.startEdge]: offsetStart + '%',\n          [orientation.endEdge]: offsetEnd + '%',\n        }}\n      />\n    );\n  }\n);\n\nSliderRange.displayName = RANGE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SliderThumb\n * -----------------------------------------------------------------------------------------------*/\n\nconst THUMB_NAME = 'SliderThumb';\n\ntype SliderThumbElement = SliderThumbImplElement;\ninterface SliderThumbProps extends Omit<SliderThumbImplProps, 'index'> {}\n\nconst SliderThumb = React.forwardRef<SliderThumbElement, SliderThumbProps>(\n  (props: ScopedProps<SliderThumbProps>, forwardedRef) => {\n    const getItems = useCollection(props.__scopeSlider);\n    const [thumb, setThumb] = React.useState<SliderThumbImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    const index = React.useMemo(\n      () => (thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1),\n      [getItems, thumb]\n    );\n    return <SliderThumbImpl {...props} ref={composedRefs} index={index} />;\n  }\n);\n\ntype SliderThumbImplElement = React.ElementRef<typeof Primitive.span>;\ninterface SliderThumbImplProps extends PrimitiveSpanProps {\n  index: number;\n  name?: string;\n}\n\nconst SliderThumbImpl = React.forwardRef<SliderThumbImplElement, SliderThumbImplProps>(\n  (props: ScopedProps<SliderThumbImplProps>, forwardedRef) => {\n    const { __scopeSlider, index, name, ...thumbProps } = props;\n    const context = useSliderContext(THUMB_NAME, __scopeSlider);\n    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);\n    const [thumb, setThumb] = React.useState<HTMLSpanElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = thumb ? context.form || !!thumb.closest('form') : true;\n    const size = useSize(thumb);\n    // We cast because index could be `-1` which would return undefined\n    const value = context.values[index] as number | undefined;\n    const percent =\n      value === undefined ? 0 : convertValueToPercentage(value, context.min, context.max);\n    const label = getLabel(index, context.values.length);\n    const orientationSize = size?.[orientation.size];\n    const thumbInBoundsOffset = orientationSize\n      ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction)\n      : 0;\n\n    React.useEffect(() => {\n      if (thumb) {\n        context.thumbs.add(thumb);\n        return () => {\n          context.thumbs.delete(thumb);\n        };\n      }\n    }, [thumb, context.thumbs]);\n\n    return (\n      <span\n        style={{\n          transform: 'var(--radix-slider-thumb-transform)',\n          position: 'absolute',\n          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`,\n        }}\n      >\n        <Collection.ItemSlot scope={props.__scopeSlider}>\n          <Primitive.span\n            role=\"slider\"\n            aria-label={props['aria-label'] || label}\n            aria-valuemin={context.min}\n            aria-valuenow={value}\n            aria-valuemax={context.max}\n            aria-orientation={context.orientation}\n            data-orientation={context.orientation}\n            data-disabled={context.disabled ? '' : undefined}\n            tabIndex={context.disabled ? undefined : 0}\n            {...thumbProps}\n            ref={composedRefs}\n            /**\n             * There will be no value on initial render while we work out the index so we hide thumbs\n             * without a value, otherwise SSR will render them in the wrong position before they\n             * snap into the correct position during hydration which would be visually jarring for\n             * slower connections.\n             */\n            style={value === undefined ? { display: 'none' } : props.style}\n            onFocus={composeEventHandlers(props.onFocus, () => {\n              context.valueIndexToChangeRef.current = index;\n            })}\n          />\n        </Collection.ItemSlot>\n\n        {isFormControl && (\n          <BubbleInput\n            key={index}\n            name={\n              name ??\n              (context.name ? context.name + (context.values.length > 1 ? '[]' : '') : undefined)\n            }\n            form={context.form}\n            value={value}\n          />\n        )}\n      </span>\n    );\n  }\n);\n\nSliderThumb.displayName = THUMB_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst BubbleInput = (props: React.ComponentPropsWithoutRef<'input'>) => {\n  const { value, ...inputProps } = props;\n  const ref = React.useRef<HTMLInputElement>(null);\n  const prevValue = usePrevious(value);\n\n  // Bubble value change to parents (e.g form change event)\n  React.useEffect(() => {\n    const input = ref.current!;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'value') as PropertyDescriptor;\n    const setValue = descriptor.set;\n    if (prevValue !== value && setValue) {\n      const event = new Event('input', { bubbles: true });\n      setValue.call(input, value);\n      input.dispatchEvent(event);\n    }\n  }, [prevValue, value]);\n\n  /**\n   * We purposefully do not use `type=\"hidden\"` here otherwise forms that\n   * wrap it will not be able to access its value via the FormData API.\n   *\n   * We purposefully do not add the `value` attribute here to allow the value\n   * to be set programmatically and bubble to any parent form `onChange` event.\n   * Adding the `value` will cause React to consider the programmatic\n   * dispatch a duplicate and it will get swallowed.\n   */\n  return <input style={{ display: 'none' }} {...inputProps} ref={ref} defaultValue={value} />;\n};\n\nfunction getNextSortedValues(prevValues: number[] = [], nextValue: number, atIndex: number) {\n  const nextValues = [...prevValues];\n  nextValues[atIndex] = nextValue;\n  return nextValues.sort((a, b) => a - b);\n}\n\nfunction convertValueToPercentage(value: number, min: number, max: number) {\n  const maxSteps = max - min;\n  const percentPerStep = 100 / maxSteps;\n  const percentage = percentPerStep * (value - min);\n  return clamp(percentage, [0, 100]);\n}\n\n/**\n * Returns a label for each thumb when there are two or more thumbs\n */\nfunction getLabel(index: number, totalValues: number) {\n  if (totalValues > 2) {\n    return `Value ${index + 1} of ${totalValues}`;\n  } else if (totalValues === 2) {\n    return ['Minimum', 'Maximum'][index];\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * Given a `values` array and a `nextValue`, determine which value in\n * the array is closest to `nextValue` and return its index.\n *\n * @example\n * // returns 1\n * getClosestValueIndex([10, 30], 25);\n */\nfunction getClosestValueIndex(values: number[], nextValue: number) {\n  if (values.length === 1) return 0;\n  const distances = values.map((value) => Math.abs(value - nextValue));\n  const closestDistance = Math.min(...distances);\n  return distances.indexOf(closestDistance);\n}\n\n/**\n * Offsets the thumb centre point while sliding to ensure it remains\n * within the bounds of the slider when reaching the edges\n */\nfunction getThumbInBoundsOffset(width: number, left: number, direction: number) {\n  const halfWidth = width / 2;\n  const halfPercent = 50;\n  const offset = linearScale([0, halfPercent], [0, halfWidth]);\n  return (halfWidth - offset(left) * direction) * direction;\n}\n\n/**\n * Gets an array of steps between each value.\n *\n * @example\n * // returns [1, 9]\n * getStepsBetweenValues([10, 11, 20]);\n */\nfunction getStepsBetweenValues(values: number[]) {\n  return values.slice(0, -1).map((value, index) => values[index + 1] - value);\n}\n\n/**\n * Verifies the minimum steps between all values is greater than or equal\n * to the expected minimum steps.\n *\n * @example\n * // returns false\n * hasMinStepsBetweenValues([1,2,3], 2);\n *\n * @example\n * // returns true\n * hasMinStepsBetweenValues([1,2,3], 1);\n */\nfunction hasMinStepsBetweenValues(values: number[], minStepsBetweenValues: number) {\n  if (minStepsBetweenValues > 0) {\n    const stepsBetweenValues = getStepsBetweenValues(values);\n    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);\n    return actualMinStepsBetweenValues >= minStepsBetweenValues;\n  }\n  return true;\n}\n\n// https://github.com/tmcw-up-for-adoption/simple-linear-scale/blob/master/index.js\nfunction linearScale(input: readonly [number, number], output: readonly [number, number]) {\n  return (value: number) => {\n    if (input[0] === input[1] || output[0] === output[1]) return output[0];\n    const ratio = (output[1] - output[0]) / (input[1] - input[0]);\n    return output[0] + ratio * (value - input[0]);\n  };\n}\n\nfunction getDecimalCount(value: number) {\n  return (String(value).split('.')[1] || '').length;\n}\n\nfunction roundValue(value: number, decimalCount: number) {\n  const rounder = Math.pow(10, decimalCount);\n  return Math.round(value * rounder) / rounder;\n}\n\nconst Root = Slider;\nconst Track = SliderTrack;\nconst Range = SliderRange;\nconst Thumb = SliderThumb;\n\nexport {\n  createSliderScope,\n  //\n  Slider,\n  SliderTrack,\n  SliderRange,\n  SliderThumb,\n  //\n  Root,\n  Track,\n  Range,\n  Thumb,\n};\nexport type { SliderProps, SliderTrackProps, SliderRangeProps, SliderThumbProps };\n"]},"metadata":{},"sourceType":"module"}