{"ast":null,"code":"\"use client\"; // packages/react/dismissable-layer/src/DismissableLayer.tsx\n\nimport * as React from \"react\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { Primitive, dispatchDiscreteCustomEvent } from \"@radix-ui/react-primitive\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useEscapeKeydown } from \"@radix-ui/react-use-escape-keydown\";\nimport { jsx } from \"react/jsx-runtime\";\nvar DISMISSABLE_LAYER_NAME = \"DismissableLayer\";\nvar CONTEXT_UPDATE = \"dismissableLayer.update\";\nvar POINTER_DOWN_OUTSIDE = \"dismissableLayer.pointerDownOutside\";\nvar FOCUS_OUTSIDE = \"dismissableLayer.focusOutside\";\nvar originalBodyPointerEvents;\nvar DismissableLayerContext = React.createContext({\n  layers: /* @__PURE__ */new Set(),\n  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */new Set(),\n  branches: /* @__PURE__ */new Set()\n});\nvar DismissableLayer = React.forwardRef((props, forwardedRef) => {\n  const {\n    disableOutsidePointerEvents = false,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside,\n    onInteractOutside,\n    onDismiss,\n    ...layerProps\n  } = props;\n  const context = React.useContext(DismissableLayerContext);\n  const [node, setNode] = React.useState(null);\n  const ownerDocument = node?.ownerDocument ?? globalThis?.document;\n  const [, force] = React.useState({});\n  const composedRefs = useComposedRefs(forwardedRef, node2 => setNode(node2));\n  const layers = Array.from(context.layers);\n  const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);\n  const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);\n  const index = node ? layers.indexOf(node) : -1;\n  const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n  const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;\n  const pointerDownOutside = usePointerDownOutside(event => {\n    const target = event.target;\n    const isPointerDownOnBranch = [...context.branches].some(branch => branch.contains(target));\n    if (!isPointerEventsEnabled || isPointerDownOnBranch) return;\n    onPointerDownOutside?.(event);\n    onInteractOutside?.(event);\n    if (!event.defaultPrevented) onDismiss?.();\n  }, ownerDocument);\n  const focusOutside = useFocusOutside(event => {\n    const target = event.target;\n    const isFocusInBranch = [...context.branches].some(branch => branch.contains(target));\n    if (isFocusInBranch) return;\n    onFocusOutside?.(event);\n    onInteractOutside?.(event);\n    if (!event.defaultPrevented) onDismiss?.();\n  }, ownerDocument);\n  useEscapeKeydown(event => {\n    const isHighestLayer = index === context.layers.size - 1;\n    if (!isHighestLayer) return;\n    onEscapeKeyDown?.(event);\n\n    if (!event.defaultPrevented && onDismiss) {\n      event.preventDefault();\n      onDismiss();\n    }\n  }, ownerDocument);\n  React.useEffect(() => {\n    if (!node) return;\n\n    if (disableOutsidePointerEvents) {\n      if (context.layersWithOutsidePointerEventsDisabled.size === 0) {\n        originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;\n        ownerDocument.body.style.pointerEvents = \"none\";\n      }\n\n      context.layersWithOutsidePointerEventsDisabled.add(node);\n    }\n\n    context.layers.add(node);\n    dispatchUpdate();\n    return () => {\n      if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {\n        ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;\n      }\n    };\n  }, [node, ownerDocument, disableOutsidePointerEvents, context]);\n  React.useEffect(() => {\n    return () => {\n      if (!node) return;\n      context.layers.delete(node);\n      context.layersWithOutsidePointerEventsDisabled.delete(node);\n      dispatchUpdate();\n    };\n  }, [node, context]);\n  React.useEffect(() => {\n    const handleUpdate = () => force({});\n\n    document.addEventListener(CONTEXT_UPDATE, handleUpdate);\n    return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);\n  }, []);\n  return /* @__PURE__ */jsx(Primitive.div, { ...layerProps,\n    ref: composedRefs,\n    style: {\n      pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? \"auto\" : \"none\" : void 0,\n      ...props.style\n    },\n    onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),\n    onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),\n    onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, pointerDownOutside.onPointerDownCapture)\n  });\n});\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\nvar BRANCH_NAME = \"DismissableLayerBranch\";\nvar DismissableLayerBranch = React.forwardRef((props, forwardedRef) => {\n  const context = React.useContext(DismissableLayerContext);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  React.useEffect(() => {\n    const node = ref.current;\n\n    if (node) {\n      context.branches.add(node);\n      return () => {\n        context.branches.delete(node);\n      };\n    }\n  }, [context.branches]);\n  return /* @__PURE__ */jsx(Primitive.div, { ...props,\n    ref: composedRefs\n  });\n});\nDismissableLayerBranch.displayName = BRANCH_NAME;\n\nfunction usePointerDownOutside(onPointerDownOutside) {\n  let ownerDocument = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : globalThis?.document;\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside);\n  const isPointerInsideReactTreeRef = React.useRef(false);\n  const handleClickRef = React.useRef(() => {});\n  React.useEffect(() => {\n    const handlePointerDown = event => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        let handleAndDispatchPointerDownOutsideEvent2 = function () {\n          handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE, handlePointerDownOutside, eventDetail, {\n            discrete: true\n          });\n        };\n\n        var handleAndDispatchPointerDownOutsideEvent = handleAndDispatchPointerDownOutsideEvent2;\n        const eventDetail = {\n          originalEvent: event\n        };\n\n        if (event.pointerType === \"touch\") {\n          ownerDocument.removeEventListener(\"click\", handleClickRef.current);\n          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;\n          ownerDocument.addEventListener(\"click\", handleClickRef.current, {\n            once: true\n          });\n        } else {\n          handleAndDispatchPointerDownOutsideEvent2();\n        }\n      } else {\n        ownerDocument.removeEventListener(\"click\", handleClickRef.current);\n      }\n\n      isPointerInsideReactTreeRef.current = false;\n    };\n\n    const timerId = window.setTimeout(() => {\n      ownerDocument.addEventListener(\"pointerdown\", handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      ownerDocument.removeEventListener(\"pointerdown\", handlePointerDown);\n      ownerDocument.removeEventListener(\"click\", handleClickRef.current);\n    };\n  }, [ownerDocument, handlePointerDownOutside]);\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true\n  };\n}\n\nfunction useFocusOutside(onFocusOutside) {\n  let ownerDocument = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : globalThis?.document;\n  const handleFocusOutside = useCallbackRef(onFocusOutside);\n  const isFocusInsideReactTreeRef = React.useRef(false);\n  React.useEffect(() => {\n    const handleFocus = event => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = {\n          originalEvent: event\n        };\n        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {\n          discrete: false\n        });\n      }\n    };\n\n    ownerDocument.addEventListener(\"focusin\", handleFocus);\n    return () => ownerDocument.removeEventListener(\"focusin\", handleFocus);\n  }, [ownerDocument, handleFocusOutside]);\n  return {\n    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,\n    onBlurCapture: () => isFocusInsideReactTreeRef.current = false\n  };\n}\n\nfunction dispatchUpdate() {\n  const event = new CustomEvent(CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\n\nfunction handleAndDispatchCustomEvent(name, handler, detail, _ref) {\n  let {\n    discrete\n  } = _ref;\n  const target = detail.originalEvent.target;\n  const event = new CustomEvent(name, {\n    bubbles: false,\n    cancelable: true,\n    detail\n  });\n  if (handler) target.addEventListener(name, handler, {\n    once: true\n  });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(target, event);\n  } else {\n    target.dispatchEvent(event);\n  }\n}\n\nvar Root = DismissableLayer;\nvar Branch = DismissableLayerBranch;\nexport { Branch, DismissableLayer, DismissableLayerBranch, Root };","map":{"version":3,"mappings":"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","names":["React","composeEventHandlers","Primitive","dispatchDiscreteCustomEvent","useComposedRefs","useCallbackRef","useEscapeKeydown","DISMISSABLE_LAYER_NAME","CONTEXT_UPDATE","POINTER_DOWN_OUTSIDE","FOCUS_OUTSIDE","originalBodyPointerEvents","DismissableLayerContext","layers","Set","layersWithOutsidePointerEventsDisabled","branches","DismissableLayer","props","forwardedRef","disableOutsidePointerEvents","onEscapeKeyDown","onPointerDownOutside","onFocusOutside","onInteractOutside","onDismiss","layerProps","context","node","setNode","ownerDocument","globalThis","document","force","composedRefs","Array","from","highestLayerWithOutsidePointerEventsDisabled","slice","highestLayerWithOutsidePointerEventsDisabledIndex","indexOf","index","isBodyPointerEventsDisabled","size","isPointerEventsEnabled","pointerDownOutside","usePointerDownOutside","event","target","isPointerDownOnBranch","some","branch","contains","defaultPrevented","focusOutside","useFocusOutside","isFocusInBranch","isHighestLayer","preventDefault","body","style","pointerEvents","add","dispatchUpdate","delete","handleUpdate","addEventListener","removeEventListener","div","ref","onFocusCapture","onBlurCapture","onPointerDownCapture","displayName","BRANCH_NAME","DismissableLayerBranch","current","handlePointerDownOutside","isPointerInsideReactTreeRef","handleClickRef","handlePointerDown","handleAndDispatchPointerDownOutsideEvent","handleAndDispatchCustomEvent","eventDetail","discrete","originalEvent","pointerType","once","timerId","window","setTimeout","clearTimeout","handleFocusOutside","isFocusInsideReactTreeRef","handleFocus","CustomEvent","dispatchEvent","name","handler","detail","bubbles","cancelable","Root","Branch"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-dismissable-layer/src/DismissableLayer.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayer\n * -----------------------------------------------------------------------------------------------*/\n\nconst DISMISSABLE_LAYER_NAME = 'DismissableLayer';\nconst CONTEXT_UPDATE = 'dismissableLayer.update';\nconst POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';\nconst FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';\n\nlet originalBodyPointerEvents: string;\n\nconst DismissableLayerContext = React.createContext({\n  layers: new Set<DismissableLayerElement>(),\n  layersWithOutsidePointerEventsDisabled: new Set<DismissableLayerElement>(),\n  branches: new Set<DismissableLayerBranchElement>(),\n});\n\ntype DismissableLayerElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DismissableLayerProps extends PrimitiveDivProps {\n  /**\n   * When `true`, hover/focus/click interactions will be disabled on elements outside\n   * the `DismissableLayer`. Users will need to click twice on outside elements to\n   * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n   */\n  disableOutsidePointerEvents?: boolean;\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\n  /**\n   * Event handler called when the focus moves outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void;\n  /**\n   * Event handler called when an interaction happens outside the `DismissableLayer`.\n   * Specifically, when a `pointerdown` event happens outside or focus moves outside of it.\n   * Can be prevented.\n   */\n  onInteractOutside?: (event: PointerDownOutsideEvent | FocusOutsideEvent) => void;\n  /**\n   * Handler called when the `DismissableLayer` should be dismissed\n   */\n  onDismiss?: () => void;\n}\n\nconst DismissableLayer = React.forwardRef<DismissableLayerElement, DismissableLayerProps>(\n  (props, forwardedRef) => {\n    const {\n      disableOutsidePointerEvents = false,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      ...layerProps\n    } = props;\n    const context = React.useContext(DismissableLayerContext);\n    const [node, setNode] = React.useState<DismissableLayerElement | null>(null);\n    const ownerDocument = node?.ownerDocument ?? globalThis?.document;\n    const [, force] = React.useState({});\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const layers = Array.from(context.layers);\n    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1); // prettier-ignore\n    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled); // prettier-ignore\n    const index = node ? layers.indexOf(node) : -1;\n    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;\n\n    const pointerDownOutside = usePointerDownOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;\n      onPointerDownOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    }, ownerDocument);\n\n    const focusOutside = useFocusOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (isFocusInBranch) return;\n      onFocusOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    }, ownerDocument);\n\n    useEscapeKeydown((event) => {\n      const isHighestLayer = index === context.layers.size - 1;\n      if (!isHighestLayer) return;\n      onEscapeKeyDown?.(event);\n      if (!event.defaultPrevented && onDismiss) {\n        event.preventDefault();\n        onDismiss();\n      }\n    }, ownerDocument);\n\n    React.useEffect(() => {\n      if (!node) return;\n      if (disableOutsidePointerEvents) {\n        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {\n          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;\n          ownerDocument.body.style.pointerEvents = 'none';\n        }\n        context.layersWithOutsidePointerEventsDisabled.add(node);\n      }\n      context.layers.add(node);\n      dispatchUpdate();\n      return () => {\n        if (\n          disableOutsidePointerEvents &&\n          context.layersWithOutsidePointerEventsDisabled.size === 1\n        ) {\n          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;\n        }\n      };\n    }, [node, ownerDocument, disableOutsidePointerEvents, context]);\n\n    /**\n     * We purposefully prevent combining this effect with the `disableOutsidePointerEvents` effect\n     * because a change to `disableOutsidePointerEvents` would remove this layer from the stack\n     * and add it to the end again so the layering order wouldn't be _creation order_.\n     * We only want them to be removed from context stacks when unmounted.\n     */\n    React.useEffect(() => {\n      return () => {\n        if (!node) return;\n        context.layers.delete(node);\n        context.layersWithOutsidePointerEventsDisabled.delete(node);\n        dispatchUpdate();\n      };\n    }, [node, context]);\n\n    React.useEffect(() => {\n      const handleUpdate = () => force({});\n      document.addEventListener(CONTEXT_UPDATE, handleUpdate);\n      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);\n    }, []);\n\n    return (\n      <Primitive.div\n        {...layerProps}\n        ref={composedRefs}\n        style={{\n          pointerEvents: isBodyPointerEventsDisabled\n            ? isPointerEventsEnabled\n              ? 'auto'\n              : 'none'\n            : undefined,\n          ...props.style,\n        }}\n        onFocusCapture={composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture)}\n        onBlurCapture={composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture)}\n        onPointerDownCapture={composeEventHandlers(\n          props.onPointerDownCapture,\n          pointerDownOutside.onPointerDownCapture\n        )}\n      />\n    );\n  }\n);\n\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayerBranch\n * -----------------------------------------------------------------------------------------------*/\n\nconst BRANCH_NAME = 'DismissableLayerBranch';\n\ntype DismissableLayerBranchElement = React.ElementRef<typeof Primitive.div>;\ninterface DismissableLayerBranchProps extends PrimitiveDivProps {}\n\nconst DismissableLayerBranch = React.forwardRef<\n  DismissableLayerBranchElement,\n  DismissableLayerBranchProps\n>((props, forwardedRef) => {\n  const context = React.useContext(DismissableLayerContext);\n  const ref = React.useRef<DismissableLayerBranchElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      context.branches.add(node);\n      return () => {\n        context.branches.delete(node);\n      };\n    }\n  }, [context.branches]);\n\n  return <Primitive.div {...props} ref={composedRefs} />;\n});\n\nDismissableLayerBranch.displayName = BRANCH_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype PointerDownOutsideEvent = CustomEvent<{ originalEvent: PointerEvent }>;\ntype FocusOutsideEvent = CustomEvent<{ originalEvent: FocusEvent }>;\n\n/**\n * Listens for `pointerdown` outside a react subtree. We use `pointerdown` rather than `pointerup`\n * to mimic layer dismissing behaviour present in OS.\n * Returns props to pass to the node we want to check for outside events.\n */\nfunction usePointerDownOutside(\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside) as EventListener;\n  const isPointerInsideReactTreeRef = React.useRef(false);\n  const handleClickRef = React.useRef(() => {});\n\n  React.useEffect(() => {\n    const handlePointerDown = (event: PointerEvent) => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n\n        function handleAndDispatchPointerDownOutsideEvent() {\n          handleAndDispatchCustomEvent(\n            POINTER_DOWN_OUTSIDE,\n            handlePointerDownOutside,\n            eventDetail,\n            { discrete: true }\n          );\n        }\n\n        /**\n         * On touch devices, we need to wait for a click event because browsers implement\n         * a ~350ms delay between the time the user stops touching the display and when the\n         * browser executres events. We need to ensure we don't reactivate pointer-events within\n         * this timeframe otherwise the browser may execute events that should have been prevented.\n         *\n         * Additionally, this also lets us deal automatically with cancellations when a click event\n         * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.\n         *\n         * This is why we also continuously remove the previous listener, because we cannot be\n         * certain that it was raised, and therefore cleaned-up.\n         */\n        if (event.pointerType === 'touch') {\n          ownerDocument.removeEventListener('click', handleClickRef.current);\n          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;\n          ownerDocument.addEventListener('click', handleClickRef.current, { once: true });\n        } else {\n          handleAndDispatchPointerDownOutsideEvent();\n        }\n      } else {\n        // We need to remove the event listener in case the outside click has been canceled.\n        // See: https://github.com/radix-ui/primitives/issues/2171\n        ownerDocument.removeEventListener('click', handleClickRef.current);\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    /**\n     * if this hook executes in a component that mounts via a `pointerdown` event, the event\n     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n     * this by delaying the event listener registration on the document.\n     * This is not React specific, but rather how the DOM works, ie:\n     * ```\n     * button.addEventListener('pointerdown', () => {\n     *   console.log('I will log');\n     *   document.addEventListener('pointerdown', () => {\n     *     console.log('I will also log');\n     *   })\n     * });\n     */\n    const timerId = window.setTimeout(() => {\n      ownerDocument.addEventListener('pointerdown', handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      ownerDocument.removeEventListener('pointerdown', handlePointerDown);\n      ownerDocument.removeEventListener('click', handleClickRef.current);\n    };\n  }, [ownerDocument, handlePointerDownOutside]);\n\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),\n  };\n}\n\n/**\n * Listens for when focus happens outside a react subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\nfunction useFocusOutside(\n  onFocusOutside?: (event: FocusOutsideEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const handleFocusOutside = useCallbackRef(onFocusOutside) as EventListener;\n  const isFocusInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handleFocus = (event: FocusEvent) => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {\n          discrete: false,\n        });\n      }\n    };\n    ownerDocument.addEventListener('focusin', handleFocus);\n    return () => ownerDocument.removeEventListener('focusin', handleFocus);\n  }, [ownerDocument, handleFocusOutside]);\n\n  return {\n    onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),\n    onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),\n  };\n}\n\nfunction dispatchUpdate() {\n  const event = new CustomEvent(CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\n\nfunction handleAndDispatchCustomEvent<E extends CustomEvent, OriginalEvent extends Event>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: OriginalEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const target = detail.originalEvent.target;\n  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });\n  if (handler) target.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(target, event);\n  } else {\n    target.dispatchEvent(event);\n  }\n}\n\nconst Root = DismissableLayer;\nconst Branch = DismissableLayerBranch;\n\nexport {\n  DismissableLayer,\n  DismissableLayerBranch,\n  //\n  Root,\n  Branch,\n};\nexport type { DismissableLayerProps };\n"]},"metadata":{},"sourceType":"module"}