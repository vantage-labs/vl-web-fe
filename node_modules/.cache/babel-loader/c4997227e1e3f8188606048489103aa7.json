{"ast":null,"code":"\"use client\"; // packages/react/toast/src/Toast.tsx\n\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport * as DismissableLayer from \"@radix-ui/react-dismissable-layer\";\nimport { Portal } from \"@radix-ui/react-portal\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { Primitive, dispatchDiscreteCustomEvent } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { VisuallyHidden } from \"@radix-ui/react-visually-hidden\";\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nvar PROVIDER_NAME = \"ToastProvider\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(\"Toast\");\nvar [createToastContext, createToastScope] = createContextScope(\"Toast\", [createCollectionScope]);\nvar [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);\n\nvar ToastProvider = props => {\n  const {\n    __scopeToast,\n    label = \"Notification\",\n    duration = 5e3,\n    swipeDirection = \"right\",\n    swipeThreshold = 50,\n    children\n  } = props;\n  const [viewport, setViewport] = React.useState(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n\n  if (!label.trim()) {\n    console.error(`Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`);\n  }\n\n  return /* @__PURE__ */jsx(Collection.Provider, {\n    scope: __scopeToast,\n    children: /* @__PURE__ */jsx(ToastProviderProvider, {\n      scope: __scopeToast,\n      label,\n      duration,\n      swipeDirection,\n      swipeThreshold,\n      toastCount,\n      viewport,\n      onViewportChange: setViewport,\n      onToastAdd: React.useCallback(() => setToastCount(prevCount => prevCount + 1), []),\n      onToastRemove: React.useCallback(() => setToastCount(prevCount => prevCount - 1), []),\n      isFocusedToastEscapeKeyDownRef,\n      isClosePausedRef,\n      children\n    })\n  });\n};\n\nToastProvider.displayName = PROVIDER_NAME;\nvar VIEWPORT_NAME = \"ToastViewport\";\nvar VIEWPORT_DEFAULT_HOTKEY = [\"F8\"];\nvar VIEWPORT_PAUSE = \"toast.viewportPause\";\nvar VIEWPORT_RESUME = \"toast.viewportResume\";\nvar ToastViewport = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    hotkey = VIEWPORT_DEFAULT_HOTKEY,\n    label = \"Notifications ({hotkey})\",\n    ...viewportProps\n  } = props;\n  const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n  const getItems = useCollection(__scopeToast);\n  const wrapperRef = React.useRef(null);\n  const headFocusProxyRef = React.useRef(null);\n  const tailFocusProxyRef = React.useRef(null);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n  const hotkeyLabel = hotkey.join(\"+\").replace(/Key/g, \"\").replace(/Digit/g, \"\");\n  const hasToasts = context.toastCount > 0;\n  React.useEffect(() => {\n    const handleKeyDown = event => {\n      const isHotkeyPressed = hotkey.length !== 0 && hotkey.every(key => event[key] || event.code === key);\n      if (isHotkeyPressed) ref.current?.focus();\n    };\n\n    document.addEventListener(\"keydown\", handleKeyDown);\n    return () => document.removeEventListener(\"keydown\", handleKeyDown);\n  }, [hotkey]);\n  React.useEffect(() => {\n    const wrapper = wrapperRef.current;\n    const viewport = ref.current;\n\n    if (hasToasts && wrapper && viewport) {\n      const handlePause = () => {\n        if (!context.isClosePausedRef.current) {\n          const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n          viewport.dispatchEvent(pauseEvent);\n          context.isClosePausedRef.current = true;\n        }\n      };\n\n      const handleResume = () => {\n        if (context.isClosePausedRef.current) {\n          const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n          viewport.dispatchEvent(resumeEvent);\n          context.isClosePausedRef.current = false;\n        }\n      };\n\n      const handleFocusOutResume = event => {\n        const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);\n        if (isFocusMovingOutside) handleResume();\n      };\n\n      const handlePointerLeaveResume = () => {\n        const isFocusInside = wrapper.contains(document.activeElement);\n        if (!isFocusInside) handleResume();\n      };\n\n      wrapper.addEventListener(\"focusin\", handlePause);\n      wrapper.addEventListener(\"focusout\", handleFocusOutResume);\n      wrapper.addEventListener(\"pointermove\", handlePause);\n      wrapper.addEventListener(\"pointerleave\", handlePointerLeaveResume);\n      window.addEventListener(\"blur\", handlePause);\n      window.addEventListener(\"focus\", handleResume);\n      return () => {\n        wrapper.removeEventListener(\"focusin\", handlePause);\n        wrapper.removeEventListener(\"focusout\", handleFocusOutResume);\n        wrapper.removeEventListener(\"pointermove\", handlePause);\n        wrapper.removeEventListener(\"pointerleave\", handlePointerLeaveResume);\n        window.removeEventListener(\"blur\", handlePause);\n        window.removeEventListener(\"focus\", handleResume);\n      };\n    }\n  }, [hasToasts, context.isClosePausedRef]);\n  const getSortedTabbableCandidates = React.useCallback(_ref => {\n    let {\n      tabbingDirection\n    } = _ref;\n    const toastItems = getItems();\n    const tabbableCandidates = toastItems.map(toastItem => {\n      const toastNode = toastItem.ref.current;\n      const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n      return tabbingDirection === \"forwards\" ? toastTabbableCandidates : toastTabbableCandidates.reverse();\n    });\n    return (tabbingDirection === \"forwards\" ? tabbableCandidates.reverse() : tabbableCandidates).flat();\n  }, [getItems]);\n  React.useEffect(() => {\n    const viewport = ref.current;\n\n    if (viewport) {\n      const handleKeyDown = event => {\n        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n        const isTabKey = event.key === \"Tab\" && !isMetaKey;\n\n        if (isTabKey) {\n          const focusedElement = document.activeElement;\n          const isTabbingBackwards = event.shiftKey;\n          const targetIsViewport = event.target === viewport;\n\n          if (targetIsViewport && isTabbingBackwards) {\n            headFocusProxyRef.current?.focus();\n            return;\n          }\n\n          const tabbingDirection = isTabbingBackwards ? \"backwards\" : \"forwards\";\n          const sortedCandidates = getSortedTabbableCandidates({\n            tabbingDirection\n          });\n          const index = sortedCandidates.findIndex(candidate => candidate === focusedElement);\n\n          if (focusFirst(sortedCandidates.slice(index + 1))) {\n            event.preventDefault();\n          } else {\n            isTabbingBackwards ? headFocusProxyRef.current?.focus() : tailFocusProxyRef.current?.focus();\n          }\n        }\n      };\n\n      viewport.addEventListener(\"keydown\", handleKeyDown);\n      return () => viewport.removeEventListener(\"keydown\", handleKeyDown);\n    }\n  }, [getItems, getSortedTabbableCandidates]);\n  return /* @__PURE__ */jsxs(DismissableLayer.Branch, {\n    ref: wrapperRef,\n    role: \"region\",\n    \"aria-label\": label.replace(\"{hotkey}\", hotkeyLabel),\n    tabIndex: -1,\n    style: {\n      pointerEvents: hasToasts ? void 0 : \"none\"\n    },\n    children: [hasToasts && /* @__PURE__ */jsx(FocusProxy, {\n      ref: headFocusProxyRef,\n      onFocusFromOutsideViewport: () => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: \"forwards\"\n        });\n        focusFirst(tabbableCandidates);\n      }\n    }), /* @__PURE__ */jsx(Collection.Slot, {\n      scope: __scopeToast,\n      children: /* @__PURE__ */jsx(Primitive.ol, {\n        tabIndex: -1,\n        ...viewportProps,\n        ref: composedRefs\n      })\n    }), hasToasts && /* @__PURE__ */jsx(FocusProxy, {\n      ref: tailFocusProxyRef,\n      onFocusFromOutsideViewport: () => {\n        const tabbableCandidates = getSortedTabbableCandidates({\n          tabbingDirection: \"backwards\"\n        });\n        focusFirst(tabbableCandidates);\n      }\n    })]\n  });\n});\nToastViewport.displayName = VIEWPORT_NAME;\nvar FOCUS_PROXY_NAME = \"ToastFocusProxy\";\nvar FocusProxy = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    onFocusFromOutsideViewport,\n    ...proxyProps\n  } = props;\n  const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n  return /* @__PURE__ */jsx(VisuallyHidden, {\n    \"aria-hidden\": true,\n    tabIndex: 0,\n    ...proxyProps,\n    ref: forwardedRef,\n    style: {\n      position: \"fixed\"\n    },\n    onFocus: event => {\n      const prevFocusedElement = event.relatedTarget;\n      const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n      if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n    }\n  });\n});\nFocusProxy.displayName = FOCUS_PROXY_NAME;\nvar TOAST_NAME = \"Toast\";\nvar TOAST_SWIPE_START = \"toast.swipeStart\";\nvar TOAST_SWIPE_MOVE = \"toast.swipeMove\";\nvar TOAST_SWIPE_CANCEL = \"toast.swipeCancel\";\nvar TOAST_SWIPE_END = \"toast.swipeEnd\";\nvar Toast = React.forwardRef((props, forwardedRef) => {\n  const {\n    forceMount,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    ...toastProps\n  } = props;\n  const [open = true, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: onOpenChange\n  });\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || open,\n    children: /* @__PURE__ */jsx(ToastImpl, {\n      open,\n      ...toastProps,\n      ref: forwardedRef,\n      onClose: () => setOpen(false),\n      onPause: useCallbackRef(props.onPause),\n      onResume: useCallbackRef(props.onResume),\n      onSwipeStart: composeEventHandlers(props.onSwipeStart, event => {\n        event.currentTarget.setAttribute(\"data-swipe\", \"start\");\n      }),\n      onSwipeMove: composeEventHandlers(props.onSwipeMove, event => {\n        const {\n          x,\n          y\n        } = event.detail.delta;\n        event.currentTarget.setAttribute(\"data-swipe\", \"move\");\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-x\", `${x}px`);\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-move-y\", `${y}px`);\n      }),\n      onSwipeCancel: composeEventHandlers(props.onSwipeCancel, event => {\n        event.currentTarget.setAttribute(\"data-swipe\", \"cancel\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-end-y\");\n      }),\n      onSwipeEnd: composeEventHandlers(props.onSwipeEnd, event => {\n        const {\n          x,\n          y\n        } = event.detail.delta;\n        event.currentTarget.setAttribute(\"data-swipe\", \"end\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-x\");\n        event.currentTarget.style.removeProperty(\"--radix-toast-swipe-move-y\");\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-x\", `${x}px`);\n        event.currentTarget.style.setProperty(\"--radix-toast-swipe-end-y\", `${y}px`);\n        setOpen(false);\n      })\n    })\n  });\n});\nToast.displayName = TOAST_NAME;\nvar [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {}\n\n});\nvar ToastImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    type = \"foreground\",\n    duration: durationProp,\n    open,\n    onClose,\n    onEscapeKeyDown,\n    onPause,\n    onResume,\n    onSwipeStart,\n    onSwipeMove,\n    onSwipeCancel,\n    onSwipeEnd,\n    ...toastProps\n  } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [node, setNode] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node2 => setNode(node2));\n  const pointerStartRef = React.useRef(null);\n  const swipeDeltaRef = React.useRef(null);\n  const duration = durationProp || context.duration;\n  const closeTimerStartTimeRef = React.useRef(0);\n  const closeTimerRemainingTimeRef = React.useRef(duration);\n  const closeTimerRef = React.useRef(0);\n  const {\n    onToastAdd,\n    onToastRemove\n  } = context;\n  const handleClose = useCallbackRef(() => {\n    const isFocusInToast = node?.contains(document.activeElement);\n    if (isFocusInToast) context.viewport?.focus();\n    onClose();\n  });\n  const startTimer = React.useCallback(duration2 => {\n    if (!duration2 || duration2 === Infinity) return;\n    window.clearTimeout(closeTimerRef.current);\n    closeTimerStartTimeRef.current = /* @__PURE__ */new Date().getTime();\n    closeTimerRef.current = window.setTimeout(handleClose, duration2);\n  }, [handleClose]);\n  React.useEffect(() => {\n    const viewport = context.viewport;\n\n    if (viewport) {\n      const handleResume = () => {\n        startTimer(closeTimerRemainingTimeRef.current);\n        onResume?.();\n      };\n\n      const handlePause = () => {\n        const elapsedTime = /* @__PURE__ */new Date().getTime() - closeTimerStartTimeRef.current;\n        closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n        window.clearTimeout(closeTimerRef.current);\n        onPause?.();\n      };\n\n      viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n      viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n      return () => {\n        viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n      };\n    }\n  }, [context.viewport, duration, onPause, onResume, startTimer]);\n  React.useEffect(() => {\n    if (open && !context.isClosePausedRef.current) startTimer(duration);\n  }, [open, duration, context.isClosePausedRef, startTimer]);\n  React.useEffect(() => {\n    onToastAdd();\n    return () => onToastRemove();\n  }, [onToastAdd, onToastRemove]);\n  const announceTextContent = React.useMemo(() => {\n    return node ? getAnnounceTextContent(node) : null;\n  }, [node]);\n  if (!context.viewport) return null;\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [announceTextContent && /* @__PURE__ */jsx(ToastAnnounce, {\n      __scopeToast,\n      role: \"status\",\n      \"aria-live\": type === \"foreground\" ? \"assertive\" : \"polite\",\n      \"aria-atomic\": true,\n      children: announceTextContent\n    }), /* @__PURE__ */jsx(ToastInteractiveProvider, {\n      scope: __scopeToast,\n      onClose: handleClose,\n      children: ReactDOM.createPortal( /* @__PURE__ */jsx(Collection.ItemSlot, {\n        scope: __scopeToast,\n        children: /* @__PURE__ */jsx(DismissableLayer.Root, {\n          asChild: true,\n          onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {\n            if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n            context.isFocusedToastEscapeKeyDownRef.current = false;\n          }),\n          children: /* @__PURE__ */jsx(Primitive.li, {\n            role: \"status\",\n            \"aria-live\": \"off\",\n            \"aria-atomic\": true,\n            tabIndex: 0,\n            \"data-state\": open ? \"open\" : \"closed\",\n            \"data-swipe-direction\": context.swipeDirection,\n            ...toastProps,\n            ref: composedRefs,\n            style: {\n              userSelect: \"none\",\n              touchAction: \"none\",\n              ...props.style\n            },\n            onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n              if (event.key !== \"Escape\") return;\n              onEscapeKeyDown?.(event.nativeEvent);\n\n              if (!event.nativeEvent.defaultPrevented) {\n                context.isFocusedToastEscapeKeyDownRef.current = true;\n                handleClose();\n              }\n            }),\n            onPointerDown: composeEventHandlers(props.onPointerDown, event => {\n              if (event.button !== 0) return;\n              pointerStartRef.current = {\n                x: event.clientX,\n                y: event.clientY\n              };\n            }),\n            onPointerMove: composeEventHandlers(props.onPointerMove, event => {\n              if (!pointerStartRef.current) return;\n              const x = event.clientX - pointerStartRef.current.x;\n              const y = event.clientY - pointerStartRef.current.y;\n              const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n              const isHorizontalSwipe = [\"left\", \"right\"].includes(context.swipeDirection);\n              const clamp = [\"left\", \"up\"].includes(context.swipeDirection) ? Math.min : Math.max;\n              const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n              const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n              const moveStartBuffer = event.pointerType === \"touch\" ? 10 : 2;\n              const delta = {\n                x: clampedX,\n                y: clampedY\n              };\n              const eventDetail = {\n                originalEvent: event,\n                delta\n              };\n\n              if (hasSwipeMoveStarted) {\n                swipeDeltaRef.current = delta;\n                handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                  discrete: false\n                });\n              } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                swipeDeltaRef.current = delta;\n                handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                  discrete: false\n                });\n                event.target.setPointerCapture(event.pointerId);\n              } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                pointerStartRef.current = null;\n              }\n            }),\n            onPointerUp: composeEventHandlers(props.onPointerUp, event => {\n              const delta = swipeDeltaRef.current;\n              const target = event.target;\n\n              if (target.hasPointerCapture(event.pointerId)) {\n                target.releasePointerCapture(event.pointerId);\n              }\n\n              swipeDeltaRef.current = null;\n              pointerStartRef.current = null;\n\n              if (delta) {\n                const toast = event.currentTarget;\n                const eventDetail = {\n                  originalEvent: event,\n                  delta\n                };\n\n                if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {\n                  handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                    discrete: true\n                  });\n                } else {\n                  handleAndDispatchCustomEvent(TOAST_SWIPE_CANCEL, onSwipeCancel, eventDetail, {\n                    discrete: true\n                  });\n                }\n\n                toast.addEventListener(\"click\", event2 => event2.preventDefault(), {\n                  once: true\n                });\n              }\n            })\n          })\n        })\n      }), context.viewport)\n    })]\n  });\n});\n\nvar ToastAnnounce = props => {\n  const {\n    __scopeToast,\n    children,\n    ...announceProps\n  } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n  useNextFrame(() => setRenderAnnounceText(true));\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);\n    return () => window.clearTimeout(timer);\n  }, []);\n  return isAnnounced ? null : /* @__PURE__ */jsx(Portal, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(VisuallyHidden, { ...announceProps,\n      children: renderAnnounceText && /* @__PURE__ */jsxs(Fragment, {\n        children: [context.label, \" \", children]\n      })\n    })\n  });\n};\n\nvar TITLE_NAME = \"ToastTitle\";\nvar ToastTitle = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...titleProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, { ...titleProps,\n    ref: forwardedRef\n  });\n});\nToastTitle.displayName = TITLE_NAME;\nvar DESCRIPTION_NAME = \"ToastDescription\";\nvar ToastDescription = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...descriptionProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, { ...descriptionProps,\n    ref: forwardedRef\n  });\n});\nToastDescription.displayName = DESCRIPTION_NAME;\nvar ACTION_NAME = \"ToastAction\";\nvar ToastAction = React.forwardRef((props, forwardedRef) => {\n  const {\n    altText,\n    ...actionProps\n  } = props;\n\n  if (!altText.trim()) {\n    console.error(`Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`);\n    return null;\n  }\n\n  return /* @__PURE__ */jsx(ToastAnnounceExclude, {\n    altText,\n    asChild: true,\n    children: /* @__PURE__ */jsx(ToastClose, { ...actionProps,\n      ref: forwardedRef\n    })\n  });\n});\nToastAction.displayName = ACTION_NAME;\nvar CLOSE_NAME = \"ToastClose\";\nvar ToastClose = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    ...closeProps\n  } = props;\n  const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n  return /* @__PURE__ */jsx(ToastAnnounceExclude, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(Primitive.button, {\n      type: \"button\",\n      ...closeProps,\n      ref: forwardedRef,\n      onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)\n    })\n  });\n});\nToastClose.displayName = CLOSE_NAME;\nvar ToastAnnounceExclude = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeToast,\n    altText,\n    ...announceExcludeProps\n  } = props;\n  return /* @__PURE__ */jsx(Primitive.div, {\n    \"data-radix-toast-announce-exclude\": \"\",\n    \"data-radix-toast-announce-alt\": altText || void 0,\n    ...announceExcludeProps,\n    ref: forwardedRef\n  });\n});\n\nfunction getAnnounceTextContent(container) {\n  const textContent = [];\n  const childNodes = Array.from(container.childNodes);\n  childNodes.forEach(node => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === \"none\";\n      const isExcluded = node.dataset.radixToastAnnounceExclude === \"\";\n\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n  return textContent;\n}\n\nfunction handleAndDispatchCustomEvent(name, handler, detail, _ref2) {\n  let {\n    discrete\n  } = _ref2;\n  const currentTarget = detail.originalEvent.currentTarget;\n  const event = new CustomEvent(name, {\n    bubbles: true,\n    cancelable: true,\n    detail\n  });\n  if (handler) currentTarget.addEventListener(name, handler, {\n    once: true\n  });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\n\nvar isDeltaInDirection = function (delta, direction) {\n  let threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n\n  if (direction === \"left\" || direction === \"right\") {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\n\nfunction useNextFrame() {\n  let callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\n\nfunction isHTMLElement(node) {\n  return node.nodeType === node.ELEMENT_NODE;\n}\n\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n\n  return nodes;\n}\n\nfunction focusFirst(candidates) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some(candidate => {\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nvar Provider = ToastProvider;\nvar Viewport = ToastViewport;\nvar Root2 = Toast;\nvar Title = ToastTitle;\nvar Description = ToastDescription;\nvar Action = ToastAction;\nvar Close = ToastClose;\nexport { Action, Close, Description, Provider, Root2 as Root, Title, Toast, ToastAction, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport, Viewport, createToastScope };","map":{"version":3,"mappings":";;AAAA,YAAYA,KAAZ,MAAuB,OAAvB;AACA,YAAYC,QAAZ,MAA0B,WAA1B;AACA,SAASC,oBAAT,QAAqC,qBAArC;AACA,SAASC,eAAT,QAAgC,8BAAhC;AACA,SAASC,gBAAT,QAAiC,4BAAjC;AACA,SAASC,kBAAT,QAAmC,yBAAnC;AACA,YAAYC,gBAAZ,MAAkC,mCAAlC;AACA,SAASC,MAAT,QAAuB,wBAAvB;AACA,SAASC,QAAT,QAAyB,0BAAzB;AACA,SAASC,SAAT,EAAoBC,2BAApB,QAAuD,2BAAvD;AACA,SAASC,cAAT,QAA+B,kCAA/B;AACA,SAASC,oBAAT,QAAqC,wCAArC;AACA,SAASC,eAAT,QAAgC,mCAAhC;AACA,SAASC,cAAT,QAA+B,iCAA/B;AA+EM,SAycAC,QAzcA,OA2LAC,IA3LA;AAvEN,IAAMC,gBAAgB,eAAtB;AAEA,IAAM,CAACC,UAAD,EAAaC,aAAb,EAA4BC,qBAA5B,IAAqDhB,iBAA+B,OAA/B,CAA3D;AAkBA,IAAM,CAACiB,kBAAD,EAAqBC,gBAArB,IAAyCjB,mBAAmB,OAAnB,EAA4B,CAACe,qBAAD,CAA5B,CAA/C;AACA,IAAM,CAACG,qBAAD,EAAwBC,uBAAxB,IACJH,mBAA8CJ,aAA9C,CADF;;AA4BA,IAAMQ,gBAA+CC,KAAD,IAA4C;AAC9F,QAAM;AACJC,gBADI;AAEJC,YAAQ,cAFJ;AAGJC,eAAW,GAHP;AAIJC,qBAAiB,OAJb;AAKJC,qBAAiB,EALb;AAMJC;AANI,MAOFN,KAPJ;AAQA,QAAM,CAACO,QAAD,EAAWC,WAAX,IAAgClC,eAAsC,IAAtC,CAAtC;AACA,QAAM,CAACmC,UAAD,EAAaC,aAAb,IAAoCpC,eAAS,CAAT,CAA1C;AACA,QAAMqC,iCAAuCrC,aAAO,KAAP,CAA7C;AACA,QAAMsC,mBAAyBtC,aAAO,KAAP,CAA/B;;AAEA,MAAI,CAAC4B,MAAMW,IAAN,EAAL,EAAmB;AACjBC,YAAQC,KAAR,CACE,wCAAwCxB,aAAa,oCADvD;AAGF;;AAEA,SACE,mBAACC,WAAWwB,QAAZ,EAAC;AAAoBC,WAAOhB,YAA3B;AACCK,iCAACT,qBAAD,EAAC;AACCoB,aAAOhB,YADR;AAECC,WAFD;AAGCC,cAHD;AAICC,oBAJD;AAKCC,oBALD;AAMCI,gBAND;AAOCF,cAPD;AAQCW,wBAAkBV,WARnB;AASCW,kBAAkB7C,kBAAY,MAAMoC,cAAeU,SAAD,IAAeA,YAAY,CAAzC,CAAlB,EAA+D,EAA/D,CATnB;AAUCC,qBAAqB/C,kBAAY,MAAMoC,cAAeU,SAAD,IAAeA,YAAY,CAAzC,CAAlB,EAA+D,EAA/D,CAVtB;AAWCT,oCAXD;AAYCC,sBAZD;AAcEN;AAdF,KAAD;AADD,GAAD,CADF;AAoBF,CAxCA;;AA0CAP,cAAcuB,WAAd,GAA4B/B,aAA5B;AAMA,IAAMgC,gBAAgB,eAAtB;AACA,IAAMC,0BAA0B,CAAC,IAAD,CAAhC;AACA,IAAMC,iBAAiB,qBAAvB;AACA,IAAMC,kBAAkB,sBAAxB;AAkBA,IAAMC,gBAAsBrD,iBAC1B,CAAC0B,KAAD,EAAyC4B,YAAzC,KAA0D;AACxD,QAAM;AACJ3B,gBADI;AAEJ4B,aAASL,uBAFL;AAGJtB,YAAQ,0BAHJ;AAIJ,OAAG4B;AAJC,MAKF9B,KALJ;AAMA,QAAM+B,UAAUjC,wBAAwByB,aAAxB,EAAuCtB,YAAvC,CAAhB;AACA,QAAM+B,WAAWvC,cAAcQ,YAAd,CAAjB;AACA,QAAMgC,aAAmB3D,aAAuB,IAAvB,CAAzB;AACA,QAAM4D,oBAA0B5D,aAA0B,IAA1B,CAAhC;AACA,QAAM6D,oBAA0B7D,aAA0B,IAA1B,CAAhC;AACA,QAAM8D,MAAY9D,aAA6B,IAA7B,CAAlB;AACA,QAAM+D,eAAe5D,gBAAgBmD,YAAhB,EAA8BQ,GAA9B,EAAmCL,QAAQb,gBAA3C,CAArB;AACA,QAAMoB,cAAcT,OAAOU,IAAP,CAAY,GAAZ,EAAiBC,OAAjB,CAAyB,MAAzB,EAAiC,EAAjC,EAAqCA,OAArC,CAA6C,QAA7C,EAAuD,EAAvD,CAApB;AACA,QAAMC,YAAYV,QAAQtB,UAAR,GAAqB,CAAvC;AAEMnC,kBAAU,MAAM;AACpB,UAAMoE,gBAAiBC,KAAD,IAA0B;AAG9C,YAAMC,kBACJf,OAAOgB,MAAP,KAAkB,CAAlB,IAAuBhB,OAAOiB,KAAP,CAAcC,GAAD,IAAUJ,MAAcI,GAAd,KAAsBJ,MAAMK,IAAN,KAAeD,GAA5D,CADzB;AAEA,UAAIH,eAAJ,EAAqBR,IAAIa,OAAJ,EAAaC,KAAb;AACvB,KANA;;AAOAC,aAASC,gBAAT,CAA0B,SAA1B,EAAqCV,aAArC;AACA,WAAO,MAAMS,SAASE,mBAAT,CAA6B,SAA7B,EAAwCX,aAAxC,CAAb;AACF,GAVM,EAUH,CAACb,MAAD,CAVG;AAYAvD,kBAAU,MAAM;AACpB,UAAMgF,UAAUrB,WAAWgB,OAA3B;AACA,UAAM1C,WAAW6B,IAAIa,OAArB;;AACA,QAAIR,aAAaa,OAAb,IAAwB/C,QAA5B,EAAsC;AACpC,YAAMgD,cAAc,MAAM;AACxB,YAAI,CAACxB,QAAQnB,gBAAR,CAAyBqC,OAA9B,EAAuC;AACrC,gBAAMO,aAAa,IAAIC,WAAJ,CAAgBhC,cAAhB,CAAnB;AACAlB,mBAASmD,aAAT,CAAuBF,UAAvB;AACAzB,kBAAQnB,gBAAR,CAAyBqC,OAAzB,GAAmC,IAAnC;AACF;AACF,OANA;;AAQA,YAAMU,eAAe,MAAM;AACzB,YAAI5B,QAAQnB,gBAAR,CAAyBqC,OAA7B,EAAsC;AACpC,gBAAMW,cAAc,IAAIH,WAAJ,CAAgB/B,eAAhB,CAApB;AACAnB,mBAASmD,aAAT,CAAuBE,WAAvB;AACA7B,kBAAQnB,gBAAR,CAAyBqC,OAAzB,GAAmC,KAAnC;AACF;AACF,OANA;;AAQA,YAAMY,uBAAwBlB,KAAD,IAAuB;AAClD,cAAMmB,uBAAuB,CAACR,QAAQS,QAAR,CAAiBpB,MAAMqB,aAAvB,CAA9B;AACA,YAAIF,oBAAJ,EAA0BH;AAC5B,OAHA;;AAKA,YAAMM,2BAA2B,MAAM;AACrC,cAAMC,gBAAgBZ,QAAQS,QAAR,CAAiBZ,SAASgB,aAA1B,CAAtB;AACA,YAAI,CAACD,aAAL,EAAoBP;AACtB,OAHA;;AAMAL,cAAQF,gBAAR,CAAyB,SAAzB,EAAoCG,WAApC;AACAD,cAAQF,gBAAR,CAAyB,UAAzB,EAAqCS,oBAArC;AACAP,cAAQF,gBAAR,CAAyB,aAAzB,EAAwCG,WAAxC;AACAD,cAAQF,gBAAR,CAAyB,cAAzB,EAAyCa,wBAAzC;AACAG,aAAOhB,gBAAP,CAAwB,MAAxB,EAAgCG,WAAhC;AACAa,aAAOhB,gBAAP,CAAwB,OAAxB,EAAiCO,YAAjC;AACA,aAAO,MAAM;AACXL,gBAAQD,mBAAR,CAA4B,SAA5B,EAAuCE,WAAvC;AACAD,gBAAQD,mBAAR,CAA4B,UAA5B,EAAwCQ,oBAAxC;AACAP,gBAAQD,mBAAR,CAA4B,aAA5B,EAA2CE,WAA3C;AACAD,gBAAQD,mBAAR,CAA4B,cAA5B,EAA4CY,wBAA5C;AACAG,eAAOf,mBAAP,CAA2B,MAA3B,EAAmCE,WAAnC;AACAa,eAAOf,mBAAP,CAA2B,OAA3B,EAAoCM,YAApC;AACF,OAPA;AAQF;AACF,GA9CM,EA8CH,CAAClB,SAAD,EAAYV,QAAQnB,gBAApB,CA9CG;AAgDN,QAAMyD,8BAAoC/F,kBACxC,QAA0E;AAAA,QAAzE;AAAEgG;AAAF,KAAyE;AACxE,UAAMC,aAAavC,UAAnB;AACA,UAAMwC,qBAAqBD,WAAWE,GAAX,CAAgBC,SAAD,IAAe;AACvD,YAAMC,YAAYD,UAAUtC,GAAV,CAAca,OAAhC;AACA,YAAM2B,0BAA0B,CAACD,SAAD,EAAY,GAAGE,sBAAsBF,SAAtB,CAAf,CAAhC;AACA,aAAOL,qBAAqB,UAArB,GACHM,uBADG,GAEHA,wBAAwBE,OAAxB,EAFJ;AAGD,KAN0B,CAA3B;AAOA,YACER,qBAAqB,UAArB,GAAkCE,mBAAmBM,OAAnB,EAAlC,GAAiEN,kBADnE,EAEEO,IAFF;AAGF,GAbwC,EAcxC,CAAC/C,QAAD,CAdwC,CAA1C;AAiBM1D,kBAAU,MAAM;AACpB,UAAMiC,WAAW6B,IAAIa,OAArB;;AAIA,QAAI1C,QAAJ,EAAc;AACZ,YAAMmC,gBAAiBC,KAAD,IAA0B;AAC9C,cAAMqC,YAAYrC,MAAMsC,MAAN,IAAgBtC,MAAMuC,OAAtB,IAAiCvC,MAAMwC,OAAzD;AACA,cAAMC,WAAWzC,MAAMI,GAAN,KAAc,KAAd,IAAuB,CAACiC,SAAzC;;AAEA,YAAII,QAAJ,EAAc;AACZ,gBAAMC,iBAAiBlC,SAASgB,aAAhC;AACA,gBAAMmB,qBAAqB3C,MAAM4C,QAAjC;AACA,gBAAMC,mBAAmB7C,MAAM8C,MAAN,KAAiBlF,QAA1C;;AAIA,cAAIiF,oBAAoBF,kBAAxB,EAA4C;AAC1CpD,8BAAkBe,OAAlB,EAA2BC,KAA3B;AACA;AACF;;AAEA,gBAAMoB,mBAAmBgB,qBAAqB,WAArB,GAAmC,UAA5D;AACA,gBAAMI,mBAAmBrB,4BAA4B;AAAEC;AAAF,WAA5B,CAAzB;AACA,gBAAMqB,QAAQD,iBAAiBE,SAAjB,CAA4BC,SAAD,IAAeA,cAAcR,cAAxD,CAAd;;AACA,cAAIS,WAAWJ,iBAAiBK,KAAjB,CAAuBJ,QAAQ,CAA/B,CAAX,CAAJ,EAAmD;AACjDhD,kBAAMqD,cAAN;AACF,WAFA,MAEO;AAILV,iCACIpD,kBAAkBe,OAAlB,EAA2BC,KAA3B,EADJ,GAEIf,kBAAkBc,OAAlB,EAA2BC,KAA3B,EAFJ;AAGF;AACF;AACF,OA9BA;;AAiCA3C,eAAS6C,gBAAT,CAA0B,SAA1B,EAAqCV,aAArC;AACA,aAAO,MAAMnC,SAAS8C,mBAAT,CAA6B,SAA7B,EAAwCX,aAAxC,CAAb;AACF;AACF,GA1CM,EA0CH,CAACV,QAAD,EAAWqC,2BAAX,CA1CG;AA4CN,SACE,oBAAkBzF,uBAAlB,EAAC;AACCwD,SAAKH,UADN;AAECgE,UAAK,QAFN;AAGC,kBAAY/F,MAAMsC,OAAN,CAAc,UAAd,EAA0BF,WAA1B,CAHb;AAKC4D,cAAU,EALX;AAQCC,WAAO;AAAEC,qBAAe3D,YAAY,MAAZ,GAAwB;AAAzC,KARR;AAUEnC,4BACC,mBAAC+F,UAAD,EAAC;AACCjE,WAAKF,iBADN;AAECoE,kCAA4B,MAAM;AAChC,cAAM9B,qBAAqBH,4BAA4B;AACrDC,4BAAkB;AADmC,SAA5B,CAA3B;AAGAwB,mBAAWtB,kBAAX;AACF;AAPD,KAAD,CADD,EAeD,mBAAChF,WAAW+G,IAAZ,EAAC;AAAgBtF,aAAOhB,YAAvB;AACCK,mCAACvB,UAAUyH,EAAX,EAAC;AAAaN,kBAAU,EAAvB;AAA4B,WAAGpE,aAA/B;AAA8CM,aAAKC;AAAnD,OAAD;AADD,KAAD,CAfC,EAkBAI,aACC,mBAAC4D,UAAD,EAAC;AACCjE,WAAKD,iBADN;AAECmE,kCAA4B,MAAM;AAChC,cAAM9B,qBAAqBH,4BAA4B;AACrDC,4BAAkB;AADmC,SAA5B,CAA3B;AAGAwB,mBAAWtB,kBAAX;AACF;AAPD,KAAD,CAnBD;AAVF,GAAD,CADF;AA0CF,CArL0B,CAA5B;AAwLA7C,cAAcL,WAAd,GAA4BC,aAA5B;AAIA,IAAMkF,mBAAmB,iBAAzB;AAQA,IAAMJ,aAAmB/H,iBACvB,CAAC0B,KAAD,EAAQ4B,YAAR,KAAyB;AACvB,QAAM;AAAE3B,gBAAF;AAAgBqG,8BAAhB;AAA4C,OAAGI;AAA/C,MAA8D1G,KAApE;AACA,QAAM+B,UAAUjC,wBAAwB2G,gBAAxB,EAA0CxG,YAA1C,CAAhB;AAEA,SACE,mBAACb,cAAD,EAAC;AACC,mBAAW,IADZ;AAEC8G,cAAU,CAFX;AAGE,OAAGQ,UAHL;AAICtE,SAAKR,YAJN;AAMCuE,WAAO;AAAEQ,gBAAU;AAAZ,KANR;AAOCC,aAAUjE,KAAD,IAAW;AAClB,YAAMkE,qBAAqBlE,MAAMqB,aAAjC;AACA,YAAM8C,6BAA6B,CAAC/E,QAAQxB,QAAR,EAAkBwD,QAAlB,CAA2B8C,kBAA3B,CAApC;AACA,UAAIC,0BAAJ,EAAgCR;AAClC;AAXD,GAAD,CADF;AAeF,CApBuB,CAAzB;AAuBAD,WAAW/E,WAAX,GAAyBmF,gBAAzB;AAMA,IAAMM,aAAa,OAAnB;AACA,IAAMC,oBAAoB,kBAA1B;AACA,IAAMC,mBAAmB,iBAAzB;AACA,IAAMC,qBAAqB,mBAA3B;AACA,IAAMC,kBAAkB,gBAAxB;AAcA,IAAMC,QAAc9I,iBAClB,CAAC0B,KAAD,EAAiC4B,YAAjC,KAAkD;AAChD,QAAM;AAAEyF,cAAF;AAAcC,UAAMC,QAApB;AAA8BC,eAA9B;AAA2CC,gBAA3C;AAAyD,OAAGC;AAA5D,MAA2E1H,KAAjF;AACA,QAAM,CAACsH,OAAO,IAAR,EAAcK,OAAd,IAAyBzI,qBAAqB;AAClD0I,UAAML,QAD4C;AAElDM,iBAAaL,WAFqC;AAGlDM,cAAUL;AAHwC,GAArB,CAA/B;AAKA,SACE,mBAAC3I,QAAD,EAAC;AAASiJ,aAASV,cAAcC,IAAhC;AACChH,iCAAC0H,SAAD,EAAC;AACCV,UADD;AAEE,SAAGI,UAFL;AAGCtF,WAAKR,YAHN;AAICqG,eAAS,MAAMN,QAAQ,KAAR,CAJhB;AAKCO,eAASjJ,eAAee,MAAMkI,OAArB,CALV;AAMCC,gBAAUlJ,eAAee,MAAMmI,QAArB,CANX;AAOCC,oBAAc5J,qBAAqBwB,MAAMoI,YAA3B,EAA0CzF,KAAD,IAAW;AAChEA,cAAM0F,aAAN,CAAoBC,YAApB,CAAiC,YAAjC,EAA+C,OAA/C;AACD,OAFa,CAPf;AAUCC,mBAAa/J,qBAAqBwB,MAAMuI,WAA3B,EAAyC5F,KAAD,IAAW;AAC9D,cAAM;AAAE6F,WAAF;AAAKC;AAAL,YAAW9F,MAAM+F,MAAN,CAAaC,KAA9B;AACAhG,cAAM0F,aAAN,CAAoBC,YAApB,CAAiC,YAAjC,EAA+C,MAA/C;AACA3F,cAAM0F,aAAN,CAAoBlC,KAApB,CAA0ByC,WAA1B,CAAsC,4BAAtC,EAAoE,GAAGJ,CAAC,IAAxE;AACA7F,cAAM0F,aAAN,CAAoBlC,KAApB,CAA0ByC,WAA1B,CAAsC,4BAAtC,EAAoE,GAAGH,CAAC,IAAxE;AACD,OALY,CAVd;AAgBCI,qBAAerK,qBAAqBwB,MAAM6I,aAA3B,EAA2ClG,KAAD,IAAW;AAClEA,cAAM0F,aAAN,CAAoBC,YAApB,CAAiC,YAAjC,EAA+C,QAA/C;AACA3F,cAAM0F,aAAN,CAAoBlC,KAApB,CAA0B2C,cAA1B,CAAyC,4BAAzC;AACAnG,cAAM0F,aAAN,CAAoBlC,KAApB,CAA0B2C,cAA1B,CAAyC,4BAAzC;AACAnG,cAAM0F,aAAN,CAAoBlC,KAApB,CAA0B2C,cAA1B,CAAyC,2BAAzC;AACAnG,cAAM0F,aAAN,CAAoBlC,KAApB,CAA0B2C,cAA1B,CAAyC,2BAAzC;AACD,OANc,CAhBhB;AAuBCC,kBAAYvK,qBAAqBwB,MAAM+I,UAA3B,EAAwCpG,KAAD,IAAW;AAC5D,cAAM;AAAE6F,WAAF;AAAKC;AAAL,YAAW9F,MAAM+F,MAAN,CAAaC,KAA9B;AACAhG,cAAM0F,aAAN,CAAoBC,YAApB,CAAiC,YAAjC,EAA+C,KAA/C;AACA3F,cAAM0F,aAAN,CAAoBlC,KAApB,CAA0B2C,cAA1B,CAAyC,4BAAzC;AACAnG,cAAM0F,aAAN,CAAoBlC,KAApB,CAA0B2C,cAA1B,CAAyC,4BAAzC;AACAnG,cAAM0F,aAAN,CAAoBlC,KAApB,CAA0ByC,WAA1B,CAAsC,2BAAtC,EAAmE,GAAGJ,CAAC,IAAvE;AACA7F,cAAM0F,aAAN,CAAoBlC,KAApB,CAA0ByC,WAA1B,CAAsC,2BAAtC,EAAmE,GAAGH,CAAC,IAAvE;AACAd,gBAAQ,KAAR;AACD,OARW;AAvBb,KAAD;AADD,GAAD,CADF;AAqCF,CA7CkB,CAApB;AAgDAP,MAAM9F,WAAN,GAAoByF,UAApB;AASA,IAAM,CAACiC,wBAAD,EAA2BC,0BAA3B,IAAyDtJ,mBAAmBoH,UAAnB,EAA+B;AAC5FkB,YAAU,CAAC;;AADiF,CAA/B,CAA/D;AAwBA,IAAMD,YAAkB1J,iBACtB,CAAC0B,KAAD,EAAqC4B,YAArC,KAAsD;AACpD,QAAM;AACJ3B,gBADI;AAEJiJ,WAAO,YAFH;AAGJ/I,cAAUgJ,YAHN;AAIJ7B,QAJI;AAKJW,WALI;AAMJmB,mBANI;AAOJlB,WAPI;AAQJC,YARI;AASJC,gBATI;AAUJG,eAVI;AAWJM,iBAXI;AAYJE,cAZI;AAaJ,OAAGrB;AAbC,MAcF1H,KAdJ;AAeA,QAAM+B,UAAUjC,wBAAwBiH,UAAxB,EAAoC9G,YAApC,CAAhB;AACA,QAAM,CAACoJ,IAAD,EAAOC,OAAP,IAAwBhL,eAAkC,IAAlC,CAA9B;AACA,QAAM+D,eAAe5D,gBAAgBmD,YAAhB,EAA+ByH,KAAD,IAAUC,QAAQD,KAAR,CAAxC,CAArB;AACA,QAAME,kBAAwBjL,aAAwC,IAAxC,CAA9B;AACA,QAAMkL,gBAAsBlL,aAAwC,IAAxC,CAA5B;AACA,QAAM6B,WAAWgJ,gBAAgBpH,QAAQ5B,QAAzC;AACA,QAAMsJ,yBAA+BnL,aAAO,CAAP,CAArC;AACA,QAAMoL,6BAAmCpL,aAAO6B,QAAP,CAAzC;AACA,QAAMwJ,gBAAsBrL,aAAO,CAAP,CAA5B;AACA,QAAM;AAAE6C,cAAF;AAAcE;AAAd,MAAgCU,OAAtC;AACA,QAAM6H,cAAc3K,eAAe,MAAM;AAGvC,UAAM4K,iBAAiBR,MAAMtF,QAAN,CAAeZ,SAASgB,aAAxB,CAAvB;AACA,QAAI0F,cAAJ,EAAoB9H,QAAQxB,QAAR,EAAkB2C,KAAlB;AACpB+E;AACD,GANmB,CAApB;AAQA,QAAM6B,aAAmBxL,kBACtB6B,SAAD,IAAsB;AACpB,QAAI,CAACA,SAAD,IAAaA,cAAa4J,QAA9B,EAAwC;AACxC3F,WAAO4F,YAAP,CAAoBL,cAAc1G,OAAlC;AACAwG,2BAAuBxG,OAAvB,GAAiC,mBAAIgH,IAAJ,EAAV,CAAqBC,OAArB,EAAvB;AACAP,kBAAc1G,OAAd,GAAwBmB,OAAO+F,UAAP,CAAkBP,WAAlB,EAA+BzJ,SAA/B,CAAxB;AACF,GANuB,EAOvB,CAACyJ,WAAD,CAPuB,CAAzB;AAUMtL,kBAAU,MAAM;AACpB,UAAMiC,WAAWwB,QAAQxB,QAAzB;;AACA,QAAIA,QAAJ,EAAc;AACZ,YAAMoD,eAAe,MAAM;AACzBmG,mBAAWJ,2BAA2BzG,OAAtC;AACAkF;AACF,OAHA;;AAIA,YAAM5E,cAAc,MAAM;AACxB,cAAM6G,cAAc,mBAAIH,IAAJ,EAAd,CAAyBC,OAAzB,KAAqCT,uBAAuBxG,OAAlE;AACAyG,mCAA2BzG,OAA3B,GAAqCyG,2BAA2BzG,OAA3B,GAAqCmH,WAA1E;AACAhG,eAAO4F,YAAP,CAAoBL,cAAc1G,OAAlC;AACAiF;AACF,OALA;;AAMA3H,eAAS6C,gBAAT,CAA0B3B,cAA1B,EAA0C8B,WAA1C;AACAhD,eAAS6C,gBAAT,CAA0B1B,eAA1B,EAA2CiC,YAA3C;AACA,aAAO,MAAM;AACXpD,iBAAS8C,mBAAT,CAA6B5B,cAA7B,EAA6C8B,WAA7C;AACAhD,iBAAS8C,mBAAT,CAA6B3B,eAA7B,EAA8CiC,YAA9C;AACF,OAHA;AAIF;AACF,GApBM,EAoBH,CAAC5B,QAAQxB,QAAT,EAAmBJ,QAAnB,EAA6B+H,OAA7B,EAAsCC,QAAtC,EAAgD2B,UAAhD,CApBG;AAyBAxL,kBAAU,MAAM;AACpB,QAAIgJ,QAAQ,CAACvF,QAAQnB,gBAAR,CAAyBqC,OAAtC,EAA+C6G,WAAW3J,QAAX;AACjD,GAFM,EAEH,CAACmH,IAAD,EAAOnH,QAAP,EAAiB4B,QAAQnB,gBAAzB,EAA2CkJ,UAA3C,CAFG;AAIAxL,kBAAU,MAAM;AACpB6C;AACA,WAAO,MAAME,eAAb;AACF,GAHM,EAGH,CAACF,UAAD,EAAaE,aAAb,CAHG;AAKN,QAAMgJ,sBAA4B/L,cAAQ,MAAM;AAC9C,WAAO+K,OAAOiB,uBAAuBjB,IAAvB,CAAP,GAAsC,IAA7C;AACF,GAFkC,EAE/B,CAACA,IAAD,CAF+B,CAAlC;AAIA,MAAI,CAACtH,QAAQxB,QAAb,EAAuB,OAAO,IAAP;AAEvB,SACE;AACGD,sCACC,mBAACiK,aAAD,EAAC;AACCtK,kBADD;AAGCgG,YAAK,QAHN;AAIC,mBAAWiD,SAAS,YAAT,GAAwB,WAAxB,GAAsC,QAJlD;AAKC,qBAAW,IALZ;AAOE5I;AAPF,KAAD,CADD,EAYD,mBAAC0I,wBAAD,EAAC;AAAyB/H,aAAOhB,YAAhC;AAA8CgI,eAAS2B,WAAvD;AACEtJ,gBAAS/B,uBACR,mBAACiB,WAAWgL,QAAZ,EAAC;AAAoBvJ,eAAOhB,YAA3B;AACCK,qCAAkB1B,qBAAlB,EAAC;AACC6L,mBAAO,IADR;AAECrB,2BAAiB5K,qBAAqB4K,eAArB,EAAsC,MAAM;AAC3D,gBAAI,CAACrH,QAAQpB,8BAAR,CAAuCsC,OAA5C,EAAqD2G;AACrD7H,oBAAQpB,8BAAR,CAAuCsC,OAAvC,GAAiD,KAAjD;AACD,WAHgB,CAFlB;AAOC3C,uCAACvB,UAAU2L,EAAX,EAAC;AAECzE,kBAAK,QAFN;AAGC,yBAAU,KAHX;AAIC,2BAAW,IAJZ;AAKCC,sBAAU,CALX;AAMC,0BAAYoB,OAAO,MAAP,GAAgB,QAN7B;AAOC,oCAAsBvF,QAAQ3B,cAP/B;AAQE,eAAGsH,UARL;AASCtF,iBAAKC,YATN;AAUC8D,mBAAO;AAAEwE,0BAAY,MAAd;AAAsBC,2BAAa,MAAnC;AAA2C,iBAAG5K,MAAMmG;AAApD,aAVR;AAWC0E,uBAAWrM,qBAAqBwB,MAAM6K,SAA3B,EAAuClI,KAAD,IAAW;AAC1D,kBAAIA,MAAMI,GAAN,KAAc,QAAlB,EAA4B;AAC5BqG,gCAAkBzG,MAAMmI,WAAxB;;AACA,kBAAI,CAACnI,MAAMmI,WAAN,CAAkBC,gBAAvB,EAAyC;AACvChJ,wBAAQpB,8BAAR,CAAuCsC,OAAvC,GAAiD,IAAjD;AACA2G;AACF;AACD,aAPU,CAXZ;AAmBCoB,2BAAexM,qBAAqBwB,MAAMgL,aAA3B,EAA2CrI,KAAD,IAAW;AAClE,kBAAIA,MAAMsI,MAAN,KAAiB,CAArB,EAAwB;AACxB1B,8BAAgBtG,OAAhB,GAA0B;AAAEuF,mBAAG7F,MAAMuI,OAAX;AAAoBzC,mBAAG9F,MAAMwI;AAA7B,eAA1B;AACD,aAHc,CAnBhB;AAuBCC,2BAAe5M,qBAAqBwB,MAAMoL,aAA3B,EAA2CzI,KAAD,IAAW;AAClE,kBAAI,CAAC4G,gBAAgBtG,OAArB,EAA8B;AAC9B,oBAAMuF,IAAI7F,MAAMuI,OAAN,GAAgB3B,gBAAgBtG,OAAhB,CAAwBuF,CAAlD;AACA,oBAAMC,IAAI9F,MAAMwI,OAAN,GAAgB5B,gBAAgBtG,OAAhB,CAAwBwF,CAAlD;AACA,oBAAM4C,sBAAsBC,QAAQ9B,cAAcvG,OAAtB,CAA5B;AACA,oBAAMsI,oBAAoB,CAAC,MAAD,EAAS,OAAT,EAAkBC,QAAlB,CAA2BzJ,QAAQ3B,cAAnC,CAA1B;AACA,oBAAMqL,QAAQ,CAAC,MAAD,EAAS,IAAT,EAAeD,QAAf,CAAwBzJ,QAAQ3B,cAAhC,IACVsL,KAAKC,GADK,GAEVD,KAAKE,GAFT;AAGA,oBAAMC,WAAWN,oBAAoBE,MAAM,CAAN,EAASjD,CAAT,CAApB,GAAkC,CAAnD;AACA,oBAAMsD,WAAW,CAACP,iBAAD,GAAqBE,MAAM,CAAN,EAAShD,CAAT,CAArB,GAAmC,CAApD;AACA,oBAAMsD,kBAAkBpJ,MAAMqJ,WAAN,KAAsB,OAAtB,GAAgC,EAAhC,GAAqC,CAA7D;AACA,oBAAMrD,QAAQ;AAAEH,mBAAGqD,QAAL;AAAepD,mBAAGqD;AAAlB,eAAd;AACA,oBAAMG,cAAc;AAAEC,+BAAevJ,KAAjB;AAAwBgG;AAAxB,eAApB;;AACA,kBAAI0C,mBAAJ,EAAyB;AACvB7B,8BAAcvG,OAAd,GAAwB0F,KAAxB;AACAwD,6CAA6BlF,gBAA7B,EAA+CsB,WAA/C,EAA4D0D,WAA5D,EAAyE;AACvEG,4BAAU;AAD6D,iBAAzE;AAGF,eALA,MAKA,IAAWC,mBAAmB1D,KAAnB,EAA0B5G,QAAQ3B,cAAlC,EAAkD2L,eAAlD,CAAX,EAA+E;AAC7EvC,8BAAcvG,OAAd,GAAwB0F,KAAxB;AACAwD,6CAA6BnF,iBAA7B,EAAgDoB,YAAhD,EAA8D6D,WAA9D,EAA2E;AACzEG,4BAAU;AAD+D,iBAA3E;AAGCzJ,sBAAM8C,MAAN,CAA6B6G,iBAA7B,CAA+C3J,MAAM4J,SAArD;AACH,eANA,MAMA,IAAWb,KAAKc,GAAL,CAAShE,CAAT,IAAcuD,eAAd,IAAiCL,KAAKc,GAAL,CAAS/D,CAAT,IAAcsD,eAA1D,EAA2E;AAGzExC,gCAAgBtG,OAAhB,GAA0B,IAA1B;AACF;AACD,aA9Bc,CAvBhB;AAsDCwJ,yBAAajO,qBAAqBwB,MAAMyM,WAA3B,EAAyC9J,KAAD,IAAW;AAC9D,oBAAMgG,QAAQa,cAAcvG,OAA5B;AACA,oBAAMwC,SAAS9C,MAAM8C,MAArB;;AACA,kBAAIA,OAAOiH,iBAAP,CAAyB/J,MAAM4J,SAA/B,CAAJ,EAA+C;AAC7C9G,uBAAOkH,qBAAP,CAA6BhK,MAAM4J,SAAnC;AACF;;AACA/C,4BAAcvG,OAAd,GAAwB,IAAxB;AACAsG,8BAAgBtG,OAAhB,GAA0B,IAA1B;;AACA,kBAAI0F,KAAJ,EAAW;AACT,sBAAMiE,QAAQjK,MAAM0F,aAApB;AACA,sBAAM4D,cAAc;AAAEC,iCAAevJ,KAAjB;AAAwBgG;AAAxB,iBAApB;;AACA,oBACE0D,mBAAmB1D,KAAnB,EAA0B5G,QAAQ3B,cAAlC,EAAkD2B,QAAQ1B,cAA1D,CADF,EAEE;AACA8L,+CAA6BhF,eAA7B,EAA8C4B,UAA9C,EAA0DkD,WAA1D,EAAuE;AACrEG,8BAAU;AAD2D,mBAAvE;AAGF,iBANA,MAMO;AACLD,+CACEjF,kBADF,EAEE2B,aAFF,EAGEoD,WAHF,EAIE;AACEG,8BAAU;AADZ,mBAJF;AAQF;;AAGAQ,sBAAMxJ,gBAAN,CAAuB,OAAvB,EAAiCT,MAAD,IAAWA,OAAMqD,cAANrD,EAA3C,EAAmE;AACjEkK,wBAAM;AAD2D,iBAAnE;AAGF;AACD,aAjCY;AAtDd,WAAD;AAPD,SAAD;AADD,OAAD,CADQ,EAoGR9K,QAAQxB,QApGA;AADX,KAAD,CAZC;AADH,IADF;AAwHF,CA7MsB,CAAxB;;AAsNA,IAAMgK,gBAA+CvK,KAAD,IAA4C;AAC9F,QAAM;AAAEC,gBAAF;AAAgBK,YAAhB;AAA0B,OAAGwM;AAA7B,MAA+C9M,KAArD;AACA,QAAM+B,UAAUjC,wBAAwBiH,UAAxB,EAAoC9G,YAApC,CAAhB;AACA,QAAM,CAAC8M,kBAAD,EAAqBC,qBAArB,IAAoD1O,eAAS,KAAT,CAA1D;AACA,QAAM,CAAC2O,WAAD,EAAcC,cAAd,IAAsC5O,eAAS,KAAT,CAA5C;AAGA6O,eAAa,MAAMH,sBAAsB,IAAtB,CAAnB;AAGM1O,kBAAU,MAAM;AACpB,UAAM8O,QAAQhJ,OAAO+F,UAAP,CAAkB,MAAM+C,eAAe,IAAf,CAAxB,EAA8C,GAA9C,CAAd;AACA,WAAO,MAAM9I,OAAO4F,YAAP,CAAoBoD,KAApB,CAAb;AACF,GAHM,EAGH,EAHG;AAKN,SAAOH,cAAc,IAAd,GACL,mBAACpO,MAAD,EAAC;AAAO4L,aAAO,IAAd;AACCnK,iCAAClB,cAAD,EAAC,EAAgB,GAAG0N,aAAnB;AACExM,sCACC;AACGA,2BAAQJ,KAAR,EAAc,GAAd,EAAgBI,QAAhB;AADH;AAFH,KAAD;AADD,GAAD,CADF;AAWF,CA1BA;;AAgCA,IAAM+M,aAAa,YAAnB;AAMA,IAAMC,aAAmBhP,iBACvB,CAAC0B,KAAD,EAAsC4B,YAAtC,KAAuD;AACrD,QAAM;AAAE3B,gBAAF;AAAgB,OAAGsN;AAAnB,MAAkCvN,KAAxC;AACA,SAAO,mBAACjB,UAAUyO,GAAX,EAAC,EAAe,GAAGD,UAAlB;AAA8BnL,SAAKR;AAAnC,GAAD,CAAP;AACF,CAJuB,CAAzB;AAOA0L,WAAWhM,WAAX,GAAyB+L,UAAzB;AAMA,IAAMI,mBAAmB,kBAAzB;AAKA,IAAMC,mBAAyBpP,iBAC7B,CAAC0B,KAAD,EAA4C4B,YAA5C,KAA6D;AAC3D,QAAM;AAAE3B,gBAAF;AAAgB,OAAG0N;AAAnB,MAAwC3N,KAA9C;AACA,SAAO,mBAACjB,UAAUyO,GAAX,EAAC,EAAe,GAAGG,gBAAlB;AAAoCvL,SAAKR;AAAzC,GAAD,CAAP;AACF,CAJ6B,CAA/B;AAOA8L,iBAAiBpM,WAAjB,GAA+BmM,gBAA/B;AAMA,IAAMG,cAAc,aAApB;AAaA,IAAMC,cAAoBvP,iBACxB,CAAC0B,KAAD,EAAuC4B,YAAvC,KAAwD;AACtD,QAAM;AAAEkM,WAAF;AAAW,OAAGC;AAAd,MAA8B/N,KAApC;;AAEA,MAAI,CAAC8N,QAAQjN,IAAR,EAAL,EAAqB;AACnBC,YAAQC,KAAR,CACE,0CAA0C6M,WAAW,oCADvD;AAGA,WAAO,IAAP;AACF;;AAEA,SACE,mBAACI,oBAAD,EAAC;AAAqBF,WAArB;AAAuCrD,aAAO,IAA9C;AACCnK,iCAAC2N,UAAD,EAAC,EAAY,GAAGF,WAAf;AAA4B3L,WAAKR;AAAjC,KAAD;AADD,GAAD,CADF;AAKF,CAhBwB,CAA1B;AAmBAiM,YAAYvM,WAAZ,GAA0BsM,WAA1B;AAMA,IAAMM,aAAa,YAAnB;AAMA,IAAMD,aAAmB3P,iBACvB,CAAC0B,KAAD,EAAsC4B,YAAtC,KAAuD;AACrD,QAAM;AAAE3B,gBAAF;AAAgB,OAAGkO;AAAnB,MAAkCnO,KAAxC;AACA,QAAMoO,qBAAqBnF,2BAA2BiF,UAA3B,EAAuCjO,YAAvC,CAA3B;AAEA,SACE,mBAAC+N,oBAAD,EAAC;AAAqBvD,aAAO,IAA5B;AACCnK,iCAACvB,UAAUkM,MAAX,EAAC;AACC/B,YAAK,QADN;AAEE,SAAGiF,UAFL;AAGC/L,WAAKR,YAHN;AAICyM,eAAS7P,qBAAqBwB,MAAMqO,OAA3B,EAAoCD,mBAAmBnG,OAAvD;AAJV,KAAD;AADD,GAAD,CADF;AAUF,CAfuB,CAAzB;AAkBAgG,WAAW3M,WAAX,GAAyB4M,UAAzB;AASA,IAAMF,uBAA6B1P,iBAGjC,CAAC0B,KAAD,EAAgD4B,YAAhD,KAAiE;AACjE,QAAM;AAAE3B,gBAAF;AAAgB6N,WAAhB;AAAyB,OAAGQ;AAA5B,MAAqDtO,KAA3D;AAEA,SACE,mBAACjB,UAAUyO,GAAX,EAAC;AACC,yCAAkC,EADnC;AAEC,qCAA+BM,WAAW,MAF3C;AAGE,OAAGQ,oBAHL;AAIClM,SAAKR;AAJN,GAAD,CADF;AAQD,CAdkC,CAAnC;;AAgBA,SAAS0I,sBAAT,CAAgCiE,SAAhC,EAAwD;AACtD,QAAMC,cAAwB,EAA9B;AACA,QAAMC,aAAaC,MAAMC,IAAN,CAAWJ,UAAUE,UAArB,CAAnB;AAEAA,aAAWG,OAAX,CAAoBvF,IAAD,IAAU;AAC3B,QAAIA,KAAKwF,QAAL,KAAkBxF,KAAKyF,SAAvB,IAAoCzF,KAAKmF,WAA7C,EAA0DA,YAAYO,IAAZ,CAAiB1F,KAAKmF,WAAtB;;AAC1D,QAAIQ,cAAc3F,IAAd,CAAJ,EAAyB;AACvB,YAAM4F,WAAW5F,KAAK6F,UAAL,IAAmB7F,KAAK8F,MAAxB,IAAkC9F,KAAKlD,KAAL,CAAWiJ,OAAX,KAAuB,MAA1E;AACA,YAAMC,aAAahG,KAAKiG,OAAL,CAAaC,yBAAb,KAA2C,EAA9D;;AAEA,UAAI,CAACN,QAAL,EAAe;AACb,YAAII,UAAJ,EAAgB;AACd,gBAAMvB,UAAUzE,KAAKiG,OAAL,CAAaE,qBAA7B;AACA,cAAI1B,OAAJ,EAAaU,YAAYO,IAAZ,CAAiBjB,OAAjB;AACf,SAHA,MAGO;AACLU,sBAAYO,IAAZ,CAAiB,GAAGzE,uBAAuBjB,IAAvB,CAApB;AACF;AACF;AACF;AACD,GAfD;AAmBA,SAAOmF,WAAP;AACF;;AAIA,SAASrC,4BAAT,CAIEsD,IAJF,EAKEC,OALF,EAMEhH,MANF,SAQE;AAAA,MADA;AAAE0D;AAAF,GACA;AACA,QAAM/D,gBAAgBK,OAAOwD,aAAP,CAAqB7D,aAA3C;AACA,QAAM1F,QAAQ,IAAIc,WAAJ,CAAgBgM,IAAhB,EAAsB;AAAEE,aAAS,IAAX;AAAiBC,gBAAY,IAA7B;AAAmClH;AAAnC,GAAtB,CAAd;AACA,MAAIgH,OAAJ,EAAarH,cAAcjF,gBAAd,CAA+BqM,IAA/B,EAAqCC,OAArC,EAA+D;AAAE7C,UAAM;AAAR,GAA/D;;AAEb,MAAIT,QAAJ,EAAc;AACZpN,gCAA4BqJ,aAA5B,EAA2C1F,KAA3C;AACF,GAFA,MAEO;AACL0F,kBAAc3E,aAAd,CAA4Bf,KAA5B;AACF;AACF;;AAEA,IAAM0J,qBAAqB,UACzB1D,KADyB,EAEzBkH,SAFyB,EAItB;AAAA,MADHC,SACG,uEADS,CACT;AACH,QAAMC,SAASrE,KAAKc,GAAL,CAAS7D,MAAMH,CAAf,CAAf;AACA,QAAMwH,SAAStE,KAAKc,GAAL,CAAS7D,MAAMF,CAAf,CAAf;AACA,QAAMwH,WAAWF,SAASC,MAA1B;;AACA,MAAIH,cAAc,MAAd,IAAwBA,cAAc,OAA1C,EAAmD;AACjD,WAAOI,YAAYF,SAASD,SAA5B;AACF,GAFA,MAEO;AACL,WAAO,CAACG,QAAD,IAAaD,SAASF,SAA7B;AACF;AACF,CAbA;;AAeA,SAAS3C,YAAT,GAA2C;AAAA,MAArB+C,QAAqB,uEAAV,MAAM,CAAC,CAAG;AACzC,QAAMC,KAAKlR,eAAeiR,QAAf,CAAX;AACA/Q,kBAAgB,MAAM;AACpB,QAAIiR,OAAO,CAAX;AACA,QAAIC,OAAO,CAAX;AACAD,WAAOhM,OAAOkM,qBAAP,CAA6B,MAAOD,OAAOjM,OAAOkM,qBAAP,CAA6BH,EAA7B,CAA3C,CAAP;AACA,WAAO,MAAM;AACX/L,aAAOmM,oBAAP,CAA4BH,IAA5B;AACAhM,aAAOmM,oBAAP,CAA4BF,IAA5B;AACF,KAHA;AAIF,GARA,EAQG,CAACF,EAAD,CARH;AASF;;AAEA,SAASnB,aAAT,CAAuB3F,IAAvB,EAAuD;AACrD,SAAOA,KAAKwF,QAAL,KAAkBxF,KAAKmH,YAA9B;AACF;;AAYA,SAAS3L,qBAAT,CAA+B0J,SAA/B,EAAuD;AACrD,QAAMkC,QAAuB,EAA7B;AACA,QAAMC,SAASvN,SAASwN,gBAAT,CAA0BpC,SAA1B,EAAqCqC,WAAWC,YAAhD,EAA8D;AAC3EC,gBAAazH,IAAD,IAAe;AACzB,YAAM0H,gBAAgB1H,KAAK2H,OAAL,KAAiB,OAAjB,IAA4B3H,KAAKH,IAAL,KAAc,QAAhE;AACA,UAAIG,KAAK4H,QAAL,IAAiB5H,KAAK8F,MAAtB,IAAgC4B,aAApC,EAAmD,OAAOH,WAAWM,WAAlB;AAInD,aAAO7H,KAAKnD,QAAL,IAAiB,CAAjB,GAAqB0K,WAAWO,aAAhC,GAAgDP,WAAWM,WAAlE;AACF;AAR2E,GAA9D,CAAf;;AAUA,SAAOR,OAAOU,QAAP,EAAP,EAA0BX,MAAM1B,IAAN,CAAW2B,OAAOW,WAAlB;;AAG1B,SAAOZ,KAAP;AACF;;AAEA,SAAS3K,UAAT,CAAoBwL,UAApB,EAA+C;AAC7C,QAAMC,2BAA2BpO,SAASgB,aAA1C;AACA,SAAOmN,WAAWE,IAAX,CAAiB3L,SAAD,IAAe;AAEpC,QAAIA,cAAc0L,wBAAlB,EAA4C,OAAO,IAAP;AAC5C1L,cAAU3C,KAAV;AACA,WAAOC,SAASgB,aAAT,KAA2BoN,wBAAlC;AACD,GALM,CAAP;AAMF;;AAEA,IAAMvQ,WAAWjB,aAAjB;AACA,IAAM0R,WAAW9P,aAAjB;AACA,IAAM+P,QAAOtK,KAAb;AACA,IAAMuK,QAAQrE,UAAd;AACA,IAAMsE,cAAclE,gBAApB;AACA,IAAMmE,SAAShE,WAAf;AACA,IAAMiE,QAAQ7D,UAAd","names":["React","ReactDOM","composeEventHandlers","useComposedRefs","createCollection","createContextScope","DismissableLayer","Portal","Presence","Primitive","dispatchDiscreteCustomEvent","useCallbackRef","useControllableState","useLayoutEffect","VisuallyHidden","Fragment","jsxs","PROVIDER_NAME","Collection","useCollection","createCollectionScope","createToastContext","createToastScope","ToastProviderProvider","useToastProviderContext","ToastProvider","props","__scopeToast","label","duration","swipeDirection","swipeThreshold","children","viewport","setViewport","toastCount","setToastCount","isFocusedToastEscapeKeyDownRef","isClosePausedRef","trim","console","error","Provider","scope","onViewportChange","onToastAdd","prevCount","onToastRemove","displayName","VIEWPORT_NAME","VIEWPORT_DEFAULT_HOTKEY","VIEWPORT_PAUSE","VIEWPORT_RESUME","ToastViewport","forwardedRef","hotkey","viewportProps","context","getItems","wrapperRef","headFocusProxyRef","tailFocusProxyRef","ref","composedRefs","hotkeyLabel","join","replace","hasToasts","handleKeyDown","event","isHotkeyPressed","length","every","key","code","current","focus","document","addEventListener","removeEventListener","wrapper","handlePause","pauseEvent","CustomEvent","dispatchEvent","handleResume","resumeEvent","handleFocusOutResume","isFocusMovingOutside","contains","relatedTarget","handlePointerLeaveResume","isFocusInside","activeElement","window","getSortedTabbableCandidates","tabbingDirection","toastItems","tabbableCandidates","map","toastItem","toastNode","toastTabbableCandidates","getTabbableCandidates","reverse","flat","isMetaKey","altKey","ctrlKey","metaKey","isTabKey","focusedElement","isTabbingBackwards","shiftKey","targetIsViewport","target","sortedCandidates","index","findIndex","candidate","focusFirst","slice","preventDefault","role","tabIndex","style","pointerEvents","FocusProxy","onFocusFromOutsideViewport","Slot","ol","FOCUS_PROXY_NAME","proxyProps","position","onFocus","prevFocusedElement","isFocusFromOutsideViewport","TOAST_NAME","TOAST_SWIPE_START","TOAST_SWIPE_MOVE","TOAST_SWIPE_CANCEL","TOAST_SWIPE_END","Toast","forceMount","open","openProp","defaultOpen","onOpenChange","toastProps","setOpen","prop","defaultProp","onChange","present","ToastImpl","onClose","onPause","onResume","onSwipeStart","currentTarget","setAttribute","onSwipeMove","x","y","detail","delta","setProperty","onSwipeCancel","removeProperty","onSwipeEnd","ToastInteractiveProvider","useToastInteractiveContext","type","durationProp","onEscapeKeyDown","node","setNode","pointerStartRef","swipeDeltaRef","closeTimerStartTimeRef","closeTimerRemainingTimeRef","closeTimerRef","handleClose","isFocusInToast","startTimer","Infinity","clearTimeout","Date","getTime","setTimeout","elapsedTime","announceTextContent","getAnnounceTextContent","ToastAnnounce","ItemSlot","asChild","li","userSelect","touchAction","onKeyDown","nativeEvent","defaultPrevented","onPointerDown","button","clientX","clientY","onPointerMove","hasSwipeMoveStarted","Boolean","isHorizontalSwipe","includes","clamp","Math","min","max","clampedX","clampedY","moveStartBuffer","pointerType","eventDetail","originalEvent","handleAndDispatchCustomEvent","discrete","isDeltaInDirection","setPointerCapture","pointerId","abs","onPointerUp","hasPointerCapture","releasePointerCapture","toast","once","announceProps","renderAnnounceText","setRenderAnnounceText","isAnnounced","setIsAnnounced","useNextFrame","timer","TITLE_NAME","ToastTitle","titleProps","div","DESCRIPTION_NAME","ToastDescription","descriptionProps","ACTION_NAME","ToastAction","altText","actionProps","ToastAnnounceExclude","ToastClose","CLOSE_NAME","closeProps","interactiveContext","onClick","announceExcludeProps","container","textContent","childNodes","Array","from","forEach","nodeType","TEXT_NODE","push","isHTMLElement","isHidden","ariaHidden","hidden","display","isExcluded","dataset","radixToastAnnounceExclude","radixToastAnnounceAlt","name","handler","bubbles","cancelable","direction","threshold","deltaX","deltaY","isDeltaX","callback","fn","raf1","raf2","requestAnimationFrame","cancelAnimationFrame","ELEMENT_NODE","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","disabled","FILTER_SKIP","FILTER_ACCEPT","nextNode","currentNode","candidates","previouslyFocusedElement","some","Viewport","Root","Title","Description","Action","Close"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-toast/src/Toast.tsx"],"sourcesContent":["import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { createContextScope } from '@radix-ui/react-context';\nimport * as DismissableLayer from '@radix-ui/react-dismissable-layer';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * ToastProvider\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROVIDER_NAME = 'ToastProvider';\n\nconst [Collection, useCollection, createCollectionScope] = createCollection<ToastElement>('Toast');\n\ntype SwipeDirection = 'up' | 'down' | 'left' | 'right';\ntype ToastProviderContextValue = {\n  label: string;\n  duration: number;\n  swipeDirection: SwipeDirection;\n  swipeThreshold: number;\n  toastCount: number;\n  viewport: ToastViewportElement | null;\n  onViewportChange(viewport: ToastViewportElement): void;\n  onToastAdd(): void;\n  onToastRemove(): void;\n  isFocusedToastEscapeKeyDownRef: React.MutableRefObject<boolean>;\n  isClosePausedRef: React.MutableRefObject<boolean>;\n};\n\ntype ScopedProps<P> = P & { __scopeToast?: Scope };\nconst [createToastContext, createToastScope] = createContextScope('Toast', [createCollectionScope]);\nconst [ToastProviderProvider, useToastProviderContext] =\n  createToastContext<ToastProviderContextValue>(PROVIDER_NAME);\n\ninterface ToastProviderProps {\n  children?: React.ReactNode;\n  /**\n   * An author-localized label for each toast. Used to help screen reader users\n   * associate the interruption with a toast.\n   * @defaultValue 'Notification'\n   */\n  label?: string;\n  /**\n   * Time in milliseconds that each toast should remain visible for.\n   * @defaultValue 5000\n   */\n  duration?: number;\n  /**\n   * Direction of pointer swipe that should close the toast.\n   * @defaultValue 'right'\n   */\n  swipeDirection?: SwipeDirection;\n  /**\n   * Distance in pixels that the swipe must pass before a close is triggered.\n   * @defaultValue 50\n   */\n  swipeThreshold?: number;\n}\n\nconst ToastProvider: React.FC<ToastProviderProps> = (props: ScopedProps<ToastProviderProps>) => {\n  const {\n    __scopeToast,\n    label = 'Notification',\n    duration = 5000,\n    swipeDirection = 'right',\n    swipeThreshold = 50,\n    children,\n  } = props;\n  const [viewport, setViewport] = React.useState<ToastViewportElement | null>(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n\n  if (!label.trim()) {\n    console.error(\n      `Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`\n    );\n  }\n\n  return (\n    <Collection.Provider scope={__scopeToast}>\n      <ToastProviderProvider\n        scope={__scopeToast}\n        label={label}\n        duration={duration}\n        swipeDirection={swipeDirection}\n        swipeThreshold={swipeThreshold}\n        toastCount={toastCount}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        onToastAdd={React.useCallback(() => setToastCount((prevCount) => prevCount + 1), [])}\n        onToastRemove={React.useCallback(() => setToastCount((prevCount) => prevCount - 1), [])}\n        isFocusedToastEscapeKeyDownRef={isFocusedToastEscapeKeyDownRef}\n        isClosePausedRef={isClosePausedRef}\n      >\n        {children}\n      </ToastProviderProvider>\n    </Collection.Provider>\n  );\n};\n\nToastProvider.displayName = PROVIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'ToastViewport';\nconst VIEWPORT_DEFAULT_HOTKEY = ['F8'];\nconst VIEWPORT_PAUSE = 'toast.viewportPause';\nconst VIEWPORT_RESUME = 'toast.viewportResume';\n\ntype ToastViewportElement = React.ElementRef<typeof Primitive.ol>;\ntype PrimitiveOrderedListProps = React.ComponentPropsWithoutRef<typeof Primitive.ol>;\ninterface ToastViewportProps extends PrimitiveOrderedListProps {\n  /**\n   * The keys to use as the keyboard shortcut that will move focus to the toast viewport.\n   * @defaultValue ['F8']\n   */\n  hotkey?: string[];\n  /**\n   * An author-localized label for the toast viewport to provide context for screen reader users\n   * when navigating page landmarks. The available `{hotkey}` placeholder will be replaced for you.\n   * @defaultValue 'Notifications ({hotkey})'\n   */\n  label?: string;\n}\n\nconst ToastViewport = React.forwardRef<ToastViewportElement, ToastViewportProps>(\n  (props: ScopedProps<ToastViewportProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      hotkey = VIEWPORT_DEFAULT_HOTKEY,\n      label = 'Notifications ({hotkey})',\n      ...viewportProps\n    } = props;\n    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n    const getItems = useCollection(__scopeToast);\n    const wrapperRef = React.useRef<HTMLDivElement>(null);\n    const headFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const tailFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const ref = React.useRef<ToastViewportElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n    const hotkeyLabel = hotkey.join('+').replace(/Key/g, '').replace(/Digit/g, '');\n    const hasToasts = context.toastCount > 0;\n\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        // we use `event.code` as it is consistent regardless of meta keys that were pressed.\n        // for example, `event.key` for `Control+Alt+t` is `` and `t !== `\n        const isHotkeyPressed =\n          hotkey.length !== 0 && hotkey.every((key) => (event as any)[key] || event.code === key);\n        if (isHotkeyPressed) ref.current?.focus();\n      };\n      document.addEventListener('keydown', handleKeyDown);\n      return () => document.removeEventListener('keydown', handleKeyDown);\n    }, [hotkey]);\n\n    React.useEffect(() => {\n      const wrapper = wrapperRef.current;\n      const viewport = ref.current;\n      if (hasToasts && wrapper && viewport) {\n        const handlePause = () => {\n          if (!context.isClosePausedRef.current) {\n            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n            viewport.dispatchEvent(pauseEvent);\n            context.isClosePausedRef.current = true;\n          }\n        };\n\n        const handleResume = () => {\n          if (context.isClosePausedRef.current) {\n            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n            viewport.dispatchEvent(resumeEvent);\n            context.isClosePausedRef.current = false;\n          }\n        };\n\n        const handleFocusOutResume = (event: FocusEvent) => {\n          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget as HTMLElement);\n          if (isFocusMovingOutside) handleResume();\n        };\n\n        const handlePointerLeaveResume = () => {\n          const isFocusInside = wrapper.contains(document.activeElement);\n          if (!isFocusInside) handleResume();\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        wrapper.addEventListener('focusin', handlePause);\n        wrapper.addEventListener('focusout', handleFocusOutResume);\n        wrapper.addEventListener('pointermove', handlePause);\n        wrapper.addEventListener('pointerleave', handlePointerLeaveResume);\n        window.addEventListener('blur', handlePause);\n        window.addEventListener('focus', handleResume);\n        return () => {\n          wrapper.removeEventListener('focusin', handlePause);\n          wrapper.removeEventListener('focusout', handleFocusOutResume);\n          wrapper.removeEventListener('pointermove', handlePause);\n          wrapper.removeEventListener('pointerleave', handlePointerLeaveResume);\n          window.removeEventListener('blur', handlePause);\n          window.removeEventListener('focus', handleResume);\n        };\n      }\n    }, [hasToasts, context.isClosePausedRef]);\n\n    const getSortedTabbableCandidates = React.useCallback(\n      ({ tabbingDirection }: { tabbingDirection: 'forwards' | 'backwards' }) => {\n        const toastItems = getItems();\n        const tabbableCandidates = toastItems.map((toastItem) => {\n          const toastNode = toastItem.ref.current!;\n          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n          return tabbingDirection === 'forwards'\n            ? toastTabbableCandidates\n            : toastTabbableCandidates.reverse();\n        });\n        return (\n          tabbingDirection === 'forwards' ? tabbableCandidates.reverse() : tabbableCandidates\n        ).flat();\n      },\n      [getItems]\n    );\n\n    React.useEffect(() => {\n      const viewport = ref.current;\n      // We programmatically manage tabbing as we are unable to influence\n      // the source order with portals, this allows us to reverse the\n      // tab order so that it runs from most recent toast to least\n      if (viewport) {\n        const handleKeyDown = (event: KeyboardEvent) => {\n          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n          const isTabKey = event.key === 'Tab' && !isMetaKey;\n\n          if (isTabKey) {\n            const focusedElement = document.activeElement;\n            const isTabbingBackwards = event.shiftKey;\n            const targetIsViewport = event.target === viewport;\n\n            // If we're back tabbing after jumping to the viewport then we simply\n            // proxy focus out to the preceding document\n            if (targetIsViewport && isTabbingBackwards) {\n              headFocusProxyRef.current?.focus();\n              return;\n            }\n\n            const tabbingDirection = isTabbingBackwards ? 'backwards' : 'forwards';\n            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });\n            const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);\n            if (focusFirst(sortedCandidates.slice(index + 1))) {\n              event.preventDefault();\n            } else {\n              // If we can't focus that means we're at the edges so we\n              // proxy to the corresponding exit point and let the browser handle\n              // tab/shift+tab keypress and implicitly pass focus to the next valid element in the document\n              isTabbingBackwards\n                ? headFocusProxyRef.current?.focus()\n                : tailFocusProxyRef.current?.focus();\n            }\n          }\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        viewport.addEventListener('keydown', handleKeyDown);\n        return () => viewport.removeEventListener('keydown', handleKeyDown);\n      }\n    }, [getItems, getSortedTabbableCandidates]);\n\n    return (\n      <DismissableLayer.Branch\n        ref={wrapperRef}\n        role=\"region\"\n        aria-label={label.replace('{hotkey}', hotkeyLabel)}\n        // Ensure virtual cursor from landmarks menus triggers focus/blur for pause/resume\n        tabIndex={-1}\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        style={{ pointerEvents: hasToasts ? undefined : 'none' }}\n      >\n        {hasToasts && (\n          <FocusProxy\n            ref={headFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'forwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n        {/**\n         * tabindex on the the list so that it can be focused when items are removed. we focus\n         * the list instead of the viewport so it announces number of items remaining.\n         */}\n        <Collection.Slot scope={__scopeToast}>\n          <Primitive.ol tabIndex={-1} {...viewportProps} ref={composedRefs} />\n        </Collection.Slot>\n        {hasToasts && (\n          <FocusProxy\n            ref={tailFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'backwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n      </DismissableLayer.Branch>\n    );\n  }\n);\n\nToastViewport.displayName = VIEWPORT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_PROXY_NAME = 'ToastFocusProxy';\n\ntype FocusProxyElement = React.ElementRef<typeof VisuallyHidden>;\ntype VisuallyHiddenProps = React.ComponentPropsWithoutRef<typeof VisuallyHidden>;\ninterface FocusProxyProps extends VisuallyHiddenProps {\n  onFocusFromOutsideViewport(): void;\n}\n\nconst FocusProxy = React.forwardRef<FocusProxyElement, ScopedProps<FocusProxyProps>>(\n  (props, forwardedRef) => {\n    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;\n    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n\n    return (\n      <VisuallyHidden\n        aria-hidden\n        tabIndex={0}\n        {...proxyProps}\n        ref={forwardedRef}\n        // Avoid page scrolling when focus is on the focus proxy\n        style={{ position: 'fixed' }}\n        onFocus={(event) => {\n          const prevFocusedElement = event.relatedTarget as HTMLElement | null;\n          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n        }}\n      />\n    );\n  }\n);\n\nFocusProxy.displayName = FOCUS_PROXY_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Toast\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOAST_NAME = 'Toast';\nconst TOAST_SWIPE_START = 'toast.swipeStart';\nconst TOAST_SWIPE_MOVE = 'toast.swipeMove';\nconst TOAST_SWIPE_CANCEL = 'toast.swipeCancel';\nconst TOAST_SWIPE_END = 'toast.swipeEnd';\n\ntype ToastElement = ToastImplElement;\ninterface ToastProps extends Omit<ToastImplProps, keyof ToastImplPrivateProps> {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst Toast = React.forwardRef<ToastElement, ToastProps>(\n  (props: ScopedProps<ToastProps>, forwardedRef) => {\n    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;\n    const [open = true, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen,\n      onChange: onOpenChange,\n    });\n    return (\n      <Presence present={forceMount || open}>\n        <ToastImpl\n          open={open}\n          {...toastProps}\n          ref={forwardedRef}\n          onClose={() => setOpen(false)}\n          onPause={useCallbackRef(props.onPause)}\n          onResume={useCallbackRef(props.onResume)}\n          onSwipeStart={composeEventHandlers(props.onSwipeStart, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'start');\n          })}\n          onSwipeMove={composeEventHandlers(props.onSwipeMove, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'move');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-y', `${y}px`);\n          })}\n          onSwipeCancel={composeEventHandlers(props.onSwipeCancel, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'cancel');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-y');\n          })}\n          onSwipeEnd={composeEventHandlers(props.onSwipeEnd, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'end');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-y', `${y}px`);\n            setOpen(false);\n          })}\n        />\n      </Presence>\n    );\n  }\n);\n\nToast.displayName = TOAST_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype SwipeEvent = { currentTarget: EventTarget & ToastElement } & Omit<\n  CustomEvent<{ originalEvent: React.PointerEvent; delta: { x: number; y: number } }>,\n  'currentTarget'\n>;\n\nconst [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {},\n});\n\ntype ToastImplElement = React.ElementRef<typeof Primitive.li>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer.Root>;\ntype ToastImplPrivateProps = { open: boolean; onClose(): void };\ntype PrimitiveListItemProps = React.ComponentPropsWithoutRef<typeof Primitive.li>;\ninterface ToastImplProps extends ToastImplPrivateProps, PrimitiveListItemProps {\n  type?: 'foreground' | 'background';\n  /**\n   * Time in milliseconds that toast should remain visible for. Overrides value\n   * given to `ToastProvider`.\n   */\n  duration?: number;\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPause?(): void;\n  onResume?(): void;\n  onSwipeStart?(event: SwipeEvent): void;\n  onSwipeMove?(event: SwipeEvent): void;\n  onSwipeCancel?(event: SwipeEvent): void;\n  onSwipeEnd?(event: SwipeEvent): void;\n}\n\nconst ToastImpl = React.forwardRef<ToastImplElement, ToastImplProps>(\n  (props: ScopedProps<ToastImplProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      type = 'foreground',\n      duration: durationProp,\n      open,\n      onClose,\n      onEscapeKeyDown,\n      onPause,\n      onResume,\n      onSwipeStart,\n      onSwipeMove,\n      onSwipeCancel,\n      onSwipeEnd,\n      ...toastProps\n    } = props;\n    const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n    const [node, setNode] = React.useState<ToastImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const pointerStartRef = React.useRef<{ x: number; y: number } | null>(null);\n    const swipeDeltaRef = React.useRef<{ x: number; y: number } | null>(null);\n    const duration = durationProp || context.duration;\n    const closeTimerStartTimeRef = React.useRef(0);\n    const closeTimerRemainingTimeRef = React.useRef(duration);\n    const closeTimerRef = React.useRef(0);\n    const { onToastAdd, onToastRemove } = context;\n    const handleClose = useCallbackRef(() => {\n      // focus viewport if focus is within toast to read the remaining toast\n      // count to SR users and ensure focus isn't lost\n      const isFocusInToast = node?.contains(document.activeElement);\n      if (isFocusInToast) context.viewport?.focus();\n      onClose();\n    });\n\n    const startTimer = React.useCallback(\n      (duration: number) => {\n        if (!duration || duration === Infinity) return;\n        window.clearTimeout(closeTimerRef.current);\n        closeTimerStartTimeRef.current = new Date().getTime();\n        closeTimerRef.current = window.setTimeout(handleClose, duration);\n      },\n      [handleClose]\n    );\n\n    React.useEffect(() => {\n      const viewport = context.viewport;\n      if (viewport) {\n        const handleResume = () => {\n          startTimer(closeTimerRemainingTimeRef.current);\n          onResume?.();\n        };\n        const handlePause = () => {\n          const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;\n          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n          window.clearTimeout(closeTimerRef.current);\n          onPause?.();\n        };\n        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n        return () => {\n          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n        };\n      }\n    }, [context.viewport, duration, onPause, onResume, startTimer]);\n\n    // start timer when toast opens or duration changes.\n    // we include `open` in deps because closed !== unmounted when animating\n    // so it could reopen before being completely unmounted\n    React.useEffect(() => {\n      if (open && !context.isClosePausedRef.current) startTimer(duration);\n    }, [open, duration, context.isClosePausedRef, startTimer]);\n\n    React.useEffect(() => {\n      onToastAdd();\n      return () => onToastRemove();\n    }, [onToastAdd, onToastRemove]);\n\n    const announceTextContent = React.useMemo(() => {\n      return node ? getAnnounceTextContent(node) : null;\n    }, [node]);\n\n    if (!context.viewport) return null;\n\n    return (\n      <>\n        {announceTextContent && (\n          <ToastAnnounce\n            __scopeToast={__scopeToast}\n            // Toasts are always role=status to avoid stuttering issues with role=alert in SRs.\n            role=\"status\"\n            aria-live={type === 'foreground' ? 'assertive' : 'polite'}\n            aria-atomic\n          >\n            {announceTextContent}\n          </ToastAnnounce>\n        )}\n\n        <ToastInteractiveProvider scope={__scopeToast} onClose={handleClose}>\n          {ReactDOM.createPortal(\n            <Collection.ItemSlot scope={__scopeToast}>\n              <DismissableLayer.Root\n                asChild\n                onEscapeKeyDown={composeEventHandlers(onEscapeKeyDown, () => {\n                  if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n                  context.isFocusedToastEscapeKeyDownRef.current = false;\n                })}\n              >\n                <Primitive.li\n                  // Ensure toasts are announced as status list or status when focused\n                  role=\"status\"\n                  aria-live=\"off\"\n                  aria-atomic\n                  tabIndex={0}\n                  data-state={open ? 'open' : 'closed'}\n                  data-swipe-direction={context.swipeDirection}\n                  {...toastProps}\n                  ref={composedRefs}\n                  style={{ userSelect: 'none', touchAction: 'none', ...props.style }}\n                  onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                    if (event.key !== 'Escape') return;\n                    onEscapeKeyDown?.(event.nativeEvent);\n                    if (!event.nativeEvent.defaultPrevented) {\n                      context.isFocusedToastEscapeKeyDownRef.current = true;\n                      handleClose();\n                    }\n                  })}\n                  onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n                    if (event.button !== 0) return;\n                    pointerStartRef.current = { x: event.clientX, y: event.clientY };\n                  })}\n                  onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n                    if (!pointerStartRef.current) return;\n                    const x = event.clientX - pointerStartRef.current.x;\n                    const y = event.clientY - pointerStartRef.current.y;\n                    const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n                    const isHorizontalSwipe = ['left', 'right'].includes(context.swipeDirection);\n                    const clamp = ['left', 'up'].includes(context.swipeDirection)\n                      ? Math.min\n                      : Math.max;\n                    const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n                    const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n                    const moveStartBuffer = event.pointerType === 'touch' ? 10 : 2;\n                    const delta = { x: clampedX, y: clampedY };\n                    const eventDetail = { originalEvent: event, delta };\n                    if (hasSwipeMoveStarted) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                        discrete: false,\n                      });\n                    } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                        discrete: false,\n                      });\n                      (event.target as HTMLElement).setPointerCapture(event.pointerId);\n                    } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                      // User is swiping in wrong direction so we disable swipe gesture\n                      // for the current pointer down interaction\n                      pointerStartRef.current = null;\n                    }\n                  })}\n                  onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n                    const delta = swipeDeltaRef.current;\n                    const target = event.target as HTMLElement;\n                    if (target.hasPointerCapture(event.pointerId)) {\n                      target.releasePointerCapture(event.pointerId);\n                    }\n                    swipeDeltaRef.current = null;\n                    pointerStartRef.current = null;\n                    if (delta) {\n                      const toast = event.currentTarget;\n                      const eventDetail = { originalEvent: event, delta };\n                      if (\n                        isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)\n                      ) {\n                        handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                          discrete: true,\n                        });\n                      } else {\n                        handleAndDispatchCustomEvent(\n                          TOAST_SWIPE_CANCEL,\n                          onSwipeCancel,\n                          eventDetail,\n                          {\n                            discrete: true,\n                          }\n                        );\n                      }\n                      // Prevent click event from triggering on items within the toast when\n                      // pointer up is part of a swipe gesture\n                      toast.addEventListener('click', (event) => event.preventDefault(), {\n                        once: true,\n                      });\n                    }\n                  })}\n                />\n              </DismissableLayer.Root>\n            </Collection.ItemSlot>,\n            context.viewport\n          )}\n        </ToastInteractiveProvider>\n      </>\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\ninterface ToastAnnounceProps\n  extends Omit<React.ComponentPropsWithoutRef<'div'>, 'children'>,\n    ScopedProps<{ children: string[] }> {}\n\nconst ToastAnnounce: React.FC<ToastAnnounceProps> = (props: ScopedProps<ToastAnnounceProps>) => {\n  const { __scopeToast, children, ...announceProps } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n\n  // render text content in the next frame to ensure toast is announced in NVDA\n  useNextFrame(() => setRenderAnnounceText(true));\n\n  // cleanup after announcing\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1000);\n    return () => window.clearTimeout(timer);\n  }, []);\n\n  return isAnnounced ? null : (\n    <Portal asChild>\n      <VisuallyHidden {...announceProps}>\n        {renderAnnounceText && (\n          <>\n            {context.label} {children}\n          </>\n        )}\n      </VisuallyHidden>\n    </Portal>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * ToastTitle\n * -----------------------------------------------------------------------------------------------*/\n\nconst TITLE_NAME = 'ToastTitle';\n\ntype ToastTitleElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ToastTitleProps extends PrimitiveDivProps {}\n\nconst ToastTitle = React.forwardRef<ToastTitleElement, ToastTitleProps>(\n  (props: ScopedProps<ToastTitleProps>, forwardedRef) => {\n    const { __scopeToast, ...titleProps } = props;\n    return <Primitive.div {...titleProps} ref={forwardedRef} />;\n  }\n);\n\nToastTitle.displayName = TITLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastDescription\n * -----------------------------------------------------------------------------------------------*/\n\nconst DESCRIPTION_NAME = 'ToastDescription';\n\ntype ToastDescriptionElement = React.ElementRef<typeof Primitive.div>;\ninterface ToastDescriptionProps extends PrimitiveDivProps {}\n\nconst ToastDescription = React.forwardRef<ToastDescriptionElement, ToastDescriptionProps>(\n  (props: ScopedProps<ToastDescriptionProps>, forwardedRef) => {\n    const { __scopeToast, ...descriptionProps } = props;\n    return <Primitive.div {...descriptionProps} ref={forwardedRef} />;\n  }\n);\n\nToastDescription.displayName = DESCRIPTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastAction\n * -----------------------------------------------------------------------------------------------*/\n\nconst ACTION_NAME = 'ToastAction';\n\ntype ToastActionElement = ToastCloseElement;\ninterface ToastActionProps extends ToastCloseProps {\n  /**\n   * A short description for an alternate way to carry out the action. For screen reader users\n   * who will not be able to navigate to the button easily/quickly.\n   * @example <ToastAction altText=\"Goto account settings to upgrade\">Upgrade</ToastAction>\n   * @example <ToastAction altText=\"Undo (Alt+U)\">Undo</ToastAction>\n   */\n  altText: string;\n}\n\nconst ToastAction = React.forwardRef<ToastActionElement, ToastActionProps>(\n  (props: ScopedProps<ToastActionProps>, forwardedRef) => {\n    const { altText, ...actionProps } = props;\n\n    if (!altText.trim()) {\n      console.error(\n        `Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`\n      );\n      return null;\n    }\n\n    return (\n      <ToastAnnounceExclude altText={altText} asChild>\n        <ToastClose {...actionProps} ref={forwardedRef} />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastAction.displayName = ACTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastClose\n * -----------------------------------------------------------------------------------------------*/\n\nconst CLOSE_NAME = 'ToastClose';\n\ntype ToastCloseElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface ToastCloseProps extends PrimitiveButtonProps {}\n\nconst ToastClose = React.forwardRef<ToastCloseElement, ToastCloseProps>(\n  (props: ScopedProps<ToastCloseProps>, forwardedRef) => {\n    const { __scopeToast, ...closeProps } = props;\n    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n\n    return (\n      <ToastAnnounceExclude asChild>\n        <Primitive.button\n          type=\"button\"\n          {...closeProps}\n          ref={forwardedRef}\n          onClick={composeEventHandlers(props.onClick, interactiveContext.onClose)}\n        />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastClose.displayName = CLOSE_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype ToastAnnounceExcludeElement = React.ElementRef<typeof Primitive.div>;\ninterface ToastAnnounceExcludeProps extends PrimitiveDivProps {\n  altText?: string;\n}\n\nconst ToastAnnounceExclude = React.forwardRef<\n  ToastAnnounceExcludeElement,\n  ToastAnnounceExcludeProps\n>((props: ScopedProps<ToastAnnounceExcludeProps>, forwardedRef) => {\n  const { __scopeToast, altText, ...announceExcludeProps } = props;\n\n  return (\n    <Primitive.div\n      data-radix-toast-announce-exclude=\"\"\n      data-radix-toast-announce-alt={altText || undefined}\n      {...announceExcludeProps}\n      ref={forwardedRef}\n    />\n  );\n});\n\nfunction getAnnounceTextContent(container: HTMLElement) {\n  const textContent: string[] = [];\n  const childNodes = Array.from(container.childNodes);\n\n  childNodes.forEach((node) => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === 'none';\n      const isExcluded = node.dataset.radixToastAnnounceExclude === '';\n\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n\n  // We return a collection of text rather than a single concatenated string.\n  // This allows SR VO to naturally pause break between nodes while announcing.\n  return textContent;\n}\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction handleAndDispatchCustomEvent<\n  E extends CustomEvent,\n  ReactEvent extends React.SyntheticEvent,\n>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: ReactEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const currentTarget = detail.originalEvent.currentTarget as HTMLElement;\n  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });\n  if (handler) currentTarget.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\n\nconst isDeltaInDirection = (\n  delta: { x: number; y: number },\n  direction: SwipeDirection,\n  threshold = 0\n) => {\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === 'left' || direction === 'right') {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\n\nfunction useNextFrame(callback = () => {}) {\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => (raf2 = window.requestAnimationFrame(fn)));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\n\nfunction isHTMLElement(node: any): node is HTMLElement {\n  return node.nodeType === node.ELEMENT_NODE;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some((candidate) => {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nconst Provider = ToastProvider;\nconst Viewport = ToastViewport;\nconst Root = Toast;\nconst Title = ToastTitle;\nconst Description = ToastDescription;\nconst Action = ToastAction;\nconst Close = ToastClose;\n\nexport {\n  createToastScope,\n  //\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastAction,\n  ToastClose,\n  //\n  Provider,\n  Viewport,\n  Root,\n  Title,\n  Description,\n  Action,\n  Close,\n};\nexport type {\n  ToastProviderProps,\n  ToastViewportProps,\n  ToastProps,\n  ToastTitleProps,\n  ToastDescriptionProps,\n  ToastActionProps,\n  ToastCloseProps,\n};\n"]},"metadata":{},"sourceType":"module"}