{"ast":null,"code":"import _defineProperty from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { animateCSSModeScroll } from '../../shared/utils.js';\nexport default function slideTo() {\n  var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var speed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.params.speed;\n  var runCallbacks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  var internal = arguments.length > 3 ? arguments[3] : undefined;\n  var initial = arguments.length > 4 ? arguments[4] : undefined;\n\n  if (typeof index === 'string') {\n    index = parseInt(index, 10);\n  }\n\n  var swiper = this;\n  var slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n  var params = swiper.params,\n      snapGrid = swiper.snapGrid,\n      slidesGrid = swiper.slidesGrid,\n      previousIndex = swiper.previousIndex,\n      activeIndex = swiper.activeIndex,\n      rtl = swiper.rtlTranslate,\n      wrapperEl = swiper.wrapperEl,\n      enabled = swiper.enabled;\n\n  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n    return false;\n  }\n\n  var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  var translate = -snapGrid[snapIndex]; // Normalize slideIndex\n\n  if (params.normalizeSlideIndex) {\n    for (var i = 0; i < slidesGrid.length; i += 1) {\n      var normalizedTranslate = -Math.floor(translate * 100);\n      var normalizedGrid = Math.floor(slidesGrid[i] * 100);\n      var normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n          slideIndex = i;\n        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGrid) {\n        slideIndex = i;\n      }\n    }\n  } // Directions locks\n\n\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {\n      return false;\n    }\n\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) {\n        return false;\n      }\n    }\n  }\n\n  if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  } // Update progress\n\n\n  swiper.updateProgress(translate);\n  var direction;\n  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index\n\n  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n    swiper.updateActiveIndex(slideIndex); // Update Height\n\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n\n    swiper.updateSlidesClasses();\n\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n\n    return false;\n  }\n\n  if (params.cssMode) {\n    var isH = swiper.isHorizontal();\n    var t = rtl ? translate : -translate;\n\n    if (speed === 0) {\n      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n\n      if (isVirtual) {\n        swiper.wrapperEl.style.scrollSnapType = 'none';\n        swiper._immediateVirtual = true;\n      }\n\n      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n        swiper._cssModeVirtualInitialSet = true;\n        requestAnimationFrame(function () {\n          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n        });\n      } else {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n      }\n\n      if (isVirtual) {\n        requestAnimationFrame(function () {\n          swiper.wrapperEl.style.scrollSnapType = '';\n          swiper._immediateVirtual = false;\n        });\n      }\n    } else {\n      var _wrapperEl$scrollTo;\n\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper: swiper,\n          targetPosition: t,\n          side: isH ? 'left' : 'top'\n        });\n        return true;\n      }\n\n      wrapperEl.scrollTo((_wrapperEl$scrollTo = {}, _defineProperty(_wrapperEl$scrollTo, isH ? 'left' : 'top', t), _defineProperty(_wrapperEl$scrollTo, \"behavior\", 'smooth'), _wrapperEl$scrollTo));\n    }\n\n    return true;\n  }\n\n  swiper.setTransition(speed);\n  swiper.setTranslate(translate);\n  swiper.updateActiveIndex(slideIndex);\n  swiper.updateSlidesClasses();\n  swiper.emit('beforeTransitionStart', speed, internal);\n  swiper.transitionStart(runCallbacks, direction);\n\n  if (speed === 0) {\n    swiper.transitionEnd(runCallbacks, direction);\n  } else if (!swiper.animating) {\n    swiper.animating = true;\n\n    if (!swiper.onSlideToWrapperTransitionEnd) {\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n        if (!swiper || swiper.destroyed) return;\n        if (e.target !== this) return;\n        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n        swiper.onSlideToWrapperTransitionEnd = null;\n        delete swiper.onSlideToWrapperTransitionEnd;\n        swiper.transitionEnd(runCallbacks, direction);\n      };\n    }\n\n    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/swiper/core/slide/slideTo.js"],"names":["animateCSSModeScroll","slideTo","index","speed","params","runCallbacks","internal","initial","parseInt","swiper","slideIndex","snapGrid","slidesGrid","previousIndex","activeIndex","rtl","rtlTranslate","wrapperEl","enabled","animating","preventInteractionOnTransition","skip","Math","min","slidesPerGroupSkip","snapIndex","floor","slidesPerGroup","length","translate","normalizeSlideIndex","i","normalizedTranslate","normalizedGrid","normalizedGridNext","initialized","allowSlideNext","minTranslate","allowSlidePrev","maxTranslate","emit","updateProgress","direction","updateActiveIndex","autoHeight","updateAutoHeight","updateSlidesClasses","effect","setTranslate","transitionStart","transitionEnd","cssMode","isH","isHorizontal","t","isVirtual","virtual","style","scrollSnapType","_immediateVirtual","_cssModeVirtualInitialSet","initialSlide","requestAnimationFrame","support","smoothScroll","targetPosition","side","scrollTo","setTransition","onSlideToWrapperTransitionEnd","e","destroyed","target","removeEventListener","addEventListener"],"mappings":"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","sourcesContent":["import { animateCSSModeScroll } from '../../shared/utils.js';\nexport default function slideTo(index = 0, speed = this.params.speed, runCallbacks = true, internal, initial) {\n  if (typeof index === 'string') {\n    index = parseInt(index, 10);\n  }\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    previousIndex,\n    activeIndex,\n    rtlTranslate: rtl,\n    wrapperEl,\n    enabled\n  } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {\n    return false;\n  }\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n  const translate = -snapGrid[snapIndex];\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      const normalizedTranslate = -Math.floor(translate * 100);\n      const normalizedGrid = Math.floor(slidesGrid[i] * 100);\n      const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);\n      if (typeof slidesGrid[i + 1] !== 'undefined') {\n        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {\n          slideIndex = i;\n        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {\n          slideIndex = i + 1;\n        }\n      } else if (normalizedTranslate >= normalizedGrid) {\n        slideIndex = i;\n      }\n    }\n  }\n  // Directions locks\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && (rtl ? translate > swiper.translate && translate > swiper.minTranslate() : translate < swiper.translate && translate < swiper.minTranslate())) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) {\n        return false;\n      }\n    }\n  }\n  if (slideIndex !== (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  // Update progress\n  swiper.updateProgress(translate);\n  let direction;\n  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset';\n\n  // Update Index\n  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n    swiper.updateActiveIndex(slideIndex);\n    // Update Height\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n    return false;\n  }\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    const t = rtl ? translate : -translate;\n    if (speed === 0) {\n      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;\n      if (isVirtual) {\n        swiper.wrapperEl.style.scrollSnapType = 'none';\n        swiper._immediateVirtual = true;\n      }\n      if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {\n        swiper._cssModeVirtualInitialSet = true;\n        requestAnimationFrame(() => {\n          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n        });\n      } else {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;\n      }\n      if (isVirtual) {\n        requestAnimationFrame(() => {\n          swiper.wrapperEl.style.scrollSnapType = '';\n          swiper._immediateVirtual = false;\n        });\n      }\n    } else {\n      if (!swiper.support.smoothScroll) {\n        animateCSSModeScroll({\n          swiper,\n          targetPosition: t,\n          side: isH ? 'left' : 'top'\n        });\n        return true;\n      }\n      wrapperEl.scrollTo({\n        [isH ? 'left' : 'top']: t,\n        behavior: 'smooth'\n      });\n    }\n    return true;\n  }\n  swiper.setTransition(speed);\n  swiper.setTranslate(translate);\n  swiper.updateActiveIndex(slideIndex);\n  swiper.updateSlidesClasses();\n  swiper.emit('beforeTransitionStart', speed, internal);\n  swiper.transitionStart(runCallbacks, direction);\n  if (speed === 0) {\n    swiper.transitionEnd(runCallbacks, direction);\n  } else if (!swiper.animating) {\n    swiper.animating = true;\n    if (!swiper.onSlideToWrapperTransitionEnd) {\n      swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n        if (!swiper || swiper.destroyed) return;\n        if (e.target !== this) return;\n        swiper.wrapperEl.removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n        swiper.onSlideToWrapperTransitionEnd = null;\n        delete swiper.onSlideToWrapperTransitionEnd;\n        swiper.transitionEnd(runCallbacks, direction);\n      };\n    }\n    swiper.wrapperEl.addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n  }\n  return true;\n}"]},"metadata":{},"sourceType":"module"}