{"ast":null,"code":"\"use client\"; // packages/react/switch/src/Switch.tsx\n\nimport * as React from \"react\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { usePrevious } from \"@radix-ui/react-use-previous\";\nimport { useSize } from \"@radix-ui/react-use-size\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { jsx, jsxs } from \"react/jsx-runtime\";\nvar SWITCH_NAME = \"Switch\";\nvar [createSwitchContext, createSwitchScope] = createContextScope(SWITCH_NAME);\nvar [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);\nvar Switch = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSwitch,\n    name,\n    checked: checkedProp,\n    defaultChecked,\n    required,\n    disabled,\n    value = \"on\",\n    onCheckedChange,\n    form,\n    ...switchProps\n  } = props;\n  const [button, setButton] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setButton(node));\n  const hasConsumerStoppedPropagationRef = React.useRef(false);\n  const isFormControl = button ? form || !!button.closest(\"form\") : true;\n  const [checked = false, setChecked] = useControllableState({\n    prop: checkedProp,\n    defaultProp: defaultChecked,\n    onChange: onCheckedChange\n  });\n  return /* @__PURE__ */jsxs(SwitchProvider, {\n    scope: __scopeSwitch,\n    checked,\n    disabled,\n    children: [/* @__PURE__ */jsx(Primitive.button, {\n      type: \"button\",\n      role: \"switch\",\n      \"aria-checked\": checked,\n      \"aria-required\": required,\n      \"data-state\": getState(checked),\n      \"data-disabled\": disabled ? \"\" : void 0,\n      disabled,\n      value,\n      ...switchProps,\n      ref: composedRefs,\n      onClick: composeEventHandlers(props.onClick, event => {\n        setChecked(prevChecked => !prevChecked);\n\n        if (isFormControl) {\n          hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n          if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();\n        }\n      })\n    }), isFormControl && /* @__PURE__ */jsx(BubbleInput, {\n      control: button,\n      bubbles: !hasConsumerStoppedPropagationRef.current,\n      name,\n      value,\n      checked,\n      required,\n      disabled,\n      form,\n      style: {\n        transform: \"translateX(-100%)\"\n      }\n    })]\n  });\n});\nSwitch.displayName = SWITCH_NAME;\nvar THUMB_NAME = \"SwitchThumb\";\nvar SwitchThumb = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeSwitch,\n    ...thumbProps\n  } = props;\n  const context = useSwitchContext(THUMB_NAME, __scopeSwitch);\n  return /* @__PURE__ */jsx(Primitive.span, {\n    \"data-state\": getState(context.checked),\n    \"data-disabled\": context.disabled ? \"\" : void 0,\n    ...thumbProps,\n    ref: forwardedRef\n  });\n});\nSwitchThumb.displayName = THUMB_NAME;\n\nvar BubbleInput = props => {\n  const {\n    control,\n    checked,\n    bubbles = true,\n    ...inputProps\n  } = props;\n  const ref = React.useRef(null);\n  const prevChecked = usePrevious(checked);\n  const controlSize = useSize(control);\n  React.useEffect(() => {\n    const input = ref.current;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, \"checked\");\n    const setChecked = descriptor.set;\n\n    if (prevChecked !== checked && setChecked) {\n      const event = new Event(\"click\", {\n        bubbles\n      });\n      setChecked.call(input, checked);\n      input.dispatchEvent(event);\n    }\n  }, [prevChecked, checked, bubbles]);\n  return /* @__PURE__ */jsx(\"input\", {\n    type: \"checkbox\",\n    \"aria-hidden\": true,\n    defaultChecked: checked,\n    ...inputProps,\n    tabIndex: -1,\n    ref,\n    style: { ...props.style,\n      ...controlSize,\n      position: \"absolute\",\n      pointerEvents: \"none\",\n      opacity: 0,\n      margin: 0\n    }\n  });\n};\n\nfunction getState(checked) {\n  return checked ? \"checked\" : \"unchecked\";\n}\n\nvar Root = Switch;\nvar Thumb = SwitchThumb;\nexport { Root, Switch, SwitchThumb, Thumb, createSwitchScope };","map":{"version":3,"mappings":"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","names":["React","composeEventHandlers","useComposedRefs","createContextScope","useControllableState","usePrevious","useSize","Primitive","jsx","SWITCH_NAME","createSwitchContext","createSwitchScope","SwitchProvider","useSwitchContext","Switch","props","forwardedRef","__scopeSwitch","name","checked","checkedProp","defaultChecked","required","disabled","value","onCheckedChange","form","switchProps","button","setButton","composedRefs","node","hasConsumerStoppedPropagationRef","isFormControl","closest","setChecked","prop","defaultProp","onChange","scope","children","type","role","getState","ref","onClick","event","prevChecked","current","isPropagationStopped","stopPropagation","BubbleInput","control","bubbles","style","transform","displayName","THUMB_NAME","SwitchThumb","thumbProps","context","span","inputProps","controlSize","input","inputProto","window","HTMLInputElement","prototype","descriptor","Object","getOwnPropertyDescriptor","set","Event","call","dispatchEvent","tabIndex","position","pointerEvents","opacity","margin","Root","Thumb"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-switch/src/Switch.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Switch\n * -----------------------------------------------------------------------------------------------*/\n\nconst SWITCH_NAME = 'Switch';\n\ntype ScopedProps<P> = P & { __scopeSwitch?: Scope };\nconst [createSwitchContext, createSwitchScope] = createContextScope(SWITCH_NAME);\n\ntype SwitchContextValue = { checked: boolean; disabled?: boolean };\nconst [SwitchProvider, useSwitchContext] = createSwitchContext<SwitchContextValue>(SWITCH_NAME);\n\ntype SwitchElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface SwitchProps extends PrimitiveButtonProps {\n  checked?: boolean;\n  defaultChecked?: boolean;\n  required?: boolean;\n  onCheckedChange?(checked: boolean): void;\n}\n\nconst Switch = React.forwardRef<SwitchElement, SwitchProps>(\n  (props: ScopedProps<SwitchProps>, forwardedRef) => {\n    const {\n      __scopeSwitch,\n      name,\n      checked: checkedProp,\n      defaultChecked,\n      required,\n      disabled,\n      value = 'on',\n      onCheckedChange,\n      form,\n      ...switchProps\n    } = props;\n    const [button, setButton] = React.useState<HTMLButtonElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));\n    const hasConsumerStoppedPropagationRef = React.useRef(false);\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = button ? form || !!button.closest('form') : true;\n    const [checked = false, setChecked] = useControllableState({\n      prop: checkedProp,\n      defaultProp: defaultChecked,\n      onChange: onCheckedChange,\n    });\n\n    return (\n      <SwitchProvider scope={__scopeSwitch} checked={checked} disabled={disabled}>\n        <Primitive.button\n          type=\"button\"\n          role=\"switch\"\n          aria-checked={checked}\n          aria-required={required}\n          data-state={getState(checked)}\n          data-disabled={disabled ? '' : undefined}\n          disabled={disabled}\n          value={value}\n          {...switchProps}\n          ref={composedRefs}\n          onClick={composeEventHandlers(props.onClick, (event) => {\n            setChecked((prevChecked) => !prevChecked);\n            if (isFormControl) {\n              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n              // if switch is in a form, stop propagation from the button so that we only propagate\n              // one click event (from the input). We propagate changes from an input so that native\n              // form validation works and form events reflect switch updates.\n              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();\n            }\n          })}\n        />\n        {isFormControl && (\n          <BubbleInput\n            control={button}\n            bubbles={!hasConsumerStoppedPropagationRef.current}\n            name={name}\n            value={value}\n            checked={checked}\n            required={required}\n            disabled={disabled}\n            form={form}\n            // We transform because the input is absolutely positioned but we have\n            // rendered it **after** the button. This pulls it back to sit on top\n            // of the button.\n            style={{ transform: 'translateX(-100%)' }}\n          />\n        )}\n      </SwitchProvider>\n    );\n  }\n);\n\nSwitch.displayName = SWITCH_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SwitchThumb\n * -----------------------------------------------------------------------------------------------*/\n\nconst THUMB_NAME = 'SwitchThumb';\n\ntype SwitchThumbElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface SwitchThumbProps extends PrimitiveSpanProps {}\n\nconst SwitchThumb = React.forwardRef<SwitchThumbElement, SwitchThumbProps>(\n  (props: ScopedProps<SwitchThumbProps>, forwardedRef) => {\n    const { __scopeSwitch, ...thumbProps } = props;\n    const context = useSwitchContext(THUMB_NAME, __scopeSwitch);\n    return (\n      <Primitive.span\n        data-state={getState(context.checked)}\n        data-disabled={context.disabled ? '' : undefined}\n        {...thumbProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nSwitchThumb.displayName = THUMB_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype InputProps = React.ComponentPropsWithoutRef<'input'>;\ninterface BubbleInputProps extends Omit<InputProps, 'checked'> {\n  checked: boolean;\n  control: HTMLElement | null;\n  bubbles: boolean;\n}\n\nconst BubbleInput = (props: BubbleInputProps) => {\n  const { control, checked, bubbles = true, ...inputProps } = props;\n  const ref = React.useRef<HTMLInputElement>(null);\n  const prevChecked = usePrevious(checked);\n  const controlSize = useSize(control);\n\n  // Bubble checked change to parents (e.g form change event)\n  React.useEffect(() => {\n    const input = ref.current!;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'checked') as PropertyDescriptor;\n    const setChecked = descriptor.set;\n    if (prevChecked !== checked && setChecked) {\n      const event = new Event('click', { bubbles });\n      setChecked.call(input, checked);\n      input.dispatchEvent(event);\n    }\n  }, [prevChecked, checked, bubbles]);\n\n  return (\n    <input\n      type=\"checkbox\"\n      aria-hidden\n      defaultChecked={checked}\n      {...inputProps}\n      tabIndex={-1}\n      ref={ref}\n      style={{\n        ...props.style,\n        ...controlSize,\n        position: 'absolute',\n        pointerEvents: 'none',\n        opacity: 0,\n        margin: 0,\n      }}\n    />\n  );\n};\n\nfunction getState(checked: boolean) {\n  return checked ? 'checked' : 'unchecked';\n}\n\nconst Root = Switch;\nconst Thumb = SwitchThumb;\n\nexport {\n  createSwitchScope,\n  //\n  Switch,\n  SwitchThumb,\n  //\n  Root,\n  Thumb,\n};\nexport type { SwitchProps, SwitchThumbProps };\n"]},"metadata":{},"sourceType":"module"}