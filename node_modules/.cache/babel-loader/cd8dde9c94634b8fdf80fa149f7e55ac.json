{"ast":null,"code":"import _objectSpread from \"/home/bahari/vl-web-fe/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { calcGeneratorDuration, maxGeneratorDuration, generateLinearEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { springDefaults } from './defaults.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\nvar durationKeys = [\"duration\", \"bounce\"];\nvar physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\n\nfunction isSpringType(options, keys) {\n  return keys.some(function (key) {\n    return options[key] !== undefined;\n  });\n}\n\nfunction getSpringOptions(options) {\n  var springOptions = _objectSpread({\n    velocity: springDefaults.velocity,\n    stiffness: springDefaults.stiffness,\n    damping: springDefaults.damping,\n    mass: springDefaults.mass,\n    isResolvedFromDuration: false\n  }, options); // stiffness/damping/mass overrides duration/bounce\n\n\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    if (options.visualDuration) {\n      var visualDuration = options.visualDuration;\n      var root = 2 * Math.PI / (visualDuration * 1.2);\n      var stiffness = root * root;\n      var damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);\n      springOptions = _objectSpread(_objectSpread({}, springOptions), {}, {\n        mass: springDefaults.mass,\n        stiffness: stiffness,\n        damping: damping\n      });\n    } else {\n      var derived = findSpring(options);\n      springOptions = _objectSpread(_objectSpread(_objectSpread({}, springOptions), derived), {}, {\n        mass: springDefaults.mass\n      });\n      springOptions.isResolvedFromDuration = true;\n    }\n  }\n\n  return springOptions;\n}\n\nfunction spring() {\n  var optionsOrVisualDuration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : springDefaults.visualDuration;\n  var bounce = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : springDefaults.bounce;\n  var options = typeof optionsOrVisualDuration !== \"object\" ? {\n    visualDuration: optionsOrVisualDuration,\n    keyframes: [0, 1],\n    bounce: bounce\n  } : optionsOrVisualDuration;\n  var restSpeed = options.restSpeed,\n      restDelta = options.restDelta;\n  var origin = options.keyframes[0];\n  var target = options.keyframes[options.keyframes.length - 1];\n  /**\n   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n   * to reduce GC during animation.\n   */\n\n  var state = {\n    done: false,\n    value: origin\n  };\n\n  var _getSpringOptions = getSpringOptions(_objectSpread(_objectSpread({}, options), {}, {\n    velocity: -millisecondsToSeconds(options.velocity || 0)\n  })),\n      stiffness = _getSpringOptions.stiffness,\n      damping = _getSpringOptions.damping,\n      mass = _getSpringOptions.mass,\n      duration = _getSpringOptions.duration,\n      velocity = _getSpringOptions.velocity,\n      isResolvedFromDuration = _getSpringOptions.isResolvedFromDuration;\n\n  var initialVelocity = velocity || 0.0;\n  var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n  var initialDelta = target - origin;\n  var undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n  /**\n   * If we're working on a granular scale, use smaller defaults for determining\n   * when the spring is finished.\n   *\n   * These defaults have been selected emprically based on what strikes a good\n   * ratio between feeling good and finishing as soon as changes are imperceptible.\n   */\n\n  var isGranularScale = Math.abs(initialDelta) < 5;\n  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);\n  restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);\n  var resolveSpring;\n\n  if (dampingRatio < 1) {\n    var angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio); // Underdamped spring\n\n    resolveSpring = function resolveSpring(t) {\n      var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n    };\n  } else if (dampingRatio === 1) {\n    // Critically damped spring\n    resolveSpring = function resolveSpring(t) {\n      return target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    };\n  } else {\n    // Overdamped spring\n    var dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n\n    resolveSpring = function resolveSpring(t) {\n      var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t); // When performing sinh or cosh values can hit Infinity so we cap them here\n\n      var freqForT = Math.min(dampedAngularFreq * t, 300);\n      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n    };\n  }\n\n  var generator = {\n    calculatedDuration: isResolvedFromDuration ? duration || null : null,\n    next: function next(t) {\n      var current = resolveSpring(t);\n\n      if (!isResolvedFromDuration) {\n        var currentVelocity = 0.0;\n        /**\n         * We only need to calculate velocity for under-damped springs\n         * as over- and critically-damped springs can't overshoot, so\n         * checking only for displacement is enough.\n         */\n\n        if (dampingRatio < 1) {\n          currentVelocity = t === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);\n        }\n\n        var isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        var isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n\n      state.value = state.done ? target : current;\n      return state;\n    },\n    toString: function toString() {\n      var calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n      var easing = generateLinearEasing(function (progress) {\n        return generator.next(calculatedDuration * progress).value;\n      }, calculatedDuration, 30);\n      return calculatedDuration + \"ms \" + easing;\n    }\n  };\n  return generator;\n}\n\nexport { spring };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs"],"names":["calcGeneratorDuration","maxGeneratorDuration","generateLinearEasing","millisecondsToSeconds","secondsToMilliseconds","clamp","calcGeneratorVelocity","springDefaults","findSpring","calcAngularFreq","durationKeys","physicsKeys","isSpringType","options","keys","some","key","undefined","getSpringOptions","springOptions","velocity","stiffness","damping","mass","isResolvedFromDuration","visualDuration","root","Math","PI","bounce","sqrt","derived","spring","optionsOrVisualDuration","keyframes","restSpeed","restDelta","origin","target","length","state","done","value","duration","initialVelocity","dampingRatio","initialDelta","undampedAngularFreq","isGranularScale","abs","granular","default","resolveSpring","angularFreq","t","envelope","exp","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","generator","calculatedDuration","next","current","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","toString","easing","progress"],"mappings":"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","sourcesContent":["import { calcGeneratorDuration, maxGeneratorDuration, generateLinearEasing } from 'motion-dom';\nimport { millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { springDefaults } from './defaults.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: springDefaults.velocity,\n        stiffness: springDefaults.stiffness,\n        damping: springDefaults.damping,\n        mass: springDefaults.mass,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        if (options.visualDuration) {\n            const visualDuration = options.visualDuration;\n            const root = (2 * Math.PI) / (visualDuration * 1.2);\n            const stiffness = root * root;\n            const damping = 2 *\n                clamp(0.05, 1, 1 - (options.bounce || 0)) *\n                Math.sqrt(stiffness);\n            springOptions = {\n                ...springOptions,\n                mass: springDefaults.mass,\n                stiffness,\n                damping,\n            };\n        }\n        else {\n            const derived = findSpring(options);\n            springOptions = {\n                ...springOptions,\n                ...derived,\n                mass: springDefaults.mass,\n            };\n            springOptions.isResolvedFromDuration = true;\n        }\n    }\n    return springOptions;\n}\nfunction spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {\n    const options = typeof optionsOrVisualDuration !== \"object\"\n        ? {\n            visualDuration: optionsOrVisualDuration,\n            keyframes: [0, 1],\n            bounce,\n        }\n        : optionsOrVisualDuration;\n    let { restSpeed, restDelta } = options;\n    const origin = options.keyframes[0];\n    const target = options.keyframes[options.keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration, } = getSpringOptions({\n        ...options,\n        velocity: -millisecondsToSeconds(options.velocity || 0),\n    });\n    const initialVelocity = velocity || 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale\n        ? springDefaults.restSpeed.granular\n        : springDefaults.restSpeed.default);\n    restDelta || (restDelta = isGranularScale\n        ? springDefaults.restDelta.granular\n        : springDefaults.restDelta.default);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    const generator = {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = 0.0;\n                /**\n                 * We only need to calculate velocity for under-damped springs\n                 * as over- and critically-damped springs can't overshoot, so\n                 * checking only for displacement is enough.\n                 */\n                if (dampingRatio < 1) {\n                    currentVelocity =\n                        t === 0\n                            ? secondsToMilliseconds(initialVelocity)\n                            : calcGeneratorVelocity(resolveSpring, t, current);\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n        toString: () => {\n            const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n            const easing = generateLinearEasing((progress) => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);\n            return calculatedDuration + \"ms \" + easing;\n        },\n    };\n    return generator;\n}\n\nexport { spring };\n"]},"metadata":{},"sourceType":"module"}