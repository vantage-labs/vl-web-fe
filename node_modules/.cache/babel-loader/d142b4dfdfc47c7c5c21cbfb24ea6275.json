{"ast":null,"code":"// packages/react/compose-refs/src/composeRefs.tsx\nimport * as React from \"react\";\n\nfunction setRef(ref, value) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  } else if (ref !== null && ref !== void 0) {\n    ref.current = value;\n  }\n}\n\nfunction composeRefs() {\n  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {\n    refs[_key] = arguments[_key];\n  }\n\n  return node => {\n    let hasCleanup = false;\n    const cleanups = refs.map(ref => {\n      const cleanup = setRef(ref, node);\n\n      if (!hasCleanup && typeof cleanup == \"function\") {\n        hasCleanup = true;\n      }\n\n      return cleanup;\n    });\n\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n\n          if (typeof cleanup == \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\nfunction useComposedRefs() {\n  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    refs[_key2] = arguments[_key2];\n  }\n\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };","map":{"version":3,"mappings":";AAAA,YAAYA,KAAZ,MAAuB,OAAvB;;AAQA,SAASC,MAAT,CAAmBC,GAAnB,EAAwCC,KAAxC,EAAkD;AAChD,MAAI,OAAOD,GAAP,KAAe,UAAnB,EAA+B;AAC7B,WAAOA,IAAIC,KAAJ,CAAP;AACF,GAFA,MAEA,IAAWD,QAAQ,IAAR,IAAgBA,QAAQ,MAAnC,EAA8C;AAC5CA,QAAIE,OAAJ,GAAcD,KAAd;AACF;AACF;;AAMA,SAASE,WAAT,GAAyE;AAAA,oCAA9CC,IAA8C;AAA9CA,QAA8C;AAAA;;AACvE,SAAQC,IAAD,IAAU;AACf,QAAIC,aAAa,KAAjB;AACA,UAAMC,WAAWH,KAAKI,GAAL,CAAUR,GAAD,IAAS;AACjC,YAAMS,UAAUV,OAAOC,GAAP,EAAYK,IAAZ,CAAhB;;AACA,UAAI,CAACC,UAAD,IAAe,OAAOG,OAAP,IAAkB,UAArC,EAAiD;AAC/CH,qBAAa,IAAb;AACF;;AACA,aAAOG,OAAP;AACD,KANgB,CAAjB;;AAYA,QAAIH,UAAJ,EAAgB;AACd,aAAO,MAAM;AACX,iBAASI,IAAI,CAAb,EAAgBA,IAAIH,SAASI,MAA7B,EAAqCD,GAArC,EAA0C;AACxC,gBAAMD,UAAUF,SAASG,CAAT,CAAhB;;AACA,cAAI,OAAOD,OAAP,IAAkB,UAAtB,EAAkC;AAChCA;AACF,WAFA,MAEO;AACLV,mBAAOK,KAAKM,CAAL,CAAP,EAAgB,IAAhB;AACF;AACF;AACF,OATA;AAUF;AACF,GA1BA;AA2BF;;AAMA,SAASE,eAAT,GAA6E;AAAA,qCAA9CR,IAA8C;AAA9CA,QAA8C;AAAA;;AAE3E,SAAaN,kBAAYK,YAAY,GAAGC,IAAf,CAAZ,EAAkCA,IAAlC,CAAb;AACF","names":["React","setRef","ref","value","current","composeRefs","refs","node","hasCleanup","cleanups","map","cleanup","i","length","useComposedRefs"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-compose-refs/src/composeRefs.tsx"],"sourcesContent":["import * as React from 'react';\n\ntype PossibleRef<T> = React.Ref<T> | undefined;\n\n/**\n * Set a given ref to a given value\n * This utility takes care of different types of refs: callback refs and RefObject(s)\n */\nfunction setRef<T>(ref: PossibleRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    return ref(value);\n  } else if (ref !== null && ref !== undefined) {\n    ref.current = value;\n  }\n}\n\n/**\n * A utility to compose multiple refs together\n * Accepts callback refs and RefObject(s)\n */\nfunction composeRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup == 'function') {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n\n    // React <19 will log an error to the console if a callback ref returns a\n    // value. We don't use ref cleanups internally so this will only happen if a\n    // user's ref callback returns a value, which we only expect if they are\n    // using the cleanup functionality added in React 19.\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup == 'function') {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\n\n/**\n * A custom hook that composes multiple refs\n * Accepts callback refs and RefObject(s)\n */\nfunction useComposedRefs<T>(...refs: PossibleRef<T>[]): React.RefCallback<T> {\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  return React.useCallback(composeRefs(...refs), refs);\n}\n\nexport { composeRefs, useComposedRefs };\n"]},"metadata":{},"sourceType":"module"}