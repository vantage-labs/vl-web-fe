{"ast":null,"code":"\"use client\"; // packages/react/checkbox/src/Checkbox.tsx\n\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { usePrevious } from \"@radix-ui/react-use-previous\";\nimport { useSize } from \"@radix-ui/react-use-size\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { jsx, jsxs } from \"react/jsx-runtime\";\nvar CHECKBOX_NAME = \"Checkbox\";\nvar [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);\nvar [CheckboxProvider, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);\nvar Checkbox = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeCheckbox,\n    name,\n    checked: checkedProp,\n    defaultChecked,\n    required,\n    disabled,\n    value = \"on\",\n    onCheckedChange,\n    form,\n    ...checkboxProps\n  } = props;\n  const [button, setButton] = React.useState(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setButton(node));\n  const hasConsumerStoppedPropagationRef = React.useRef(false);\n  const isFormControl = button ? form || !!button.closest(\"form\") : true;\n  const [checked = false, setChecked] = useControllableState({\n    prop: checkedProp,\n    defaultProp: defaultChecked,\n    onChange: onCheckedChange\n  });\n  const initialCheckedStateRef = React.useRef(checked);\n  React.useEffect(() => {\n    const form2 = button?.form;\n\n    if (form2) {\n      const reset = () => setChecked(initialCheckedStateRef.current);\n\n      form2.addEventListener(\"reset\", reset);\n      return () => form2.removeEventListener(\"reset\", reset);\n    }\n  }, [button, setChecked]);\n  return /* @__PURE__ */jsxs(CheckboxProvider, {\n    scope: __scopeCheckbox,\n    state: checked,\n    disabled,\n    children: [/* @__PURE__ */jsx(Primitive.button, {\n      type: \"button\",\n      role: \"checkbox\",\n      \"aria-checked\": isIndeterminate(checked) ? \"mixed\" : checked,\n      \"aria-required\": required,\n      \"data-state\": getState(checked),\n      \"data-disabled\": disabled ? \"\" : void 0,\n      disabled,\n      value,\n      ...checkboxProps,\n      ref: composedRefs,\n      onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n        if (event.key === \"Enter\") event.preventDefault();\n      }),\n      onClick: composeEventHandlers(props.onClick, event => {\n        setChecked(prevChecked => isIndeterminate(prevChecked) ? true : !prevChecked);\n\n        if (isFormControl) {\n          hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n          if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();\n        }\n      })\n    }), isFormControl && /* @__PURE__ */jsx(BubbleInput, {\n      control: button,\n      bubbles: !hasConsumerStoppedPropagationRef.current,\n      name,\n      value,\n      checked,\n      required,\n      disabled,\n      form,\n      style: {\n        transform: \"translateX(-100%)\"\n      },\n      defaultChecked: isIndeterminate(defaultChecked) ? false : defaultChecked\n    })]\n  });\n});\nCheckbox.displayName = CHECKBOX_NAME;\nvar INDICATOR_NAME = \"CheckboxIndicator\";\nvar CheckboxIndicator = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeCheckbox,\n    forceMount,\n    ...indicatorProps\n  } = props;\n  const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || isIndeterminate(context.state) || context.state === true,\n    children: /* @__PURE__ */jsx(Primitive.span, {\n      \"data-state\": getState(context.state),\n      \"data-disabled\": context.disabled ? \"\" : void 0,\n      ...indicatorProps,\n      ref: forwardedRef,\n      style: {\n        pointerEvents: \"none\",\n        ...props.style\n      }\n    })\n  });\n});\nCheckboxIndicator.displayName = INDICATOR_NAME;\n\nvar BubbleInput = props => {\n  const {\n    control,\n    checked,\n    bubbles = true,\n    defaultChecked,\n    ...inputProps\n  } = props;\n  const ref = React.useRef(null);\n  const prevChecked = usePrevious(checked);\n  const controlSize = useSize(control);\n  React.useEffect(() => {\n    const input = ref.current;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, \"checked\");\n    const setChecked = descriptor.set;\n\n    if (prevChecked !== checked && setChecked) {\n      const event = new Event(\"click\", {\n        bubbles\n      });\n      input.indeterminate = isIndeterminate(checked);\n      setChecked.call(input, isIndeterminate(checked) ? false : checked);\n      input.dispatchEvent(event);\n    }\n  }, [prevChecked, checked, bubbles]);\n  const defaultCheckedRef = React.useRef(isIndeterminate(checked) ? false : checked);\n  return /* @__PURE__ */jsx(\"input\", {\n    type: \"checkbox\",\n    \"aria-hidden\": true,\n    defaultChecked: defaultChecked ?? defaultCheckedRef.current,\n    ...inputProps,\n    tabIndex: -1,\n    ref,\n    style: { ...props.style,\n      ...controlSize,\n      position: \"absolute\",\n      pointerEvents: \"none\",\n      opacity: 0,\n      margin: 0\n    }\n  });\n};\n\nfunction isIndeterminate(checked) {\n  return checked === \"indeterminate\";\n}\n\nfunction getState(checked) {\n  return isIndeterminate(checked) ? \"indeterminate\" : checked ? \"checked\" : \"unchecked\";\n}\n\nvar Root = Checkbox;\nvar Indicator = CheckboxIndicator;\nexport { Checkbox, CheckboxIndicator, Indicator, Root, createCheckboxScope };","map":{"version":3,"mappings":"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","names":["React","useComposedRefs","createContextScope","composeEventHandlers","useControllableState","usePrevious","useSize","Presence","Primitive","jsx","CHECKBOX_NAME","createCheckboxContext","createCheckboxScope","CheckboxProvider","useCheckboxContext","Checkbox","props","forwardedRef","__scopeCheckbox","name","checked","checkedProp","defaultChecked","required","disabled","value","onCheckedChange","form","checkboxProps","button","setButton","composedRefs","node","hasConsumerStoppedPropagationRef","isFormControl","closest","setChecked","prop","defaultProp","onChange","initialCheckedStateRef","reset","current","addEventListener","removeEventListener","scope","state","children","type","role","isIndeterminate","getState","ref","onKeyDown","event","key","preventDefault","onClick","prevChecked","isPropagationStopped","stopPropagation","BubbleInput","control","bubbles","style","transform","displayName","INDICATOR_NAME","CheckboxIndicator","forceMount","indicatorProps","context","present","span","pointerEvents","inputProps","controlSize","input","inputProto","window","HTMLInputElement","prototype","descriptor","Object","getOwnPropertyDescriptor","set","Event","indeterminate","call","dispatchEvent","defaultCheckedRef","tabIndex","position","opacity","margin","Root","Indicator"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-checkbox/src/Checkbox.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useSize } from '@radix-ui/react-use-size';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * Checkbox\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_NAME = 'Checkbox';\n\ntype ScopedProps<P> = P & { __scopeCheckbox?: Scope };\nconst [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);\n\ntype CheckedState = boolean | 'indeterminate';\n\ntype CheckboxContextValue = {\n  state: CheckedState;\n  disabled?: boolean;\n};\n\nconst [CheckboxProvider, useCheckboxContext] =\n  createCheckboxContext<CheckboxContextValue>(CHECKBOX_NAME);\n\ntype CheckboxElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface CheckboxProps extends Omit<PrimitiveButtonProps, 'checked' | 'defaultChecked'> {\n  checked?: CheckedState;\n  defaultChecked?: CheckedState;\n  required?: boolean;\n  onCheckedChange?(checked: CheckedState): void;\n}\n\nconst Checkbox = React.forwardRef<CheckboxElement, CheckboxProps>(\n  (props: ScopedProps<CheckboxProps>, forwardedRef) => {\n    const {\n      __scopeCheckbox,\n      name,\n      checked: checkedProp,\n      defaultChecked,\n      required,\n      disabled,\n      value = 'on',\n      onCheckedChange,\n      form,\n      ...checkboxProps\n    } = props;\n    const [button, setButton] = React.useState<HTMLButtonElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));\n    const hasConsumerStoppedPropagationRef = React.useRef(false);\n    // We set this to true by default so that events bubble to forms without JS (SSR)\n    const isFormControl = button ? form || !!button.closest('form') : true;\n    const [checked = false, setChecked] = useControllableState({\n      prop: checkedProp,\n      defaultProp: defaultChecked,\n      onChange: onCheckedChange,\n    });\n    const initialCheckedStateRef = React.useRef(checked);\n    React.useEffect(() => {\n      const form = button?.form;\n      if (form) {\n        const reset = () => setChecked(initialCheckedStateRef.current);\n        form.addEventListener('reset', reset);\n        return () => form.removeEventListener('reset', reset);\n      }\n    }, [button, setChecked]);\n\n    return (\n      <CheckboxProvider scope={__scopeCheckbox} state={checked} disabled={disabled}>\n        <Primitive.button\n          type=\"button\"\n          role=\"checkbox\"\n          aria-checked={isIndeterminate(checked) ? 'mixed' : checked}\n          aria-required={required}\n          data-state={getState(checked)}\n          data-disabled={disabled ? '' : undefined}\n          disabled={disabled}\n          value={value}\n          {...checkboxProps}\n          ref={composedRefs}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            // According to WAI ARIA, Checkboxes don't activate on enter keypress\n            if (event.key === 'Enter') event.preventDefault();\n          })}\n          onClick={composeEventHandlers(props.onClick, (event) => {\n            setChecked((prevChecked) => (isIndeterminate(prevChecked) ? true : !prevChecked));\n            if (isFormControl) {\n              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();\n              // if checkbox is in a form, stop propagation from the button so that we only propagate\n              // one click event (from the input). We propagate changes from an input so that native\n              // form validation works and form events reflect checkbox updates.\n              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();\n            }\n          })}\n        />\n        {isFormControl && (\n          <BubbleInput\n            control={button}\n            bubbles={!hasConsumerStoppedPropagationRef.current}\n            name={name}\n            value={value}\n            checked={checked}\n            required={required}\n            disabled={disabled}\n            form={form}\n            // We transform because the input is absolutely positioned but we have\n            // rendered it **after** the button. This pulls it back to sit on top\n            // of the button.\n            style={{ transform: 'translateX(-100%)' }}\n            defaultChecked={isIndeterminate(defaultChecked) ? false : defaultChecked}\n          />\n        )}\n      </CheckboxProvider>\n    );\n  }\n);\n\nCheckbox.displayName = CHECKBOX_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * CheckboxIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'CheckboxIndicator';\n\ntype CheckboxIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface CheckboxIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst CheckboxIndicator = React.forwardRef<CheckboxIndicatorElement, CheckboxIndicatorProps>(\n  (props: ScopedProps<CheckboxIndicatorProps>, forwardedRef) => {\n    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;\n    const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);\n    return (\n      <Presence present={forceMount || isIndeterminate(context.state) || context.state === true}>\n        <Primitive.span\n          data-state={getState(context.state)}\n          data-disabled={context.disabled ? '' : undefined}\n          {...indicatorProps}\n          ref={forwardedRef}\n          style={{ pointerEvents: 'none', ...props.style }}\n        />\n      </Presence>\n    );\n  }\n);\n\nCheckboxIndicator.displayName = INDICATOR_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype InputProps = React.ComponentPropsWithoutRef<'input'>;\ninterface BubbleInputProps extends Omit<InputProps, 'checked'> {\n  checked: CheckedState;\n  control: HTMLElement | null;\n  bubbles: boolean;\n}\n\nconst BubbleInput = (props: BubbleInputProps) => {\n  const { control, checked, bubbles = true, defaultChecked, ...inputProps } = props;\n  const ref = React.useRef<HTMLInputElement>(null);\n  const prevChecked = usePrevious(checked);\n  const controlSize = useSize(control);\n\n  // Bubble checked change to parents (e.g form change event)\n  React.useEffect(() => {\n    const input = ref.current!;\n    const inputProto = window.HTMLInputElement.prototype;\n    const descriptor = Object.getOwnPropertyDescriptor(inputProto, 'checked') as PropertyDescriptor;\n    const setChecked = descriptor.set;\n\n    if (prevChecked !== checked && setChecked) {\n      const event = new Event('click', { bubbles });\n      input.indeterminate = isIndeterminate(checked);\n      setChecked.call(input, isIndeterminate(checked) ? false : checked);\n      input.dispatchEvent(event);\n    }\n  }, [prevChecked, checked, bubbles]);\n\n  const defaultCheckedRef = React.useRef(isIndeterminate(checked) ? false : checked);\n  return (\n    <input\n      type=\"checkbox\"\n      aria-hidden\n      defaultChecked={defaultChecked ?? defaultCheckedRef.current}\n      {...inputProps}\n      tabIndex={-1}\n      ref={ref}\n      style={{\n        ...props.style,\n        ...controlSize,\n        position: 'absolute',\n        pointerEvents: 'none',\n        opacity: 0,\n        margin: 0,\n      }}\n    />\n  );\n};\n\nfunction isIndeterminate(checked?: CheckedState): checked is 'indeterminate' {\n  return checked === 'indeterminate';\n}\n\nfunction getState(checked: CheckedState) {\n  return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n}\n\nconst Root = Checkbox;\nconst Indicator = CheckboxIndicator;\n\nexport {\n  createCheckboxScope,\n  //\n  Checkbox,\n  CheckboxIndicator,\n  //\n  Root,\n  Indicator,\n};\nexport type { CheckboxProps, CheckboxIndicatorProps, CheckedState };\n"]},"metadata":{},"sourceType":"module"}