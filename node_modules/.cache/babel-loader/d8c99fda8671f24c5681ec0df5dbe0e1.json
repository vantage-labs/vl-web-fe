{"ast":null,"code":"\"use client\"; // packages/react/navigation-menu/src/NavigationMenu.tsx\n\nimport * as React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { Primitive, dispatchDiscreteCustomEvent } from \"@radix-ui/react-primitive\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport { composeRefs, useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { useDirection } from \"@radix-ui/react-direction\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { useId } from \"@radix-ui/react-id\";\nimport { createCollection } from \"@radix-ui/react-collection\";\nimport { DismissableLayer } from \"@radix-ui/react-dismissable-layer\";\nimport { usePrevious } from \"@radix-ui/react-use-previous\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport * as VisuallyHiddenPrimitive from \"@radix-ui/react-visually-hidden\";\nimport { Fragment, jsx, jsxs } from \"react/jsx-runtime\";\nvar NAVIGATION_MENU_NAME = \"NavigationMenu\";\nvar [Collection, useCollection, createCollectionScope] = createCollection(NAVIGATION_MENU_NAME);\nvar [FocusGroupCollection, useFocusGroupCollection, createFocusGroupCollectionScope] = createCollection(NAVIGATION_MENU_NAME);\nvar [createNavigationMenuContext, createNavigationMenuScope] = createContextScope(NAVIGATION_MENU_NAME, [createCollectionScope, createFocusGroupCollectionScope]);\nvar [NavigationMenuProviderImpl, useNavigationMenuContext] = createNavigationMenuContext(NAVIGATION_MENU_NAME);\nvar [ViewportContentProvider, useViewportContentContext] = createNavigationMenuContext(NAVIGATION_MENU_NAME);\nvar NavigationMenu = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeNavigationMenu,\n    value: valueProp,\n    onValueChange,\n    defaultValue,\n    delayDuration = 200,\n    skipDelayDuration = 300,\n    orientation = \"horizontal\",\n    dir,\n    ...NavigationMenuProps\n  } = props;\n  const [navigationMenu, setNavigationMenu] = React.useState(null);\n  const composedRef = useComposedRefs(forwardedRef, node => setNavigationMenu(node));\n  const direction = useDirection(dir);\n  const openTimerRef = React.useRef(0);\n  const closeTimerRef = React.useRef(0);\n  const skipDelayTimerRef = React.useRef(0);\n  const [isOpenDelayed, setIsOpenDelayed] = React.useState(true);\n  const [value = \"\", setValue] = useControllableState({\n    prop: valueProp,\n    onChange: value2 => {\n      const isOpen = value2 !== \"\";\n      const hasSkipDelayDuration = skipDelayDuration > 0;\n\n      if (isOpen) {\n        window.clearTimeout(skipDelayTimerRef.current);\n        if (hasSkipDelayDuration) setIsOpenDelayed(false);\n      } else {\n        window.clearTimeout(skipDelayTimerRef.current);\n        skipDelayTimerRef.current = window.setTimeout(() => setIsOpenDelayed(true), skipDelayDuration);\n      }\n\n      onValueChange?.(value2);\n    },\n    defaultProp: defaultValue\n  });\n  const startCloseTimer = React.useCallback(() => {\n    window.clearTimeout(closeTimerRef.current);\n    closeTimerRef.current = window.setTimeout(() => setValue(\"\"), 150);\n  }, [setValue]);\n  const handleOpen = React.useCallback(itemValue => {\n    window.clearTimeout(closeTimerRef.current);\n    setValue(itemValue);\n  }, [setValue]);\n  const handleDelayedOpen = React.useCallback(itemValue => {\n    const isOpenItem = value === itemValue;\n\n    if (isOpenItem) {\n      window.clearTimeout(closeTimerRef.current);\n    } else {\n      openTimerRef.current = window.setTimeout(() => {\n        window.clearTimeout(closeTimerRef.current);\n        setValue(itemValue);\n      }, delayDuration);\n    }\n  }, [value, setValue, delayDuration]);\n  React.useEffect(() => {\n    return () => {\n      window.clearTimeout(openTimerRef.current);\n      window.clearTimeout(closeTimerRef.current);\n      window.clearTimeout(skipDelayTimerRef.current);\n    };\n  }, []);\n  return /* @__PURE__ */jsx(NavigationMenuProvider, {\n    scope: __scopeNavigationMenu,\n    isRootMenu: true,\n    value,\n    dir: direction,\n    orientation,\n    rootNavigationMenu: navigationMenu,\n    onTriggerEnter: itemValue => {\n      window.clearTimeout(openTimerRef.current);\n      if (isOpenDelayed) handleDelayedOpen(itemValue);else handleOpen(itemValue);\n    },\n    onTriggerLeave: () => {\n      window.clearTimeout(openTimerRef.current);\n      startCloseTimer();\n    },\n    onContentEnter: () => window.clearTimeout(closeTimerRef.current),\n    onContentLeave: startCloseTimer,\n    onItemSelect: itemValue => {\n      setValue(prevValue => prevValue === itemValue ? \"\" : itemValue);\n    },\n    onItemDismiss: () => setValue(\"\"),\n    children: /* @__PURE__ */jsx(Primitive.nav, {\n      \"aria-label\": \"Main\",\n      \"data-orientation\": orientation,\n      dir: direction,\n      ...NavigationMenuProps,\n      ref: composedRef\n    })\n  });\n});\nNavigationMenu.displayName = NAVIGATION_MENU_NAME;\nvar SUB_NAME = \"NavigationMenuSub\";\nvar NavigationMenuSub = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeNavigationMenu,\n    value: valueProp,\n    onValueChange,\n    defaultValue,\n    orientation = \"horizontal\",\n    ...subProps\n  } = props;\n  const context = useNavigationMenuContext(SUB_NAME, __scopeNavigationMenu);\n  const [value = \"\", setValue] = useControllableState({\n    prop: valueProp,\n    onChange: onValueChange,\n    defaultProp: defaultValue\n  });\n  return /* @__PURE__ */jsx(NavigationMenuProvider, {\n    scope: __scopeNavigationMenu,\n    isRootMenu: false,\n    value,\n    dir: context.dir,\n    orientation,\n    rootNavigationMenu: context.rootNavigationMenu,\n    onTriggerEnter: itemValue => setValue(itemValue),\n    onItemSelect: itemValue => setValue(itemValue),\n    onItemDismiss: () => setValue(\"\"),\n    children: /* @__PURE__ */jsx(Primitive.div, {\n      \"data-orientation\": orientation,\n      ...subProps,\n      ref: forwardedRef\n    })\n  });\n});\nNavigationMenuSub.displayName = SUB_NAME;\n\nvar NavigationMenuProvider = props => {\n  const {\n    scope,\n    isRootMenu,\n    rootNavigationMenu,\n    dir,\n    orientation,\n    children,\n    value,\n    onItemSelect,\n    onItemDismiss,\n    onTriggerEnter,\n    onTriggerLeave,\n    onContentEnter,\n    onContentLeave\n  } = props;\n  const [viewport, setViewport] = React.useState(null);\n  const [viewportContent, setViewportContent] = React.useState( /* @__PURE__ */new Map());\n  const [indicatorTrack, setIndicatorTrack] = React.useState(null);\n  return /* @__PURE__ */jsx(NavigationMenuProviderImpl, {\n    scope,\n    isRootMenu,\n    rootNavigationMenu,\n    value,\n    previousValue: usePrevious(value),\n    baseId: useId(),\n    dir,\n    orientation,\n    viewport,\n    onViewportChange: setViewport,\n    indicatorTrack,\n    onIndicatorTrackChange: setIndicatorTrack,\n    onTriggerEnter: useCallbackRef(onTriggerEnter),\n    onTriggerLeave: useCallbackRef(onTriggerLeave),\n    onContentEnter: useCallbackRef(onContentEnter),\n    onContentLeave: useCallbackRef(onContentLeave),\n    onItemSelect: useCallbackRef(onItemSelect),\n    onItemDismiss: useCallbackRef(onItemDismiss),\n    onViewportContentChange: React.useCallback((contentValue, contentData) => {\n      setViewportContent(prevContent => {\n        prevContent.set(contentValue, contentData);\n        return new Map(prevContent);\n      });\n    }, []),\n    onViewportContentRemove: React.useCallback(contentValue => {\n      setViewportContent(prevContent => {\n        if (!prevContent.has(contentValue)) return prevContent;\n        prevContent.delete(contentValue);\n        return new Map(prevContent);\n      });\n    }, []),\n    children: /* @__PURE__ */jsx(Collection.Provider, {\n      scope,\n      children: /* @__PURE__ */jsx(ViewportContentProvider, {\n        scope,\n        items: viewportContent,\n        children\n      })\n    })\n  });\n};\n\nvar LIST_NAME = \"NavigationMenuList\";\nvar NavigationMenuList = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeNavigationMenu,\n    ...listProps\n  } = props;\n  const context = useNavigationMenuContext(LIST_NAME, __scopeNavigationMenu);\n  const list = /* @__PURE__ */jsx(Primitive.ul, {\n    \"data-orientation\": context.orientation,\n    ...listProps,\n    ref: forwardedRef\n  });\n  return /* @__PURE__ */jsx(Primitive.div, {\n    style: {\n      position: \"relative\"\n    },\n    ref: context.onIndicatorTrackChange,\n    children: /* @__PURE__ */jsx(Collection.Slot, {\n      scope: __scopeNavigationMenu,\n      children: context.isRootMenu ? /* @__PURE__ */jsx(FocusGroup, {\n        asChild: true,\n        children: list\n      }) : list\n    })\n  });\n});\nNavigationMenuList.displayName = LIST_NAME;\nvar ITEM_NAME = \"NavigationMenuItem\";\nvar [NavigationMenuItemContextProvider, useNavigationMenuItemContext] = createNavigationMenuContext(ITEM_NAME);\nvar NavigationMenuItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeNavigationMenu,\n    value: valueProp,\n    ...itemProps\n  } = props;\n  const autoValue = useId();\n  const value = valueProp || autoValue || \"LEGACY_REACT_AUTO_VALUE\";\n  const contentRef = React.useRef(null);\n  const triggerRef = React.useRef(null);\n  const focusProxyRef = React.useRef(null);\n  const restoreContentTabOrderRef = React.useRef(() => {});\n  const wasEscapeCloseRef = React.useRef(false);\n  const handleContentEntry = React.useCallback(function () {\n    let side = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"start\";\n\n    if (contentRef.current) {\n      restoreContentTabOrderRef.current();\n      const candidates = getTabbableCandidates(contentRef.current);\n      if (candidates.length) focusFirst(side === \"start\" ? candidates : candidates.reverse());\n    }\n  }, []);\n  const handleContentExit = React.useCallback(() => {\n    if (contentRef.current) {\n      const candidates = getTabbableCandidates(contentRef.current);\n      if (candidates.length) restoreContentTabOrderRef.current = removeFromTabOrder(candidates);\n    }\n  }, []);\n  return /* @__PURE__ */jsx(NavigationMenuItemContextProvider, {\n    scope: __scopeNavigationMenu,\n    value,\n    triggerRef,\n    contentRef,\n    focusProxyRef,\n    wasEscapeCloseRef,\n    onEntryKeyDown: handleContentEntry,\n    onFocusProxyEnter: handleContentEntry,\n    onRootContentClose: handleContentExit,\n    onContentFocusOutside: handleContentExit,\n    children: /* @__PURE__ */jsx(Primitive.li, { ...itemProps,\n      ref: forwardedRef\n    })\n  });\n});\nNavigationMenuItem.displayName = ITEM_NAME;\nvar TRIGGER_NAME = \"NavigationMenuTrigger\";\nvar NavigationMenuTrigger = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeNavigationMenu,\n    disabled,\n    ...triggerProps\n  } = props;\n  const context = useNavigationMenuContext(TRIGGER_NAME, props.__scopeNavigationMenu);\n  const itemContext = useNavigationMenuItemContext(TRIGGER_NAME, props.__scopeNavigationMenu);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(ref, itemContext.triggerRef, forwardedRef);\n  const triggerId = makeTriggerId(context.baseId, itemContext.value);\n  const contentId = makeContentId(context.baseId, itemContext.value);\n  const hasPointerMoveOpenedRef = React.useRef(false);\n  const wasClickCloseRef = React.useRef(false);\n  const open = itemContext.value === context.value;\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(Collection.ItemSlot, {\n      scope: __scopeNavigationMenu,\n      value: itemContext.value,\n      children: /* @__PURE__ */jsx(FocusGroupItem, {\n        asChild: true,\n        children: /* @__PURE__ */jsx(Primitive.button, {\n          id: triggerId,\n          disabled,\n          \"data-disabled\": disabled ? \"\" : void 0,\n          \"data-state\": getOpenState(open),\n          \"aria-expanded\": open,\n          \"aria-controls\": contentId,\n          ...triggerProps,\n          ref: composedRefs,\n          onPointerEnter: composeEventHandlers(props.onPointerEnter, () => {\n            wasClickCloseRef.current = false;\n            itemContext.wasEscapeCloseRef.current = false;\n          }),\n          onPointerMove: composeEventHandlers(props.onPointerMove, whenMouse(() => {\n            if (disabled || wasClickCloseRef.current || itemContext.wasEscapeCloseRef.current || hasPointerMoveOpenedRef.current) return;\n            context.onTriggerEnter(itemContext.value);\n            hasPointerMoveOpenedRef.current = true;\n          })),\n          onPointerLeave: composeEventHandlers(props.onPointerLeave, whenMouse(() => {\n            if (disabled) return;\n            context.onTriggerLeave();\n            hasPointerMoveOpenedRef.current = false;\n          })),\n          onClick: composeEventHandlers(props.onClick, () => {\n            context.onItemSelect(itemContext.value);\n            wasClickCloseRef.current = open;\n          }),\n          onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n            const verticalEntryKey = context.dir === \"rtl\" ? \"ArrowLeft\" : \"ArrowRight\";\n            const entryKey = {\n              horizontal: \"ArrowDown\",\n              vertical: verticalEntryKey\n            }[context.orientation];\n\n            if (open && event.key === entryKey) {\n              itemContext.onEntryKeyDown();\n              event.preventDefault();\n            }\n          })\n        })\n      })\n    }), open && /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(VisuallyHiddenPrimitive.Root, {\n        \"aria-hidden\": true,\n        tabIndex: 0,\n        ref: itemContext.focusProxyRef,\n        onFocus: event => {\n          const content = itemContext.contentRef.current;\n          const prevFocusedElement = event.relatedTarget;\n          const wasTriggerFocused = prevFocusedElement === ref.current;\n          const wasFocusFromContent = content?.contains(prevFocusedElement);\n\n          if (wasTriggerFocused || !wasFocusFromContent) {\n            itemContext.onFocusProxyEnter(wasTriggerFocused ? \"start\" : \"end\");\n          }\n        }\n      }), context.viewport && /* @__PURE__ */jsx(\"span\", {\n        \"aria-owns\": contentId\n      })]\n    })]\n  });\n});\nNavigationMenuTrigger.displayName = TRIGGER_NAME;\nvar LINK_NAME = \"NavigationMenuLink\";\nvar LINK_SELECT = \"navigationMenu.linkSelect\";\nvar NavigationMenuLink = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeNavigationMenu,\n    active,\n    onSelect,\n    ...linkProps\n  } = props;\n  return /* @__PURE__ */jsx(FocusGroupItem, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(Primitive.a, {\n      \"data-active\": active ? \"\" : void 0,\n      \"aria-current\": active ? \"page\" : void 0,\n      ...linkProps,\n      ref: forwardedRef,\n      onClick: composeEventHandlers(props.onClick, event => {\n        const target = event.target;\n        const linkSelectEvent = new CustomEvent(LINK_SELECT, {\n          bubbles: true,\n          cancelable: true\n        });\n        target.addEventListener(LINK_SELECT, event2 => onSelect?.(event2), {\n          once: true\n        });\n        dispatchDiscreteCustomEvent(target, linkSelectEvent);\n\n        if (!linkSelectEvent.defaultPrevented && !event.metaKey) {\n          const rootContentDismissEvent = new CustomEvent(ROOT_CONTENT_DISMISS, {\n            bubbles: true,\n            cancelable: true\n          });\n          dispatchDiscreteCustomEvent(target, rootContentDismissEvent);\n        }\n      }, {\n        checkForDefaultPrevented: false\n      })\n    })\n  });\n});\nNavigationMenuLink.displayName = LINK_NAME;\nvar INDICATOR_NAME = \"NavigationMenuIndicator\";\nvar NavigationMenuIndicator = React.forwardRef((props, forwardedRef) => {\n  const {\n    forceMount,\n    ...indicatorProps\n  } = props;\n  const context = useNavigationMenuContext(INDICATOR_NAME, props.__scopeNavigationMenu);\n  const isVisible = Boolean(context.value);\n  return context.indicatorTrack ? ReactDOM.createPortal( /* @__PURE__ */jsx(Presence, {\n    present: forceMount || isVisible,\n    children: /* @__PURE__ */jsx(NavigationMenuIndicatorImpl, { ...indicatorProps,\n      ref: forwardedRef\n    })\n  }), context.indicatorTrack) : null;\n});\nNavigationMenuIndicator.displayName = INDICATOR_NAME;\nvar NavigationMenuIndicatorImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeNavigationMenu,\n    ...indicatorProps\n  } = props;\n  const context = useNavigationMenuContext(INDICATOR_NAME, __scopeNavigationMenu);\n  const getItems = useCollection(__scopeNavigationMenu);\n  const [activeTrigger, setActiveTrigger] = React.useState(null);\n  const [position, setPosition] = React.useState(null);\n  const isHorizontal = context.orientation === \"horizontal\";\n  const isVisible = Boolean(context.value);\n  React.useEffect(() => {\n    const items = getItems();\n    const triggerNode = items.find(item => item.value === context.value)?.ref.current;\n    if (triggerNode) setActiveTrigger(triggerNode);\n  }, [getItems, context.value]);\n\n  const handlePositionChange = () => {\n    if (activeTrigger) {\n      setPosition({\n        size: isHorizontal ? activeTrigger.offsetWidth : activeTrigger.offsetHeight,\n        offset: isHorizontal ? activeTrigger.offsetLeft : activeTrigger.offsetTop\n      });\n    }\n  };\n\n  useResizeObserver(activeTrigger, handlePositionChange);\n  useResizeObserver(context.indicatorTrack, handlePositionChange);\n  return position ? /* @__PURE__ */jsx(Primitive.div, {\n    \"aria-hidden\": true,\n    \"data-state\": isVisible ? \"visible\" : \"hidden\",\n    \"data-orientation\": context.orientation,\n    ...indicatorProps,\n    ref: forwardedRef,\n    style: {\n      position: \"absolute\",\n      ...(isHorizontal ? {\n        left: 0,\n        width: position.size + \"px\",\n        transform: `translateX(${position.offset}px)`\n      } : {\n        top: 0,\n        height: position.size + \"px\",\n        transform: `translateY(${position.offset}px)`\n      }),\n      ...indicatorProps.style\n    }\n  }) : null;\n});\nvar CONTENT_NAME = \"NavigationMenuContent\";\nvar NavigationMenuContent = React.forwardRef((props, forwardedRef) => {\n  const {\n    forceMount,\n    ...contentProps\n  } = props;\n  const context = useNavigationMenuContext(CONTENT_NAME, props.__scopeNavigationMenu);\n  const itemContext = useNavigationMenuItemContext(CONTENT_NAME, props.__scopeNavigationMenu);\n  const composedRefs = useComposedRefs(itemContext.contentRef, forwardedRef);\n  const open = itemContext.value === context.value;\n  const commonProps = {\n    value: itemContext.value,\n    triggerRef: itemContext.triggerRef,\n    focusProxyRef: itemContext.focusProxyRef,\n    wasEscapeCloseRef: itemContext.wasEscapeCloseRef,\n    onContentFocusOutside: itemContext.onContentFocusOutside,\n    onRootContentClose: itemContext.onRootContentClose,\n    ...contentProps\n  };\n  return !context.viewport ? /* @__PURE__ */jsx(Presence, {\n    present: forceMount || open,\n    children: /* @__PURE__ */jsx(NavigationMenuContentImpl, {\n      \"data-state\": getOpenState(open),\n      ...commonProps,\n      ref: composedRefs,\n      onPointerEnter: composeEventHandlers(props.onPointerEnter, context.onContentEnter),\n      onPointerLeave: composeEventHandlers(props.onPointerLeave, whenMouse(context.onContentLeave)),\n      style: {\n        // Prevent interaction when animating out\n        pointerEvents: !open && context.isRootMenu ? \"none\" : void 0,\n        ...commonProps.style\n      }\n    })\n  }) : /* @__PURE__ */jsx(ViewportContentMounter, {\n    forceMount,\n    ...commonProps,\n    ref: composedRefs\n  });\n});\nNavigationMenuContent.displayName = CONTENT_NAME;\nvar ViewportContentMounter = React.forwardRef((props, forwardedRef) => {\n  const context = useNavigationMenuContext(CONTENT_NAME, props.__scopeNavigationMenu);\n  const {\n    onViewportContentChange,\n    onViewportContentRemove\n  } = context;\n  useLayoutEffect(() => {\n    onViewportContentChange(props.value, {\n      ref: forwardedRef,\n      ...props\n    });\n  }, [props, forwardedRef, onViewportContentChange]);\n  useLayoutEffect(() => {\n    return () => onViewportContentRemove(props.value);\n  }, [props.value, onViewportContentRemove]);\n  return null;\n});\nvar ROOT_CONTENT_DISMISS = \"navigationMenu.rootContentDismiss\";\nvar NavigationMenuContentImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeNavigationMenu,\n    value,\n    triggerRef,\n    focusProxyRef,\n    wasEscapeCloseRef,\n    onRootContentClose,\n    onContentFocusOutside,\n    ...contentProps\n  } = props;\n  const context = useNavigationMenuContext(CONTENT_NAME, __scopeNavigationMenu);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(ref, forwardedRef);\n  const triggerId = makeTriggerId(context.baseId, value);\n  const contentId = makeContentId(context.baseId, value);\n  const getItems = useCollection(__scopeNavigationMenu);\n  const prevMotionAttributeRef = React.useRef(null);\n  const {\n    onItemDismiss\n  } = context;\n  React.useEffect(() => {\n    const content = ref.current;\n\n    if (context.isRootMenu && content) {\n      const handleClose = () => {\n        onItemDismiss();\n        onRootContentClose();\n        if (content.contains(document.activeElement)) triggerRef.current?.focus();\n      };\n\n      content.addEventListener(ROOT_CONTENT_DISMISS, handleClose);\n      return () => content.removeEventListener(ROOT_CONTENT_DISMISS, handleClose);\n    }\n  }, [context.isRootMenu, props.value, triggerRef, onItemDismiss, onRootContentClose]);\n  const motionAttribute = React.useMemo(() => {\n    const items = getItems();\n    const values = items.map(item => item.value);\n    if (context.dir === \"rtl\") values.reverse();\n    const index = values.indexOf(context.value);\n    const prevIndex = values.indexOf(context.previousValue);\n    const isSelected = value === context.value;\n    const wasSelected = prevIndex === values.indexOf(value);\n    if (!isSelected && !wasSelected) return prevMotionAttributeRef.current;\n\n    const attribute = (() => {\n      if (index !== prevIndex) {\n        if (isSelected && prevIndex !== -1) return index > prevIndex ? \"from-end\" : \"from-start\";\n        if (wasSelected && index !== -1) return index > prevIndex ? \"to-start\" : \"to-end\";\n      }\n\n      return null;\n    })();\n\n    prevMotionAttributeRef.current = attribute;\n    return attribute;\n  }, [context.previousValue, context.value, context.dir, getItems, value]);\n  return /* @__PURE__ */jsx(FocusGroup, {\n    asChild: true,\n    children: /* @__PURE__ */jsx(DismissableLayer, {\n      id: contentId,\n      \"aria-labelledby\": triggerId,\n      \"data-motion\": motionAttribute,\n      \"data-orientation\": context.orientation,\n      ...contentProps,\n      ref: composedRefs,\n      disableOutsidePointerEvents: false,\n      onDismiss: () => {\n        const rootContentDismissEvent = new Event(ROOT_CONTENT_DISMISS, {\n          bubbles: true,\n          cancelable: true\n        });\n        ref.current?.dispatchEvent(rootContentDismissEvent);\n      },\n      onFocusOutside: composeEventHandlers(props.onFocusOutside, event => {\n        onContentFocusOutside();\n        const target = event.target;\n        if (context.rootNavigationMenu?.contains(target)) event.preventDefault();\n      }),\n      onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, event => {\n        const target = event.target;\n        const isTrigger = getItems().some(item => item.ref.current?.contains(target));\n        const isRootViewport = context.isRootMenu && context.viewport?.contains(target);\n        if (isTrigger || isRootViewport || !context.isRootMenu) event.preventDefault();\n      }),\n      onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n        const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n        const isTabKey = event.key === \"Tab\" && !isMetaKey;\n\n        if (isTabKey) {\n          const candidates = getTabbableCandidates(event.currentTarget);\n          const focusedElement = document.activeElement;\n          const index = candidates.findIndex(candidate => candidate === focusedElement);\n          const isMovingBackwards = event.shiftKey;\n          const nextCandidates = isMovingBackwards ? candidates.slice(0, index).reverse() : candidates.slice(index + 1, candidates.length);\n\n          if (focusFirst(nextCandidates)) {\n            event.preventDefault();\n          } else {\n            focusProxyRef.current?.focus();\n          }\n        }\n      }),\n      onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, _event => {\n        wasEscapeCloseRef.current = true;\n      })\n    })\n  });\n});\nvar VIEWPORT_NAME = \"NavigationMenuViewport\";\nvar NavigationMenuViewport = React.forwardRef((props, forwardedRef) => {\n  const {\n    forceMount,\n    ...viewportProps\n  } = props;\n  const context = useNavigationMenuContext(VIEWPORT_NAME, props.__scopeNavigationMenu);\n  const open = Boolean(context.value);\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || open,\n    children: /* @__PURE__ */jsx(NavigationMenuViewportImpl, { ...viewportProps,\n      ref: forwardedRef\n    })\n  });\n});\nNavigationMenuViewport.displayName = VIEWPORT_NAME;\nvar NavigationMenuViewportImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeNavigationMenu,\n    children,\n    ...viewportImplProps\n  } = props;\n  const context = useNavigationMenuContext(VIEWPORT_NAME, __scopeNavigationMenu);\n  const composedRefs = useComposedRefs(forwardedRef, context.onViewportChange);\n  const viewportContentContext = useViewportContentContext(CONTENT_NAME, props.__scopeNavigationMenu);\n  const [size, setSize] = React.useState(null);\n  const [content, setContent] = React.useState(null);\n  const viewportWidth = size ? size?.width + \"px\" : void 0;\n  const viewportHeight = size ? size?.height + \"px\" : void 0;\n  const open = Boolean(context.value);\n  const activeContentValue = open ? context.value : context.previousValue;\n\n  const handleSizeChange = () => {\n    if (content) setSize({\n      width: content.offsetWidth,\n      height: content.offsetHeight\n    });\n  };\n\n  useResizeObserver(content, handleSizeChange);\n  return /* @__PURE__ */jsx(Primitive.div, {\n    \"data-state\": getOpenState(open),\n    \"data-orientation\": context.orientation,\n    ...viewportImplProps,\n    ref: composedRefs,\n    style: {\n      // Prevent interaction when animating out\n      pointerEvents: !open && context.isRootMenu ? \"none\" : void 0,\n      [\"--radix-navigation-menu-viewport-width\"]: viewportWidth,\n      [\"--radix-navigation-menu-viewport-height\"]: viewportHeight,\n      ...viewportImplProps.style\n    },\n    onPointerEnter: composeEventHandlers(props.onPointerEnter, context.onContentEnter),\n    onPointerLeave: composeEventHandlers(props.onPointerLeave, whenMouse(context.onContentLeave)),\n    children: Array.from(viewportContentContext.items).map(_ref => {\n      let [value, {\n        ref,\n        forceMount,\n        ...props2\n      }] = _ref;\n      const isActive = activeContentValue === value;\n      return /* @__PURE__ */jsx(Presence, {\n        present: forceMount || isActive,\n        children: /* @__PURE__ */jsx(NavigationMenuContentImpl, { ...props2,\n          ref: composeRefs(ref, node => {\n            if (isActive && node) setContent(node);\n          })\n        })\n      }, value);\n    })\n  });\n});\nvar FOCUS_GROUP_NAME = \"FocusGroup\";\nvar FocusGroup = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeNavigationMenu,\n    ...groupProps\n  } = props;\n  const context = useNavigationMenuContext(FOCUS_GROUP_NAME, __scopeNavigationMenu);\n  return /* @__PURE__ */jsx(FocusGroupCollection.Provider, {\n    scope: __scopeNavigationMenu,\n    children: /* @__PURE__ */jsx(FocusGroupCollection.Slot, {\n      scope: __scopeNavigationMenu,\n      children: /* @__PURE__ */jsx(Primitive.div, {\n        dir: context.dir,\n        ...groupProps,\n        ref: forwardedRef\n      })\n    })\n  });\n});\nvar ARROW_KEYS = [\"ArrowRight\", \"ArrowLeft\", \"ArrowUp\", \"ArrowDown\"];\nvar FOCUS_GROUP_ITEM_NAME = \"FocusGroupItem\";\nvar FocusGroupItem = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeNavigationMenu,\n    ...groupProps\n  } = props;\n  const getItems = useFocusGroupCollection(__scopeNavigationMenu);\n  const context = useNavigationMenuContext(FOCUS_GROUP_ITEM_NAME, __scopeNavigationMenu);\n  return /* @__PURE__ */jsx(FocusGroupCollection.ItemSlot, {\n    scope: __scopeNavigationMenu,\n    children: /* @__PURE__ */jsx(Primitive.button, { ...groupProps,\n      ref: forwardedRef,\n      onKeyDown: composeEventHandlers(props.onKeyDown, event => {\n        const isFocusNavigationKey = [\"Home\", \"End\", ...ARROW_KEYS].includes(event.key);\n\n        if (isFocusNavigationKey) {\n          let candidateNodes = getItems().map(item => item.ref.current);\n          const prevItemKey = context.dir === \"rtl\" ? \"ArrowRight\" : \"ArrowLeft\";\n          const prevKeys = [prevItemKey, \"ArrowUp\", \"End\"];\n          if (prevKeys.includes(event.key)) candidateNodes.reverse();\n\n          if (ARROW_KEYS.includes(event.key)) {\n            const currentIndex = candidateNodes.indexOf(event.currentTarget);\n            candidateNodes = candidateNodes.slice(currentIndex + 1);\n          }\n\n          setTimeout(() => focusFirst(candidateNodes));\n          event.preventDefault();\n        }\n      })\n    })\n  });\n});\n\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n\n  return nodes;\n}\n\nfunction focusFirst(candidates) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some(candidate => {\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nfunction removeFromTabOrder(candidates) {\n  candidates.forEach(candidate => {\n    candidate.dataset.tabindex = candidate.getAttribute(\"tabindex\") || \"\";\n    candidate.setAttribute(\"tabindex\", \"-1\");\n  });\n  return () => {\n    candidates.forEach(candidate => {\n      const prevTabIndex = candidate.dataset.tabindex;\n      candidate.setAttribute(\"tabindex\", prevTabIndex);\n    });\n  };\n}\n\nfunction useResizeObserver(element, onResize) {\n  const handleResize = useCallbackRef(onResize);\n  useLayoutEffect(() => {\n    let rAF = 0;\n\n    if (element) {\n      const resizeObserver = new ResizeObserver(() => {\n        cancelAnimationFrame(rAF);\n        rAF = window.requestAnimationFrame(handleResize);\n      });\n      resizeObserver.observe(element);\n      return () => {\n        window.cancelAnimationFrame(rAF);\n        resizeObserver.unobserve(element);\n      };\n    }\n  }, [element, handleResize]);\n}\n\nfunction getOpenState(open) {\n  return open ? \"open\" : \"closed\";\n}\n\nfunction makeTriggerId(baseId, value) {\n  return `${baseId}-trigger-${value}`;\n}\n\nfunction makeContentId(baseId, value) {\n  return `${baseId}-content-${value}`;\n}\n\nfunction whenMouse(handler) {\n  return event => event.pointerType === \"mouse\" ? handler(event) : void 0;\n}\n\nvar Root2 = NavigationMenu;\nvar Sub = NavigationMenuSub;\nvar List = NavigationMenuList;\nvar Item = NavigationMenuItem;\nvar Trigger = NavigationMenuTrigger;\nvar Link = NavigationMenuLink;\nvar Indicator = NavigationMenuIndicator;\nvar Content = NavigationMenuContent;\nvar Viewport = NavigationMenuViewport;\nexport { Content, Indicator, Item, Link, List, NavigationMenu, NavigationMenuContent, NavigationMenuIndicator, NavigationMenuItem, NavigationMenuLink, NavigationMenuList, NavigationMenuSub, NavigationMenuTrigger, NavigationMenuViewport, Root2 as Root, Sub, Trigger, Viewport, createNavigationMenuScope };","map":{"version":3,"mappings":"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","names":["React","ReactDOM","createContextScope","composeEventHandlers","Primitive","dispatchDiscreteCustomEvent","useControllableState","composeRefs","useComposedRefs","useDirection","Presence","useId","createCollection","DismissableLayer","usePrevious","useLayoutEffect","useCallbackRef","VisuallyHiddenPrimitive","Fragment","jsxs","NAVIGATION_MENU_NAME","Collection","useCollection","createCollectionScope","FocusGroupCollection","useFocusGroupCollection","createFocusGroupCollectionScope","createNavigationMenuContext","createNavigationMenuScope","NavigationMenuProviderImpl","useNavigationMenuContext","ViewportContentProvider","useViewportContentContext","NavigationMenu","props","forwardedRef","__scopeNavigationMenu","value","valueProp","onValueChange","defaultValue","delayDuration","skipDelayDuration","orientation","dir","NavigationMenuProps","navigationMenu","setNavigationMenu","composedRef","node","direction","openTimerRef","closeTimerRef","skipDelayTimerRef","isOpenDelayed","setIsOpenDelayed","setValue","prop","onChange","isOpen","hasSkipDelayDuration","window","clearTimeout","current","setTimeout","defaultProp","startCloseTimer","handleOpen","itemValue","handleDelayedOpen","isOpenItem","NavigationMenuProvider","scope","isRootMenu","rootNavigationMenu","onTriggerEnter","onTriggerLeave","onContentEnter","onContentLeave","onItemSelect","prevValue","onItemDismiss","children","nav","ref","displayName","SUB_NAME","NavigationMenuSub","subProps","context","div","viewport","setViewport","viewportContent","setViewportContent","Map","indicatorTrack","setIndicatorTrack","previousValue","baseId","onViewportChange","onIndicatorTrackChange","onViewportContentChange","contentValue","contentData","prevContent","set","onViewportContentRemove","has","delete","Provider","items","LIST_NAME","NavigationMenuList","listProps","list","ul","style","position","Slot","FocusGroup","asChild","ITEM_NAME","NavigationMenuItemContextProvider","useNavigationMenuItemContext","NavigationMenuItem","itemProps","autoValue","contentRef","triggerRef","focusProxyRef","restoreContentTabOrderRef","wasEscapeCloseRef","handleContentEntry","side","candidates","getTabbableCandidates","length","focusFirst","reverse","handleContentExit","removeFromTabOrder","onEntryKeyDown","onFocusProxyEnter","onRootContentClose","onContentFocusOutside","li","TRIGGER_NAME","NavigationMenuTrigger","disabled","triggerProps","itemContext","composedRefs","triggerId","makeTriggerId","contentId","makeContentId","hasPointerMoveOpenedRef","wasClickCloseRef","open","ItemSlot","FocusGroupItem","button","id","getOpenState","onPointerEnter","onPointerMove","whenMouse","onPointerLeave","onClick","onKeyDown","event","verticalEntryKey","entryKey","horizontal","vertical","key","preventDefault","tabIndex","onFocus","content","prevFocusedElement","relatedTarget","wasTriggerFocused","wasFocusFromContent","contains","LINK_NAME","LINK_SELECT","NavigationMenuLink","active","onSelect","linkProps","a","target","linkSelectEvent","CustomEvent","bubbles","cancelable","addEventListener","once","defaultPrevented","metaKey","rootContentDismissEvent","ROOT_CONTENT_DISMISS","checkForDefaultPrevented","INDICATOR_NAME","NavigationMenuIndicator","forceMount","indicatorProps","isVisible","Boolean","createPortal","present","NavigationMenuIndicatorImpl","getItems","activeTrigger","setActiveTrigger","setPosition","isHorizontal","triggerNode","find","item","handlePositionChange","size","offsetWidth","offsetHeight","offset","offsetLeft","offsetTop","useResizeObserver","left","width","transform","top","height","CONTENT_NAME","NavigationMenuContent","contentProps","commonProps","NavigationMenuContentImpl","pointerEvents","ViewportContentMounter","prevMotionAttributeRef","handleClose","document","activeElement","focus","removeEventListener","motionAttribute","values","map","index","indexOf","prevIndex","isSelected","wasSelected","attribute","disableOutsidePointerEvents","onDismiss","Event","dispatchEvent","onFocusOutside","onPointerDownOutside","isTrigger","some","isRootViewport","isMetaKey","altKey","ctrlKey","isTabKey","currentTarget","focusedElement","findIndex","candidate","isMovingBackwards","shiftKey","nextCandidates","slice","onEscapeKeyDown","_event","VIEWPORT_NAME","NavigationMenuViewport","viewportProps","NavigationMenuViewportImpl","viewportImplProps","viewportContentContext","setSize","setContent","viewportWidth","viewportHeight","activeContentValue","handleSizeChange","from","isActive","FOCUS_GROUP_NAME","groupProps","ARROW_KEYS","FOCUS_GROUP_ITEM_NAME","isFocusNavigationKey","includes","candidateNodes","prevItemKey","prevKeys","currentIndex","container","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","type","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","push","currentNode","previouslyFocusedElement","forEach","dataset","tabindex","getAttribute","setAttribute","prevTabIndex","element","onResize","handleResize","rAF","resizeObserver","ResizeObserver","cancelAnimationFrame","requestAnimationFrame","observe","unobserve","handler","pointerType","Root","Sub","List","Item","Trigger","Link","Indicator","Content","Viewport"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-navigation-menu/src/NavigationMenu.tsx"],"sourcesContent":["/// <reference types=\"resize-observer-browser\" />\n\nimport * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { composeRefs, useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { Presence } from '@radix-ui/react-presence';\nimport { useId } from '@radix-ui/react-id';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Orientation = 'vertical' | 'horizontal';\ntype Direction = 'ltr' | 'rtl';\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenu\n * -----------------------------------------------------------------------------------------------*/\n\nconst NAVIGATION_MENU_NAME = 'NavigationMenu';\n\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  NavigationMenuTriggerElement,\n  { value: string }\n>(NAVIGATION_MENU_NAME);\n\nconst [FocusGroupCollection, useFocusGroupCollection, createFocusGroupCollectionScope] =\n  createCollection<FocusGroupItemElement, {}>(NAVIGATION_MENU_NAME);\n\ntype ScopedProps<P> = P & { __scopeNavigationMenu?: Scope };\nconst [createNavigationMenuContext, createNavigationMenuScope] = createContextScope(\n  NAVIGATION_MENU_NAME,\n  [createCollectionScope, createFocusGroupCollectionScope]\n);\n\ntype ContentData = {\n  ref?: React.Ref<ViewportContentMounterElement>;\n} & ViewportContentMounterProps;\n\ntype NavigationMenuContextValue = {\n  isRootMenu: boolean;\n  value: string;\n  previousValue: string;\n  baseId: string;\n  dir: Direction;\n  orientation: Orientation;\n  rootNavigationMenu: NavigationMenuElement | null;\n  indicatorTrack: HTMLDivElement | null;\n  onIndicatorTrackChange(indicatorTrack: HTMLDivElement | null): void;\n  viewport: NavigationMenuViewportElement | null;\n  onViewportChange(viewport: NavigationMenuViewportElement | null): void;\n  onViewportContentChange(contentValue: string, contentData: ContentData): void;\n  onViewportContentRemove(contentValue: string): void;\n  onTriggerEnter(itemValue: string): void;\n  onTriggerLeave(): void;\n  onContentEnter(): void;\n  onContentLeave(): void;\n  onItemSelect(itemValue: string): void;\n  onItemDismiss(): void;\n};\n\nconst [NavigationMenuProviderImpl, useNavigationMenuContext] =\n  createNavigationMenuContext<NavigationMenuContextValue>(NAVIGATION_MENU_NAME);\n\nconst [ViewportContentProvider, useViewportContentContext] = createNavigationMenuContext<{\n  items: Map<string, ContentData>;\n}>(NAVIGATION_MENU_NAME);\n\ntype NavigationMenuElement = React.ElementRef<typeof Primitive.nav>;\ntype PrimitiveNavProps = React.ComponentPropsWithoutRef<typeof Primitive.nav>;\ninterface NavigationMenuProps\n  extends Omit<NavigationMenuProviderProps, keyof NavigationMenuProviderPrivateProps>,\n    PrimitiveNavProps {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (value: string) => void;\n  dir?: Direction;\n  orientation?: Orientation;\n  /**\n   * The duration from when the pointer enters the trigger until the tooltip gets opened.\n   * @defaultValue 200\n   */\n  delayDuration?: number;\n  /**\n   * How much time a user has to enter another trigger without incurring a delay again.\n   * @defaultValue 300\n   */\n  skipDelayDuration?: number;\n}\n\nconst NavigationMenu = React.forwardRef<NavigationMenuElement, NavigationMenuProps>(\n  (props: ScopedProps<NavigationMenuProps>, forwardedRef) => {\n    const {\n      __scopeNavigationMenu,\n      value: valueProp,\n      onValueChange,\n      defaultValue,\n      delayDuration = 200,\n      skipDelayDuration = 300,\n      orientation = 'horizontal',\n      dir,\n      ...NavigationMenuProps\n    } = props;\n    const [navigationMenu, setNavigationMenu] = React.useState<NavigationMenuElement | null>(null);\n    const composedRef = useComposedRefs(forwardedRef, (node) => setNavigationMenu(node));\n    const direction = useDirection(dir);\n    const openTimerRef = React.useRef(0);\n    const closeTimerRef = React.useRef(0);\n    const skipDelayTimerRef = React.useRef(0);\n    const [isOpenDelayed, setIsOpenDelayed] = React.useState(true);\n    const [value = '', setValue] = useControllableState({\n      prop: valueProp,\n      onChange: (value) => {\n        const isOpen = value !== '';\n        const hasSkipDelayDuration = skipDelayDuration > 0;\n\n        if (isOpen) {\n          window.clearTimeout(skipDelayTimerRef.current);\n          if (hasSkipDelayDuration) setIsOpenDelayed(false);\n        } else {\n          window.clearTimeout(skipDelayTimerRef.current);\n          skipDelayTimerRef.current = window.setTimeout(\n            () => setIsOpenDelayed(true),\n            skipDelayDuration\n          );\n        }\n\n        onValueChange?.(value);\n      },\n      defaultProp: defaultValue,\n    });\n\n    const startCloseTimer = React.useCallback(() => {\n      window.clearTimeout(closeTimerRef.current);\n      closeTimerRef.current = window.setTimeout(() => setValue(''), 150);\n    }, [setValue]);\n\n    const handleOpen = React.useCallback(\n      (itemValue: string) => {\n        window.clearTimeout(closeTimerRef.current);\n        setValue(itemValue);\n      },\n      [setValue]\n    );\n\n    const handleDelayedOpen = React.useCallback(\n      (itemValue: string) => {\n        const isOpenItem = value === itemValue;\n        if (isOpenItem) {\n          // If the item is already open (e.g. we're transitioning from the content to the trigger)\n          // then we want to clear the close timer immediately.\n          window.clearTimeout(closeTimerRef.current);\n        } else {\n          openTimerRef.current = window.setTimeout(() => {\n            window.clearTimeout(closeTimerRef.current);\n            setValue(itemValue);\n          }, delayDuration);\n        }\n      },\n      [value, setValue, delayDuration]\n    );\n\n    React.useEffect(() => {\n      return () => {\n        window.clearTimeout(openTimerRef.current);\n        window.clearTimeout(closeTimerRef.current);\n        window.clearTimeout(skipDelayTimerRef.current);\n      };\n    }, []);\n\n    return (\n      <NavigationMenuProvider\n        scope={__scopeNavigationMenu}\n        isRootMenu={true}\n        value={value}\n        dir={direction}\n        orientation={orientation}\n        rootNavigationMenu={navigationMenu}\n        onTriggerEnter={(itemValue) => {\n          window.clearTimeout(openTimerRef.current);\n          if (isOpenDelayed) handleDelayedOpen(itemValue);\n          else handleOpen(itemValue);\n        }}\n        onTriggerLeave={() => {\n          window.clearTimeout(openTimerRef.current);\n          startCloseTimer();\n        }}\n        onContentEnter={() => window.clearTimeout(closeTimerRef.current)}\n        onContentLeave={startCloseTimer}\n        onItemSelect={(itemValue) => {\n          setValue((prevValue) => (prevValue === itemValue ? '' : itemValue));\n        }}\n        onItemDismiss={() => setValue('')}\n      >\n        <Primitive.nav\n          aria-label=\"Main\"\n          data-orientation={orientation}\n          dir={direction}\n          {...NavigationMenuProps}\n          ref={composedRef}\n        />\n      </NavigationMenuProvider>\n    );\n  }\n);\n\nNavigationMenu.displayName = NAVIGATION_MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuSub\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_NAME = 'NavigationMenuSub';\n\ntype NavigationMenuSubElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface NavigationMenuSubProps\n  extends Omit<NavigationMenuProviderProps, keyof NavigationMenuProviderPrivateProps>,\n    PrimitiveDivProps {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?: (value: string) => void;\n  orientation?: Orientation;\n}\n\nconst NavigationMenuSub = React.forwardRef<NavigationMenuSubElement, NavigationMenuSubProps>(\n  (props: ScopedProps<NavigationMenuSubProps>, forwardedRef) => {\n    const {\n      __scopeNavigationMenu,\n      value: valueProp,\n      onValueChange,\n      defaultValue,\n      orientation = 'horizontal',\n      ...subProps\n    } = props;\n    const context = useNavigationMenuContext(SUB_NAME, __scopeNavigationMenu);\n    const [value = '', setValue] = useControllableState({\n      prop: valueProp,\n      onChange: onValueChange,\n      defaultProp: defaultValue,\n    });\n\n    return (\n      <NavigationMenuProvider\n        scope={__scopeNavigationMenu}\n        isRootMenu={false}\n        value={value}\n        dir={context.dir}\n        orientation={orientation}\n        rootNavigationMenu={context.rootNavigationMenu}\n        onTriggerEnter={(itemValue) => setValue(itemValue)}\n        onItemSelect={(itemValue) => setValue(itemValue)}\n        onItemDismiss={() => setValue('')}\n      >\n        <Primitive.div data-orientation={orientation} {...subProps} ref={forwardedRef} />\n      </NavigationMenuProvider>\n    );\n  }\n);\n\nNavigationMenuSub.displayName = SUB_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ninterface NavigationMenuProviderPrivateProps {\n  isRootMenu: boolean;\n  scope: Scope;\n  children: React.ReactNode;\n  orientation: Orientation;\n  dir: Direction;\n  rootNavigationMenu: NavigationMenuElement | null;\n  value: string;\n  onTriggerEnter(itemValue: string): void;\n  onTriggerLeave?(): void;\n  onContentEnter?(): void;\n  onContentLeave?(): void;\n  onItemSelect(itemValue: string): void;\n  onItemDismiss(): void;\n}\n\ninterface NavigationMenuProviderProps extends NavigationMenuProviderPrivateProps {}\n\nconst NavigationMenuProvider: React.FC<NavigationMenuProviderProps> = (\n  props: ScopedProps<NavigationMenuProviderProps>\n) => {\n  const {\n    scope,\n    isRootMenu,\n    rootNavigationMenu,\n    dir,\n    orientation,\n    children,\n    value,\n    onItemSelect,\n    onItemDismiss,\n    onTriggerEnter,\n    onTriggerLeave,\n    onContentEnter,\n    onContentLeave,\n  } = props;\n  const [viewport, setViewport] = React.useState<NavigationMenuViewportElement | null>(null);\n  const [viewportContent, setViewportContent] = React.useState<Map<string, ContentData>>(new Map());\n  const [indicatorTrack, setIndicatorTrack] = React.useState<HTMLDivElement | null>(null);\n\n  return (\n    <NavigationMenuProviderImpl\n      scope={scope}\n      isRootMenu={isRootMenu}\n      rootNavigationMenu={rootNavigationMenu}\n      value={value}\n      previousValue={usePrevious(value)}\n      baseId={useId()}\n      dir={dir}\n      orientation={orientation}\n      viewport={viewport}\n      onViewportChange={setViewport}\n      indicatorTrack={indicatorTrack}\n      onIndicatorTrackChange={setIndicatorTrack}\n      onTriggerEnter={useCallbackRef(onTriggerEnter)}\n      onTriggerLeave={useCallbackRef(onTriggerLeave)}\n      onContentEnter={useCallbackRef(onContentEnter)}\n      onContentLeave={useCallbackRef(onContentLeave)}\n      onItemSelect={useCallbackRef(onItemSelect)}\n      onItemDismiss={useCallbackRef(onItemDismiss)}\n      onViewportContentChange={React.useCallback((contentValue, contentData) => {\n        setViewportContent((prevContent) => {\n          prevContent.set(contentValue, contentData);\n          return new Map(prevContent);\n        });\n      }, [])}\n      onViewportContentRemove={React.useCallback((contentValue) => {\n        setViewportContent((prevContent) => {\n          if (!prevContent.has(contentValue)) return prevContent;\n          prevContent.delete(contentValue);\n          return new Map(prevContent);\n        });\n      }, [])}\n    >\n      <Collection.Provider scope={scope}>\n        <ViewportContentProvider scope={scope} items={viewportContent}>\n          {children}\n        </ViewportContentProvider>\n      </Collection.Provider>\n    </NavigationMenuProviderImpl>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuList\n * -----------------------------------------------------------------------------------------------*/\n\nconst LIST_NAME = 'NavigationMenuList';\n\ntype NavigationMenuListElement = React.ElementRef<typeof Primitive.ul>;\ntype PrimitiveUnorderedListProps = React.ComponentPropsWithoutRef<typeof Primitive.ul>;\ninterface NavigationMenuListProps extends PrimitiveUnorderedListProps {}\n\nconst NavigationMenuList = React.forwardRef<NavigationMenuListElement, NavigationMenuListProps>(\n  (props: ScopedProps<NavigationMenuListProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, ...listProps } = props;\n    const context = useNavigationMenuContext(LIST_NAME, __scopeNavigationMenu);\n\n    const list = (\n      <Primitive.ul data-orientation={context.orientation} {...listProps} ref={forwardedRef} />\n    );\n\n    return (\n      <Primitive.div style={{ position: 'relative' }} ref={context.onIndicatorTrackChange}>\n        <Collection.Slot scope={__scopeNavigationMenu}>\n          {context.isRootMenu ? <FocusGroup asChild>{list}</FocusGroup> : list}\n        </Collection.Slot>\n      </Primitive.div>\n    );\n  }\n);\n\nNavigationMenuList.displayName = LIST_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'NavigationMenuItem';\n\ntype FocusProxyElement = React.ElementRef<typeof VisuallyHiddenPrimitive.Root>;\n\ntype NavigationMenuItemContextValue = {\n  value: string;\n  triggerRef: React.RefObject<NavigationMenuTriggerElement | null>;\n  contentRef: React.RefObject<NavigationMenuContentElement | null>;\n  focusProxyRef: React.RefObject<FocusProxyElement | null>;\n  wasEscapeCloseRef: React.MutableRefObject<boolean>;\n  onEntryKeyDown(): void;\n  onFocusProxyEnter(side: 'start' | 'end'): void;\n  onRootContentClose(): void;\n  onContentFocusOutside(): void;\n};\n\nconst [NavigationMenuItemContextProvider, useNavigationMenuItemContext] =\n  createNavigationMenuContext<NavigationMenuItemContextValue>(ITEM_NAME);\n\ntype NavigationMenuItemElement = React.ElementRef<typeof Primitive.li>;\ntype PrimitiveListItemProps = React.ComponentPropsWithoutRef<typeof Primitive.li>;\ninterface NavigationMenuItemProps extends PrimitiveListItemProps {\n  value?: string;\n}\n\nconst NavigationMenuItem = React.forwardRef<NavigationMenuItemElement, NavigationMenuItemProps>(\n  (props: ScopedProps<NavigationMenuItemProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, value: valueProp, ...itemProps } = props;\n    const autoValue = useId();\n    // We need to provide an initial deterministic value as `useId` will return\n    // empty string on the first render and we don't want to match our internal \"closed\" value.\n    const value = valueProp || autoValue || 'LEGACY_REACT_AUTO_VALUE';\n    const contentRef = React.useRef<NavigationMenuContentElement>(null);\n    const triggerRef = React.useRef<NavigationMenuTriggerElement>(null);\n    const focusProxyRef = React.useRef<FocusProxyElement>(null);\n    const restoreContentTabOrderRef = React.useRef(() => {});\n    const wasEscapeCloseRef = React.useRef(false);\n\n    const handleContentEntry = React.useCallback((side = 'start') => {\n      if (contentRef.current) {\n        restoreContentTabOrderRef.current();\n        const candidates = getTabbableCandidates(contentRef.current);\n        if (candidates.length) focusFirst(side === 'start' ? candidates : candidates.reverse());\n      }\n    }, []);\n\n    const handleContentExit = React.useCallback(() => {\n      if (contentRef.current) {\n        const candidates = getTabbableCandidates(contentRef.current);\n        if (candidates.length) restoreContentTabOrderRef.current = removeFromTabOrder(candidates);\n      }\n    }, []);\n\n    return (\n      <NavigationMenuItemContextProvider\n        scope={__scopeNavigationMenu}\n        value={value}\n        triggerRef={triggerRef}\n        contentRef={contentRef}\n        focusProxyRef={focusProxyRef}\n        wasEscapeCloseRef={wasEscapeCloseRef}\n        onEntryKeyDown={handleContentEntry}\n        onFocusProxyEnter={handleContentEntry}\n        onRootContentClose={handleContentExit}\n        onContentFocusOutside={handleContentExit}\n      >\n        <Primitive.li {...itemProps} ref={forwardedRef} />\n      </NavigationMenuItemContextProvider>\n    );\n  }\n);\n\nNavigationMenuItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'NavigationMenuTrigger';\n\ntype NavigationMenuTriggerElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface NavigationMenuTriggerProps extends PrimitiveButtonProps {}\n\nconst NavigationMenuTrigger = React.forwardRef<\n  NavigationMenuTriggerElement,\n  NavigationMenuTriggerProps\n>((props: ScopedProps<NavigationMenuTriggerProps>, forwardedRef) => {\n  const { __scopeNavigationMenu, disabled, ...triggerProps } = props;\n  const context = useNavigationMenuContext(TRIGGER_NAME, props.__scopeNavigationMenu);\n  const itemContext = useNavigationMenuItemContext(TRIGGER_NAME, props.__scopeNavigationMenu);\n  const ref = React.useRef<NavigationMenuTriggerElement>(null);\n  const composedRefs = useComposedRefs(ref, itemContext.triggerRef, forwardedRef);\n  const triggerId = makeTriggerId(context.baseId, itemContext.value);\n  const contentId = makeContentId(context.baseId, itemContext.value);\n  const hasPointerMoveOpenedRef = React.useRef(false);\n  const wasClickCloseRef = React.useRef(false);\n  const open = itemContext.value === context.value;\n\n  return (\n    <>\n      <Collection.ItemSlot scope={__scopeNavigationMenu} value={itemContext.value}>\n        <FocusGroupItem asChild>\n          <Primitive.button\n            id={triggerId}\n            disabled={disabled}\n            data-disabled={disabled ? '' : undefined}\n            data-state={getOpenState(open)}\n            aria-expanded={open}\n            aria-controls={contentId}\n            {...triggerProps}\n            ref={composedRefs}\n            onPointerEnter={composeEventHandlers(props.onPointerEnter, () => {\n              wasClickCloseRef.current = false;\n              itemContext.wasEscapeCloseRef.current = false;\n            })}\n            onPointerMove={composeEventHandlers(\n              props.onPointerMove,\n              whenMouse(() => {\n                if (\n                  disabled ||\n                  wasClickCloseRef.current ||\n                  itemContext.wasEscapeCloseRef.current ||\n                  hasPointerMoveOpenedRef.current\n                )\n                  return;\n                context.onTriggerEnter(itemContext.value);\n                hasPointerMoveOpenedRef.current = true;\n              })\n            )}\n            onPointerLeave={composeEventHandlers(\n              props.onPointerLeave,\n              whenMouse(() => {\n                if (disabled) return;\n                context.onTriggerLeave();\n                hasPointerMoveOpenedRef.current = false;\n              })\n            )}\n            onClick={composeEventHandlers(props.onClick, () => {\n              context.onItemSelect(itemContext.value);\n              wasClickCloseRef.current = open;\n            })}\n            onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n              const verticalEntryKey = context.dir === 'rtl' ? 'ArrowLeft' : 'ArrowRight';\n              const entryKey = { horizontal: 'ArrowDown', vertical: verticalEntryKey }[\n                context.orientation\n              ];\n              if (open && event.key === entryKey) {\n                itemContext.onEntryKeyDown();\n                // Prevent FocusGroupItem from handling the event\n                event.preventDefault();\n              }\n            })}\n          />\n        </FocusGroupItem>\n      </Collection.ItemSlot>\n\n      {/* Proxy tab order between trigger and content */}\n      {open && (\n        <>\n          <VisuallyHiddenPrimitive.Root\n            aria-hidden\n            tabIndex={0}\n            ref={itemContext.focusProxyRef}\n            onFocus={(event) => {\n              const content = itemContext.contentRef.current;\n              const prevFocusedElement = event.relatedTarget as HTMLElement | null;\n              const wasTriggerFocused = prevFocusedElement === ref.current;\n              const wasFocusFromContent = content?.contains(prevFocusedElement);\n\n              if (wasTriggerFocused || !wasFocusFromContent) {\n                itemContext.onFocusProxyEnter(wasTriggerFocused ? 'start' : 'end');\n              }\n            }}\n          />\n\n          {/* Restructure a11y tree to make content accessible to screen reader when using the viewport */}\n          {context.viewport && <span aria-owns={contentId} />}\n        </>\n      )}\n    </>\n  );\n});\n\nNavigationMenuTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuLink\n * -----------------------------------------------------------------------------------------------*/\n\nconst LINK_NAME = 'NavigationMenuLink';\nconst LINK_SELECT = 'navigationMenu.linkSelect';\n\ntype NavigationMenuLinkElement = React.ElementRef<typeof Primitive.a>;\ntype PrimitiveLinkProps = React.ComponentPropsWithoutRef<typeof Primitive.a>;\ninterface NavigationMenuLinkProps extends Omit<PrimitiveLinkProps, 'onSelect'> {\n  active?: boolean;\n  onSelect?: (event: Event) => void;\n}\n\nconst NavigationMenuLink = React.forwardRef<NavigationMenuLinkElement, NavigationMenuLinkProps>(\n  (props: ScopedProps<NavigationMenuLinkProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, active, onSelect, ...linkProps } = props;\n\n    return (\n      <FocusGroupItem asChild>\n        <Primitive.a\n          data-active={active ? '' : undefined}\n          aria-current={active ? 'page' : undefined}\n          {...linkProps}\n          ref={forwardedRef}\n          onClick={composeEventHandlers(\n            props.onClick,\n            (event) => {\n              const target = event.target as HTMLElement;\n              const linkSelectEvent = new CustomEvent(LINK_SELECT, {\n                bubbles: true,\n                cancelable: true,\n              });\n              target.addEventListener(LINK_SELECT, (event) => onSelect?.(event), { once: true });\n              dispatchDiscreteCustomEvent(target, linkSelectEvent);\n\n              if (!linkSelectEvent.defaultPrevented && !event.metaKey) {\n                const rootContentDismissEvent = new CustomEvent(ROOT_CONTENT_DISMISS, {\n                  bubbles: true,\n                  cancelable: true,\n                });\n                dispatchDiscreteCustomEvent(target, rootContentDismissEvent);\n              }\n            },\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </FocusGroupItem>\n    );\n  }\n);\n\nNavigationMenuLink.displayName = LINK_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst INDICATOR_NAME = 'NavigationMenuIndicator';\n\ntype NavigationMenuIndicatorElement = NavigationMenuIndicatorImplElement;\ninterface NavigationMenuIndicatorProps extends NavigationMenuIndicatorImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst NavigationMenuIndicator = React.forwardRef<\n  NavigationMenuIndicatorElement,\n  NavigationMenuIndicatorProps\n>((props: ScopedProps<NavigationMenuIndicatorProps>, forwardedRef) => {\n  const { forceMount, ...indicatorProps } = props;\n  const context = useNavigationMenuContext(INDICATOR_NAME, props.__scopeNavigationMenu);\n  const isVisible = Boolean(context.value);\n\n  return context.indicatorTrack\n    ? ReactDOM.createPortal(\n        <Presence present={forceMount || isVisible}>\n          <NavigationMenuIndicatorImpl {...indicatorProps} ref={forwardedRef} />\n        </Presence>,\n        context.indicatorTrack\n      )\n    : null;\n});\n\nNavigationMenuIndicator.displayName = INDICATOR_NAME;\n\ntype NavigationMenuIndicatorImplElement = React.ElementRef<typeof Primitive.div>;\ninterface NavigationMenuIndicatorImplProps extends PrimitiveDivProps {}\n\nconst NavigationMenuIndicatorImpl = React.forwardRef<\n  NavigationMenuIndicatorImplElement,\n  NavigationMenuIndicatorImplProps\n>((props: ScopedProps<NavigationMenuIndicatorImplProps>, forwardedRef) => {\n  const { __scopeNavigationMenu, ...indicatorProps } = props;\n  const context = useNavigationMenuContext(INDICATOR_NAME, __scopeNavigationMenu);\n  const getItems = useCollection(__scopeNavigationMenu);\n  const [activeTrigger, setActiveTrigger] = React.useState<NavigationMenuTriggerElement | null>(\n    null\n  );\n  const [position, setPosition] = React.useState<{ size: number; offset: number } | null>(null);\n  const isHorizontal = context.orientation === 'horizontal';\n  const isVisible = Boolean(context.value);\n\n  React.useEffect(() => {\n    const items = getItems();\n    const triggerNode = items.find((item) => item.value === context.value)?.ref.current;\n    if (triggerNode) setActiveTrigger(triggerNode);\n  }, [getItems, context.value]);\n\n  /**\n   * Update position when the indicator or parent track size changes\n   */\n  const handlePositionChange = () => {\n    if (activeTrigger) {\n      setPosition({\n        size: isHorizontal ? activeTrigger.offsetWidth : activeTrigger.offsetHeight,\n        offset: isHorizontal ? activeTrigger.offsetLeft : activeTrigger.offsetTop,\n      });\n    }\n  };\n  useResizeObserver(activeTrigger, handlePositionChange);\n  useResizeObserver(context.indicatorTrack, handlePositionChange);\n\n  // We need to wait for the indicator position to be available before rendering to\n  // snap immediately into position rather than transitioning from initial\n  return position ? (\n    <Primitive.div\n      aria-hidden\n      data-state={isVisible ? 'visible' : 'hidden'}\n      data-orientation={context.orientation}\n      {...indicatorProps}\n      ref={forwardedRef}\n      style={{\n        position: 'absolute',\n        ...(isHorizontal\n          ? {\n              left: 0,\n              width: position.size + 'px',\n              transform: `translateX(${position.offset}px)`,\n            }\n          : {\n              top: 0,\n              height: position.size + 'px',\n              transform: `translateY(${position.offset}px)`,\n            }),\n        ...indicatorProps.style,\n      }}\n    />\n  ) : null;\n});\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'NavigationMenuContent';\n\ntype NavigationMenuContentElement = NavigationMenuContentImplElement;\ninterface NavigationMenuContentProps\n  extends Omit<NavigationMenuContentImplProps, keyof NavigationMenuContentImplPrivateProps> {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst NavigationMenuContent = React.forwardRef<\n  NavigationMenuContentElement,\n  NavigationMenuContentProps\n>((props: ScopedProps<NavigationMenuContentProps>, forwardedRef) => {\n  const { forceMount, ...contentProps } = props;\n  const context = useNavigationMenuContext(CONTENT_NAME, props.__scopeNavigationMenu);\n  const itemContext = useNavigationMenuItemContext(CONTENT_NAME, props.__scopeNavigationMenu);\n  const composedRefs = useComposedRefs(itemContext.contentRef, forwardedRef);\n  const open = itemContext.value === context.value;\n\n  const commonProps = {\n    value: itemContext.value,\n    triggerRef: itemContext.triggerRef,\n    focusProxyRef: itemContext.focusProxyRef,\n    wasEscapeCloseRef: itemContext.wasEscapeCloseRef,\n    onContentFocusOutside: itemContext.onContentFocusOutside,\n    onRootContentClose: itemContext.onRootContentClose,\n    ...contentProps,\n  };\n\n  return !context.viewport ? (\n    <Presence present={forceMount || open}>\n      <NavigationMenuContentImpl\n        data-state={getOpenState(open)}\n        {...commonProps}\n        ref={composedRefs}\n        onPointerEnter={composeEventHandlers(props.onPointerEnter, context.onContentEnter)}\n        onPointerLeave={composeEventHandlers(\n          props.onPointerLeave,\n          whenMouse(context.onContentLeave)\n        )}\n        style={{\n          // Prevent interaction when animating out\n          pointerEvents: !open && context.isRootMenu ? 'none' : undefined,\n          ...commonProps.style,\n        }}\n      />\n    </Presence>\n  ) : (\n    <ViewportContentMounter forceMount={forceMount} {...commonProps} ref={composedRefs} />\n  );\n});\n\nNavigationMenuContent.displayName = CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype ViewportContentMounterElement = NavigationMenuContentImplElement;\ninterface ViewportContentMounterProps extends NavigationMenuContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst ViewportContentMounter = React.forwardRef<\n  ViewportContentMounterElement,\n  ViewportContentMounterProps\n>((props: ScopedProps<ViewportContentMounterProps>, forwardedRef) => {\n  const context = useNavigationMenuContext(CONTENT_NAME, props.__scopeNavigationMenu);\n  const { onViewportContentChange, onViewportContentRemove } = context;\n\n  useLayoutEffect(() => {\n    onViewportContentChange(props.value, {\n      ref: forwardedRef,\n      ...props,\n    });\n  }, [props, forwardedRef, onViewportContentChange]);\n\n  useLayoutEffect(() => {\n    return () => onViewportContentRemove(props.value);\n  }, [props.value, onViewportContentRemove]);\n\n  // Content is proxied into the viewport\n  return null;\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst ROOT_CONTENT_DISMISS = 'navigationMenu.rootContentDismiss';\n\ntype MotionAttribute = 'to-start' | 'to-end' | 'from-start' | 'from-end';\ntype NavigationMenuContentImplElement = React.ElementRef<typeof DismissableLayer>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer>;\n\ninterface NavigationMenuContentImplPrivateProps {\n  value: string;\n  triggerRef: React.RefObject<NavigationMenuTriggerElement | null>;\n  focusProxyRef: React.RefObject<FocusProxyElement | null>;\n  wasEscapeCloseRef: React.MutableRefObject<boolean>;\n  onContentFocusOutside(): void;\n  onRootContentClose(): void;\n}\ninterface NavigationMenuContentImplProps\n  extends Omit<DismissableLayerProps, 'onDismiss' | 'disableOutsidePointerEvents'>,\n    NavigationMenuContentImplPrivateProps {}\n\nconst NavigationMenuContentImpl = React.forwardRef<\n  NavigationMenuContentImplElement,\n  NavigationMenuContentImplProps\n>((props: ScopedProps<NavigationMenuContentImplProps>, forwardedRef) => {\n  const {\n    __scopeNavigationMenu,\n    value,\n    triggerRef,\n    focusProxyRef,\n    wasEscapeCloseRef,\n    onRootContentClose,\n    onContentFocusOutside,\n    ...contentProps\n  } = props;\n  const context = useNavigationMenuContext(CONTENT_NAME, __scopeNavigationMenu);\n  const ref = React.useRef<NavigationMenuContentImplElement>(null);\n  const composedRefs = useComposedRefs(ref, forwardedRef);\n  const triggerId = makeTriggerId(context.baseId, value);\n  const contentId = makeContentId(context.baseId, value);\n  const getItems = useCollection(__scopeNavigationMenu);\n  const prevMotionAttributeRef = React.useRef<MotionAttribute | null>(null);\n\n  const { onItemDismiss } = context;\n\n  React.useEffect(() => {\n    const content = ref.current;\n\n    // Bubble dismiss to the root content node and focus its trigger\n    if (context.isRootMenu && content) {\n      const handleClose = () => {\n        onItemDismiss();\n        onRootContentClose();\n        if (content.contains(document.activeElement)) triggerRef.current?.focus();\n      };\n      content.addEventListener(ROOT_CONTENT_DISMISS, handleClose);\n      return () => content.removeEventListener(ROOT_CONTENT_DISMISS, handleClose);\n    }\n  }, [context.isRootMenu, props.value, triggerRef, onItemDismiss, onRootContentClose]);\n\n  const motionAttribute = React.useMemo(() => {\n    const items = getItems();\n    const values = items.map((item) => item.value);\n    if (context.dir === 'rtl') values.reverse();\n    const index = values.indexOf(context.value);\n    const prevIndex = values.indexOf(context.previousValue);\n    const isSelected = value === context.value;\n    const wasSelected = prevIndex === values.indexOf(value);\n\n    // We only want to update selected and the last selected content\n    // this avoids animations being interrupted outside of that range\n    if (!isSelected && !wasSelected) return prevMotionAttributeRef.current;\n\n    const attribute = (() => {\n      // Don't provide a direction on the initial open\n      if (index !== prevIndex) {\n        // If we're moving to this item from another\n        if (isSelected && prevIndex !== -1) return index > prevIndex ? 'from-end' : 'from-start';\n        // If we're leaving this item for another\n        if (wasSelected && index !== -1) return index > prevIndex ? 'to-start' : 'to-end';\n      }\n      // Otherwise we're entering from closed or leaving the list\n      // entirely and should not animate in any direction\n      return null;\n    })();\n\n    prevMotionAttributeRef.current = attribute;\n    return attribute;\n  }, [context.previousValue, context.value, context.dir, getItems, value]);\n\n  return (\n    <FocusGroup asChild>\n      <DismissableLayer\n        id={contentId}\n        aria-labelledby={triggerId}\n        data-motion={motionAttribute}\n        data-orientation={context.orientation}\n        {...contentProps}\n        ref={composedRefs}\n        disableOutsidePointerEvents={false}\n        onDismiss={() => {\n          const rootContentDismissEvent = new Event(ROOT_CONTENT_DISMISS, {\n            bubbles: true,\n            cancelable: true,\n          });\n          ref.current?.dispatchEvent(rootContentDismissEvent);\n        }}\n        onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n          onContentFocusOutside();\n          const target = event.target as HTMLElement;\n          // Only dismiss content when focus moves outside of the menu\n          if (context.rootNavigationMenu?.contains(target)) event.preventDefault();\n        })}\n        onPointerDownOutside={composeEventHandlers(props.onPointerDownOutside, (event) => {\n          const target = event.target as HTMLElement;\n          const isTrigger = getItems().some((item) => item.ref.current?.contains(target));\n          const isRootViewport = context.isRootMenu && context.viewport?.contains(target);\n          if (isTrigger || isRootViewport || !context.isRootMenu) event.preventDefault();\n        })}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n          const isTabKey = event.key === 'Tab' && !isMetaKey;\n          if (isTabKey) {\n            const candidates = getTabbableCandidates(event.currentTarget);\n            const focusedElement = document.activeElement;\n            const index = candidates.findIndex((candidate) => candidate === focusedElement);\n            const isMovingBackwards = event.shiftKey;\n            const nextCandidates = isMovingBackwards\n              ? candidates.slice(0, index).reverse()\n              : candidates.slice(index + 1, candidates.length);\n\n            if (focusFirst(nextCandidates)) {\n              // prevent browser tab keydown because we've handled focus\n              event.preventDefault();\n            } else {\n              // If we can't focus that means we're at the edges\n              // so focus the proxy and let browser handle\n              // tab/shift+tab keypress on the proxy instead\n              focusProxyRef.current?.focus();\n            }\n          }\n        })}\n        onEscapeKeyDown={composeEventHandlers(props.onEscapeKeyDown, (_event) => {\n          // prevent the dropdown from reopening\n          // after the escape key has been pressed\n          wasEscapeCloseRef.current = true;\n        })}\n      />\n    </FocusGroup>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * NavigationMenuViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'NavigationMenuViewport';\n\ntype NavigationMenuViewportElement = NavigationMenuViewportImplElement;\ninterface NavigationMenuViewportProps\n  extends Omit<NavigationMenuViewportImplProps, 'activeContentValue'> {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst NavigationMenuViewport = React.forwardRef<\n  NavigationMenuViewportElement,\n  NavigationMenuViewportProps\n>((props: ScopedProps<NavigationMenuViewportProps>, forwardedRef) => {\n  const { forceMount, ...viewportProps } = props;\n  const context = useNavigationMenuContext(VIEWPORT_NAME, props.__scopeNavigationMenu);\n  const open = Boolean(context.value);\n\n  return (\n    <Presence present={forceMount || open}>\n      <NavigationMenuViewportImpl {...viewportProps} ref={forwardedRef} />\n    </Presence>\n  );\n});\n\nNavigationMenuViewport.displayName = VIEWPORT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype NavigationMenuViewportImplElement = React.ElementRef<typeof Primitive.div>;\ninterface NavigationMenuViewportImplProps extends PrimitiveDivProps {}\n\nconst NavigationMenuViewportImpl = React.forwardRef<\n  NavigationMenuViewportImplElement,\n  NavigationMenuViewportImplProps\n>((props: ScopedProps<NavigationMenuViewportImplProps>, forwardedRef) => {\n  const { __scopeNavigationMenu, children, ...viewportImplProps } = props;\n  const context = useNavigationMenuContext(VIEWPORT_NAME, __scopeNavigationMenu);\n  const composedRefs = useComposedRefs(forwardedRef, context.onViewportChange);\n  const viewportContentContext = useViewportContentContext(\n    CONTENT_NAME,\n    props.__scopeNavigationMenu\n  );\n  const [size, setSize] = React.useState<{ width: number; height: number } | null>(null);\n  const [content, setContent] = React.useState<NavigationMenuContentElement | null>(null);\n  const viewportWidth = size ? size?.width + 'px' : undefined;\n  const viewportHeight = size ? size?.height + 'px' : undefined;\n  const open = Boolean(context.value);\n  // We persist the last active content value as the viewport may be animating out\n  // and we want the content to remain mounted for the lifecycle of the viewport.\n  const activeContentValue = open ? context.value : context.previousValue;\n\n  /**\n   * Update viewport size to match the active content node.\n   * We prefer offset dimensions over `getBoundingClientRect` as the latter respects CSS transform.\n   * For example, if content animates in from `scale(0.5)` the dimensions would be anything\n   * from `0.5` to `1` of the intended size.\n   */\n  const handleSizeChange = () => {\n    if (content) setSize({ width: content.offsetWidth, height: content.offsetHeight });\n  };\n  useResizeObserver(content, handleSizeChange);\n\n  return (\n    <Primitive.div\n      data-state={getOpenState(open)}\n      data-orientation={context.orientation}\n      {...viewportImplProps}\n      ref={composedRefs}\n      style={{\n        // Prevent interaction when animating out\n        pointerEvents: !open && context.isRootMenu ? 'none' : undefined,\n        ['--radix-navigation-menu-viewport-width' as any]: viewportWidth,\n        ['--radix-navigation-menu-viewport-height' as any]: viewportHeight,\n        ...viewportImplProps.style,\n      }}\n      onPointerEnter={composeEventHandlers(props.onPointerEnter, context.onContentEnter)}\n      onPointerLeave={composeEventHandlers(props.onPointerLeave, whenMouse(context.onContentLeave))}\n    >\n      {Array.from(viewportContentContext.items).map(([value, { ref, forceMount, ...props }]) => {\n        const isActive = activeContentValue === value;\n        return (\n          <Presence key={value} present={forceMount || isActive}>\n            <NavigationMenuContentImpl\n              {...props}\n              ref={composeRefs(ref, (node) => {\n                // We only want to update the stored node when another is available\n                // as we need to smoothly transition between them.\n                if (isActive && node) setContent(node);\n              })}\n            />\n          </Presence>\n        );\n      })}\n    </Primitive.div>\n  );\n});\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_GROUP_NAME = 'FocusGroup';\n\ntype FocusGroupElement = React.ElementRef<typeof Primitive.div>;\ninterface FocusGroupProps extends PrimitiveDivProps {}\n\nconst FocusGroup = React.forwardRef<FocusGroupElement, FocusGroupProps>(\n  (props: ScopedProps<FocusGroupProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, ...groupProps } = props;\n    const context = useNavigationMenuContext(FOCUS_GROUP_NAME, __scopeNavigationMenu);\n\n    return (\n      <FocusGroupCollection.Provider scope={__scopeNavigationMenu}>\n        <FocusGroupCollection.Slot scope={__scopeNavigationMenu}>\n          <Primitive.div dir={context.dir} {...groupProps} ref={forwardedRef} />\n        </FocusGroupCollection.Slot>\n      </FocusGroupCollection.Provider>\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_KEYS = ['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown'];\nconst FOCUS_GROUP_ITEM_NAME = 'FocusGroupItem';\n\ntype FocusGroupItemElement = React.ElementRef<typeof Primitive.button>;\ninterface FocusGroupItemProps extends PrimitiveButtonProps {}\n\nconst FocusGroupItem = React.forwardRef<FocusGroupItemElement, FocusGroupItemProps>(\n  (props: ScopedProps<FocusGroupItemProps>, forwardedRef) => {\n    const { __scopeNavigationMenu, ...groupProps } = props;\n    const getItems = useFocusGroupCollection(__scopeNavigationMenu);\n    const context = useNavigationMenuContext(FOCUS_GROUP_ITEM_NAME, __scopeNavigationMenu);\n\n    return (\n      <FocusGroupCollection.ItemSlot scope={__scopeNavigationMenu}>\n        <Primitive.button\n          {...groupProps}\n          ref={forwardedRef}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            const isFocusNavigationKey = ['Home', 'End', ...ARROW_KEYS].includes(event.key);\n            if (isFocusNavigationKey) {\n              let candidateNodes = getItems().map((item) => item.ref.current!);\n              const prevItemKey = context.dir === 'rtl' ? 'ArrowRight' : 'ArrowLeft';\n              const prevKeys = [prevItemKey, 'ArrowUp', 'End'];\n              if (prevKeys.includes(event.key)) candidateNodes.reverse();\n              if (ARROW_KEYS.includes(event.key)) {\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = candidateNodes.slice(currentIndex + 1);\n              }\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n\n              // Prevent page scroll while navigating\n              event.preventDefault();\n            }\n          })}\n        />\n      </FocusGroupCollection.ItemSlot>\n    );\n  }\n);\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some((candidate) => {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nfunction removeFromTabOrder(candidates: HTMLElement[]) {\n  candidates.forEach((candidate) => {\n    candidate.dataset.tabindex = candidate.getAttribute('tabindex') || '';\n    candidate.setAttribute('tabindex', '-1');\n  });\n  return () => {\n    candidates.forEach((candidate) => {\n      const prevTabIndex = candidate.dataset.tabindex as string;\n      candidate.setAttribute('tabindex', prevTabIndex);\n    });\n  };\n}\n\nfunction useResizeObserver(element: HTMLElement | null, onResize: () => void) {\n  const handleResize = useCallbackRef(onResize);\n  useLayoutEffect(() => {\n    let rAF = 0;\n    if (element) {\n      /**\n       * Resize Observer will throw an often benign error that says `ResizeObserver loop\n       * completed with undelivered notifications`. This means that ResizeObserver was not\n       * able to deliver all observations within a single animation frame, so we use\n       * `requestAnimationFrame` to ensure we don't deliver unnecessary observations.\n       * Further reading: https://github.com/WICG/resize-observer/issues/38\n       */\n      const resizeObserver = new ResizeObserver(() => {\n        cancelAnimationFrame(rAF);\n        rAF = window.requestAnimationFrame(handleResize);\n      });\n      resizeObserver.observe(element);\n      return () => {\n        window.cancelAnimationFrame(rAF);\n        resizeObserver.unobserve(element);\n      };\n    }\n  }, [element, handleResize]);\n}\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction makeTriggerId(baseId: string, value: string) {\n  return `${baseId}-trigger-${value}`;\n}\n\nfunction makeContentId(baseId: string, value: string) {\n  return `${baseId}-content-${value}`;\n}\n\nfunction whenMouse<E>(handler: React.PointerEventHandler<E>): React.PointerEventHandler<E> {\n  return (event) => (event.pointerType === 'mouse' ? handler(event) : undefined);\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = NavigationMenu;\nconst Sub = NavigationMenuSub;\nconst List = NavigationMenuList;\nconst Item = NavigationMenuItem;\nconst Trigger = NavigationMenuTrigger;\nconst Link = NavigationMenuLink;\nconst Indicator = NavigationMenuIndicator;\nconst Content = NavigationMenuContent;\nconst Viewport = NavigationMenuViewport;\n\nexport {\n  createNavigationMenuScope,\n  //\n  NavigationMenu,\n  NavigationMenuSub,\n  NavigationMenuList,\n  NavigationMenuItem,\n  NavigationMenuTrigger,\n  NavigationMenuLink,\n  NavigationMenuIndicator,\n  NavigationMenuContent,\n  NavigationMenuViewport,\n  //\n  Root,\n  Sub,\n  List,\n  Item,\n  Trigger,\n  Link,\n  Indicator,\n  Content,\n  Viewport,\n};\nexport type {\n  NavigationMenuProps,\n  NavigationMenuSubProps,\n  NavigationMenuListProps,\n  NavigationMenuItemProps,\n  NavigationMenuTriggerProps,\n  NavigationMenuLinkProps,\n  NavigationMenuIndicatorProps,\n  NavigationMenuContentProps,\n  NavigationMenuViewportProps,\n};\n"]},"metadata":{},"sourceType":"module"}