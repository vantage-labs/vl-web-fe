{"ast":null,"code":"function buildProjectionTransform(delta, treeScale, latestTransform) {\n  var transform = \"\";\n  /**\n   * The translations we use to calculate are always relative to the viewport coordinate space.\n   * But when we apply scales, we also scale the coordinate space of an element and its children.\n   * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n   * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n   */\n\n  var xTranslate = delta.x.translate / treeScale.x;\n  var yTranslate = delta.y.translate / treeScale.y;\n  var zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;\n\n  if (xTranslate || yTranslate || zTranslate) {\n    transform = \"translate3d(\".concat(xTranslate, \"px, \").concat(yTranslate, \"px, \").concat(zTranslate, \"px) \");\n  }\n  /**\n   * Apply scale correction for the tree transform.\n   * This will apply scale to the screen-orientated axes.\n   */\n\n\n  if (treeScale.x !== 1 || treeScale.y !== 1) {\n    transform += \"scale(\".concat(1 / treeScale.x, \", \").concat(1 / treeScale.y, \") \");\n  }\n\n  if (latestTransform) {\n    var transformPerspective = latestTransform.transformPerspective,\n        rotate = latestTransform.rotate,\n        rotateX = latestTransform.rotateX,\n        rotateY = latestTransform.rotateY,\n        skewX = latestTransform.skewX,\n        skewY = latestTransform.skewY;\n    if (transformPerspective) transform = \"perspective(\".concat(transformPerspective, \"px) \").concat(transform);\n    if (rotate) transform += \"rotate(\".concat(rotate, \"deg) \");\n    if (rotateX) transform += \"rotateX(\".concat(rotateX, \"deg) \");\n    if (rotateY) transform += \"rotateY(\".concat(rotateY, \"deg) \");\n    if (skewX) transform += \"skewX(\".concat(skewX, \"deg) \");\n    if (skewY) transform += \"skewY(\".concat(skewY, \"deg) \");\n  }\n  /**\n   * Apply scale to match the size of the element to the size we want it.\n   * This will apply scale to the element-orientated axes.\n   */\n\n\n  var elementScaleX = delta.x.scale * treeScale.x;\n  var elementScaleY = delta.y.scale * treeScale.y;\n\n  if (elementScaleX !== 1 || elementScaleY !== 1) {\n    transform += \"scale(\".concat(elementScaleX, \", \").concat(elementScaleY, \")\");\n  }\n\n  return transform || \"none\";\n}\n\nexport { buildProjectionTransform };","map":{"version":3,"sources":["/home/bahari/vl-web-fe/node_modules/framer-motion/dist/es/projection/styles/transform.mjs"],"names":["buildProjectionTransform","delta","treeScale","latestTransform","transform","xTranslate","x","translate","yTranslate","y","zTranslate","z","transformPerspective","rotate","rotateX","rotateY","skewX","skewY","elementScaleX","scale","elementScaleY"],"mappings":"AAAA,SAASA,wBAAT,CAAkCC,KAAlC,EAAyCC,SAAzC,EAAoDC,eAApD,EAAqE;AACjE,MAAIC,SAAS,GAAG,EAAhB;AACA;AACJ;AACA;AACA;AACA;AACA;;AACI,MAAMC,UAAU,GAAGJ,KAAK,CAACK,CAAN,CAAQC,SAAR,GAAoBL,SAAS,CAACI,CAAjD;AACA,MAAME,UAAU,GAAGP,KAAK,CAACQ,CAAN,CAAQF,SAAR,GAAoBL,SAAS,CAACO,CAAjD;AACA,MAAMC,UAAU,GAAG,CAACP,eAAe,KAAK,IAApB,IAA4BA,eAAe,KAAK,KAAK,CAArD,GAAyD,KAAK,CAA9D,GAAkEA,eAAe,CAACQ,CAAnF,KAAyF,CAA5G;;AACA,MAAIN,UAAU,IAAIG,UAAd,IAA4BE,UAAhC,EAA4C;AACxCN,IAAAA,SAAS,yBAAkBC,UAAlB,iBAAmCG,UAAnC,iBAAoDE,UAApD,SAAT;AACH;AACD;AACJ;AACA;AACA;;;AACI,MAAIR,SAAS,CAACI,CAAV,KAAgB,CAAhB,IAAqBJ,SAAS,CAACO,CAAV,KAAgB,CAAzC,EAA4C;AACxCL,IAAAA,SAAS,oBAAa,IAAIF,SAAS,CAACI,CAA3B,eAAiC,IAAIJ,SAAS,CAACO,CAA/C,OAAT;AACH;;AACD,MAAIN,eAAJ,EAAqB;AACjB,QAAQS,oBAAR,GAAyET,eAAzE,CAAQS,oBAAR;AAAA,QAA8BC,MAA9B,GAAyEV,eAAzE,CAA8BU,MAA9B;AAAA,QAAsCC,OAAtC,GAAyEX,eAAzE,CAAsCW,OAAtC;AAAA,QAA+CC,OAA/C,GAAyEZ,eAAzE,CAA+CY,OAA/C;AAAA,QAAwDC,KAAxD,GAAyEb,eAAzE,CAAwDa,KAAxD;AAAA,QAA+DC,KAA/D,GAAyEd,eAAzE,CAA+Dc,KAA/D;AACA,QAAIL,oBAAJ,EACIR,SAAS,yBAAkBQ,oBAAlB,iBAA6CR,SAA7C,CAAT;AACJ,QAAIS,MAAJ,EACIT,SAAS,qBAAcS,MAAd,UAAT;AACJ,QAAIC,OAAJ,EACIV,SAAS,sBAAeU,OAAf,UAAT;AACJ,QAAIC,OAAJ,EACIX,SAAS,sBAAeW,OAAf,UAAT;AACJ,QAAIC,KAAJ,EACIZ,SAAS,oBAAaY,KAAb,UAAT;AACJ,QAAIC,KAAJ,EACIb,SAAS,oBAAaa,KAAb,UAAT;AACP;AACD;AACJ;AACA;AACA;;;AACI,MAAMC,aAAa,GAAGjB,KAAK,CAACK,CAAN,CAAQa,KAAR,GAAgBjB,SAAS,CAACI,CAAhD;AACA,MAAMc,aAAa,GAAGnB,KAAK,CAACQ,CAAN,CAAQU,KAAR,GAAgBjB,SAAS,CAACO,CAAhD;;AACA,MAAIS,aAAa,KAAK,CAAlB,IAAuBE,aAAa,KAAK,CAA7C,EAAgD;AAC5ChB,IAAAA,SAAS,oBAAac,aAAb,eAA+BE,aAA/B,MAAT;AACH;;AACD,SAAOhB,SAAS,IAAI,MAApB;AACH;;AAED,SAASJ,wBAAT","sourcesContent":["function buildProjectionTransform(delta, treeScale, latestTransform) {\n    let transform = \"\";\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    const xTranslate = delta.x.translate / treeScale.x;\n    const yTranslate = delta.y.translate / treeScale.y;\n    const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;\n    if (xTranslate || yTranslate || zTranslate) {\n        transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;\n    }\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    if (treeScale.x !== 1 || treeScale.y !== 1) {\n        transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;\n    }\n    if (latestTransform) {\n        const { transformPerspective, rotate, rotateX, rotateY, skewX, skewY } = latestTransform;\n        if (transformPerspective)\n            transform = `perspective(${transformPerspective}px) ${transform}`;\n        if (rotate)\n            transform += `rotate(${rotate}deg) `;\n        if (rotateX)\n            transform += `rotateX(${rotateX}deg) `;\n        if (rotateY)\n            transform += `rotateY(${rotateY}deg) `;\n        if (skewX)\n            transform += `skewX(${skewX}deg) `;\n        if (skewY)\n            transform += `skewY(${skewY}deg) `;\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    const elementScaleX = delta.x.scale * treeScale.x;\n    const elementScaleY = delta.y.scale * treeScale.y;\n    if (elementScaleX !== 1 || elementScaleY !== 1) {\n        transform += `scale(${elementScaleX}, ${elementScaleY})`;\n    }\n    return transform || \"none\";\n}\n\nexport { buildProjectionTransform };\n"]},"metadata":{},"sourceType":"module"}