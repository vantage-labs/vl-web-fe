{"ast":null,"code":"\"use client\"; // packages/react/tooltip/src/Tooltip.tsx\n\nimport * as React from \"react\";\nimport { composeEventHandlers } from \"@radix-ui/primitive\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { createContextScope } from \"@radix-ui/react-context\";\nimport { DismissableLayer } from \"@radix-ui/react-dismissable-layer\";\nimport { useId } from \"@radix-ui/react-id\";\nimport * as PopperPrimitive from \"@radix-ui/react-popper\";\nimport { createPopperScope } from \"@radix-ui/react-popper\";\nimport { Portal as PortalPrimitive } from \"@radix-ui/react-portal\";\nimport { Presence } from \"@radix-ui/react-presence\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { Slottable } from \"@radix-ui/react-slot\";\nimport { useControllableState } from \"@radix-ui/react-use-controllable-state\";\nimport * as VisuallyHiddenPrimitive from \"@radix-ui/react-visually-hidden\";\nimport { jsx, jsxs } from \"react/jsx-runtime\";\nvar [createTooltipContext, createTooltipScope] = createContextScope(\"Tooltip\", [createPopperScope]);\nvar usePopperScope = createPopperScope();\nvar PROVIDER_NAME = \"TooltipProvider\";\nvar DEFAULT_DELAY_DURATION = 700;\nvar TOOLTIP_OPEN = \"tooltip.open\";\nvar [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME);\n\nvar TooltipProvider = props => {\n  const {\n    __scopeTooltip,\n    delayDuration = DEFAULT_DELAY_DURATION,\n    skipDelayDuration = 300,\n    disableHoverableContent = false,\n    children\n  } = props;\n  const [isOpenDelayed, setIsOpenDelayed] = React.useState(true);\n  const isPointerInTransitRef = React.useRef(false);\n  const skipDelayTimerRef = React.useRef(0);\n  React.useEffect(() => {\n    const skipDelayTimer = skipDelayTimerRef.current;\n    return () => window.clearTimeout(skipDelayTimer);\n  }, []);\n  return /* @__PURE__ */jsx(TooltipProviderContextProvider, {\n    scope: __scopeTooltip,\n    isOpenDelayed,\n    delayDuration,\n    onOpen: React.useCallback(() => {\n      window.clearTimeout(skipDelayTimerRef.current);\n      setIsOpenDelayed(false);\n    }, []),\n    onClose: React.useCallback(() => {\n      window.clearTimeout(skipDelayTimerRef.current);\n      skipDelayTimerRef.current = window.setTimeout(() => setIsOpenDelayed(true), skipDelayDuration);\n    }, [skipDelayDuration]),\n    isPointerInTransitRef,\n    onPointerInTransitChange: React.useCallback(inTransit => {\n      isPointerInTransitRef.current = inTransit;\n    }, []),\n    disableHoverableContent,\n    children\n  });\n};\n\nTooltipProvider.displayName = PROVIDER_NAME;\nvar TOOLTIP_NAME = \"Tooltip\";\nvar [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);\n\nvar Tooltip = props => {\n  const {\n    __scopeTooltip,\n    children,\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    disableHoverableContent: disableHoverableContentProp,\n    delayDuration: delayDurationProp\n  } = props;\n  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);\n  const popperScope = usePopperScope(__scopeTooltip);\n  const [trigger, setTrigger] = React.useState(null);\n  const contentId = useId();\n  const openTimerRef = React.useRef(0);\n  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;\n  const delayDuration = delayDurationProp ?? providerContext.delayDuration;\n  const wasOpenDelayedRef = React.useRef(false);\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: open2 => {\n      if (open2) {\n        providerContext.onOpen();\n        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));\n      } else {\n        providerContext.onClose();\n      }\n\n      onOpenChange?.(open2);\n    }\n  });\n  const stateAttribute = React.useMemo(() => {\n    return open ? wasOpenDelayedRef.current ? \"delayed-open\" : \"instant-open\" : \"closed\";\n  }, [open]);\n  const handleOpen = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = 0;\n    wasOpenDelayedRef.current = false;\n    setOpen(true);\n  }, [setOpen]);\n  const handleClose = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = 0;\n    setOpen(false);\n  }, [setOpen]);\n  const handleDelayedOpen = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = window.setTimeout(() => {\n      wasOpenDelayedRef.current = true;\n      setOpen(true);\n      openTimerRef.current = 0;\n    }, delayDuration);\n  }, [delayDuration, setOpen]);\n  React.useEffect(() => {\n    return () => {\n      if (openTimerRef.current) {\n        window.clearTimeout(openTimerRef.current);\n        openTimerRef.current = 0;\n      }\n    };\n  }, []);\n  return /* @__PURE__ */jsx(PopperPrimitive.Root, { ...popperScope,\n    children: /* @__PURE__ */jsx(TooltipContextProvider, {\n      scope: __scopeTooltip,\n      contentId,\n      open,\n      stateAttribute,\n      trigger,\n      onTriggerChange: setTrigger,\n      onTriggerEnter: React.useCallback(() => {\n        if (providerContext.isOpenDelayed) handleDelayedOpen();else handleOpen();\n      }, [providerContext.isOpenDelayed, handleDelayedOpen, handleOpen]),\n      onTriggerLeave: React.useCallback(() => {\n        if (disableHoverableContent) {\n          handleClose();\n        } else {\n          window.clearTimeout(openTimerRef.current);\n          openTimerRef.current = 0;\n        }\n      }, [handleClose, disableHoverableContent]),\n      onOpen: handleOpen,\n      onClose: handleClose,\n      disableHoverableContent,\n      children\n    })\n  });\n};\n\nTooltip.displayName = TOOLTIP_NAME;\nvar TRIGGER_NAME = \"TooltipTrigger\";\nvar TooltipTrigger = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeTooltip,\n    ...triggerProps\n  } = props;\n  const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);\n  const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);\n  const popperScope = usePopperScope(__scopeTooltip);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);\n  const isPointerDownRef = React.useRef(false);\n  const hasPointerMoveOpenedRef = React.useRef(false);\n  const handlePointerUp = React.useCallback(() => isPointerDownRef.current = false, []);\n  React.useEffect(() => {\n    return () => document.removeEventListener(\"pointerup\", handlePointerUp);\n  }, [handlePointerUp]);\n  return /* @__PURE__ */jsx(PopperPrimitive.Anchor, {\n    asChild: true,\n    ...popperScope,\n    children: /* @__PURE__ */jsx(Primitive.button, {\n      \"aria-describedby\": context.open ? context.contentId : void 0,\n      \"data-state\": context.stateAttribute,\n      ...triggerProps,\n      ref: composedRefs,\n      onPointerMove: composeEventHandlers(props.onPointerMove, event => {\n        if (event.pointerType === \"touch\") return;\n\n        if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {\n          context.onTriggerEnter();\n          hasPointerMoveOpenedRef.current = true;\n        }\n      }),\n      onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {\n        context.onTriggerLeave();\n        hasPointerMoveOpenedRef.current = false;\n      }),\n      onPointerDown: composeEventHandlers(props.onPointerDown, () => {\n        isPointerDownRef.current = true;\n        document.addEventListener(\"pointerup\", handlePointerUp, {\n          once: true\n        });\n      }),\n      onFocus: composeEventHandlers(props.onFocus, () => {\n        if (!isPointerDownRef.current) context.onOpen();\n      }),\n      onBlur: composeEventHandlers(props.onBlur, context.onClose),\n      onClick: composeEventHandlers(props.onClick, context.onClose)\n    })\n  });\n});\nTooltipTrigger.displayName = TRIGGER_NAME;\nvar PORTAL_NAME = \"TooltipPortal\";\nvar [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME, {\n  forceMount: void 0\n});\n\nvar TooltipPortal = props => {\n  const {\n    __scopeTooltip,\n    forceMount,\n    children,\n    container\n  } = props;\n  const context = useTooltipContext(PORTAL_NAME, __scopeTooltip);\n  return /* @__PURE__ */jsx(PortalProvider, {\n    scope: __scopeTooltip,\n    forceMount,\n    children: /* @__PURE__ */jsx(Presence, {\n      present: forceMount || context.open,\n      children: /* @__PURE__ */jsx(PortalPrimitive, {\n        asChild: true,\n        container,\n        children\n      })\n    })\n  });\n};\n\nTooltipPortal.displayName = PORTAL_NAME;\nvar CONTENT_NAME = \"TooltipContent\";\nvar TooltipContent = React.forwardRef((props, forwardedRef) => {\n  const portalContext = usePortalContext(CONTENT_NAME, props.__scopeTooltip);\n  const {\n    forceMount = portalContext.forceMount,\n    side = \"top\",\n    ...contentProps\n  } = props;\n  const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n  return /* @__PURE__ */jsx(Presence, {\n    present: forceMount || context.open,\n    children: context.disableHoverableContent ? /* @__PURE__ */jsx(TooltipContentImpl, {\n      side,\n      ...contentProps,\n      ref: forwardedRef\n    }) : /* @__PURE__ */jsx(TooltipContentHoverable, {\n      side,\n      ...contentProps,\n      ref: forwardedRef\n    })\n  });\n});\nvar TooltipContentHoverable = React.forwardRef((props, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n  const providerContext = useTooltipProviderContext(CONTENT_NAME, props.__scopeTooltip);\n  const ref = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const [pointerGraceArea, setPointerGraceArea] = React.useState(null);\n  const {\n    trigger,\n    onClose\n  } = context;\n  const content = ref.current;\n  const {\n    onPointerInTransitChange\n  } = providerContext;\n  const handleRemoveGraceArea = React.useCallback(() => {\n    setPointerGraceArea(null);\n    onPointerInTransitChange(false);\n  }, [onPointerInTransitChange]);\n  const handleCreateGraceArea = React.useCallback((event, hoverTarget) => {\n    const currentTarget = event.currentTarget;\n    const exitPoint = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());\n    const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);\n    const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());\n    const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);\n    setPointerGraceArea(graceArea);\n    onPointerInTransitChange(true);\n  }, [onPointerInTransitChange]);\n  React.useEffect(() => {\n    return () => handleRemoveGraceArea();\n  }, [handleRemoveGraceArea]);\n  React.useEffect(() => {\n    if (trigger && content) {\n      const handleTriggerLeave = event => handleCreateGraceArea(event, content);\n\n      const handleContentLeave = event => handleCreateGraceArea(event, trigger);\n\n      trigger.addEventListener(\"pointerleave\", handleTriggerLeave);\n      content.addEventListener(\"pointerleave\", handleContentLeave);\n      return () => {\n        trigger.removeEventListener(\"pointerleave\", handleTriggerLeave);\n        content.removeEventListener(\"pointerleave\", handleContentLeave);\n      };\n    }\n  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);\n  React.useEffect(() => {\n    if (pointerGraceArea) {\n      const handleTrackPointerGrace = event => {\n        const target = event.target;\n        const pointerPosition = {\n          x: event.clientX,\n          y: event.clientY\n        };\n        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);\n        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);\n\n        if (hasEnteredTarget) {\n          handleRemoveGraceArea();\n        } else if (isPointerOutsideGraceArea) {\n          handleRemoveGraceArea();\n          onClose();\n        }\n      };\n\n      document.addEventListener(\"pointermove\", handleTrackPointerGrace);\n      return () => document.removeEventListener(\"pointermove\", handleTrackPointerGrace);\n    }\n  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);\n  return /* @__PURE__ */jsx(TooltipContentImpl, { ...props,\n    ref: composedRefs\n  });\n});\nvar [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, {\n  isInside: false\n});\nvar TooltipContentImpl = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeTooltip,\n    children,\n    \"aria-label\": ariaLabel,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    ...contentProps\n  } = props;\n  const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);\n  const popperScope = usePopperScope(__scopeTooltip);\n  const {\n    onClose\n  } = context;\n  React.useEffect(() => {\n    document.addEventListener(TOOLTIP_OPEN, onClose);\n    return () => document.removeEventListener(TOOLTIP_OPEN, onClose);\n  }, [onClose]);\n  React.useEffect(() => {\n    if (context.trigger) {\n      const handleScroll = event => {\n        const target = event.target;\n        if (target?.contains(context.trigger)) onClose();\n      };\n\n      window.addEventListener(\"scroll\", handleScroll, {\n        capture: true\n      });\n      return () => window.removeEventListener(\"scroll\", handleScroll, {\n        capture: true\n      });\n    }\n  }, [context.trigger, onClose]);\n  return /* @__PURE__ */jsx(DismissableLayer, {\n    asChild: true,\n    disableOutsidePointerEvents: false,\n    onEscapeKeyDown,\n    onPointerDownOutside,\n    onFocusOutside: event => event.preventDefault(),\n    onDismiss: onClose,\n    children: /* @__PURE__ */jsxs(PopperPrimitive.Content, {\n      \"data-state\": context.stateAttribute,\n      ...popperScope,\n      ...contentProps,\n      ref: forwardedRef,\n      style: { ...contentProps.style,\n        // re-namespace exposed content custom properties\n        ...{\n          \"--radix-tooltip-content-transform-origin\": \"var(--radix-popper-transform-origin)\",\n          \"--radix-tooltip-content-available-width\": \"var(--radix-popper-available-width)\",\n          \"--radix-tooltip-content-available-height\": \"var(--radix-popper-available-height)\",\n          \"--radix-tooltip-trigger-width\": \"var(--radix-popper-anchor-width)\",\n          \"--radix-tooltip-trigger-height\": \"var(--radix-popper-anchor-height)\"\n        }\n      },\n      children: [/* @__PURE__ */jsx(Slottable, {\n        children\n      }), /* @__PURE__ */jsx(VisuallyHiddenContentContextProvider, {\n        scope: __scopeTooltip,\n        isInside: true,\n        children: /* @__PURE__ */jsx(VisuallyHiddenPrimitive.Root, {\n          id: context.contentId,\n          role: \"tooltip\",\n          children: ariaLabel || children\n        })\n      })]\n    })\n  });\n});\nTooltipContent.displayName = CONTENT_NAME;\nvar ARROW_NAME = \"TooltipArrow\";\nvar TooltipArrow = React.forwardRef((props, forwardedRef) => {\n  const {\n    __scopeTooltip,\n    ...arrowProps\n  } = props;\n  const popperScope = usePopperScope(__scopeTooltip);\n  const visuallyHiddenContentContext = useVisuallyHiddenContentContext(ARROW_NAME, __scopeTooltip);\n  return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */jsx(PopperPrimitive.Arrow, { ...popperScope,\n    ...arrowProps,\n    ref: forwardedRef\n  });\n});\nTooltipArrow.displayName = ARROW_NAME;\n\nfunction getExitSideFromRect(point, rect) {\n  const top = Math.abs(rect.top - point.y);\n  const bottom = Math.abs(rect.bottom - point.y);\n  const right = Math.abs(rect.right - point.x);\n  const left = Math.abs(rect.left - point.x);\n\n  switch (Math.min(top, bottom, right, left)) {\n    case left:\n      return \"left\";\n\n    case right:\n      return \"right\";\n\n    case top:\n      return \"top\";\n\n    case bottom:\n      return \"bottom\";\n\n    default:\n      throw new Error(\"unreachable\");\n  }\n}\n\nfunction getPaddedExitPoints(exitPoint, exitSide) {\n  let padding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n  const paddedExitPoints = [];\n\n  switch (exitSide) {\n    case \"top\":\n      paddedExitPoints.push({\n        x: exitPoint.x - padding,\n        y: exitPoint.y + padding\n      }, {\n        x: exitPoint.x + padding,\n        y: exitPoint.y + padding\n      });\n      break;\n\n    case \"bottom\":\n      paddedExitPoints.push({\n        x: exitPoint.x - padding,\n        y: exitPoint.y - padding\n      }, {\n        x: exitPoint.x + padding,\n        y: exitPoint.y - padding\n      });\n      break;\n\n    case \"left\":\n      paddedExitPoints.push({\n        x: exitPoint.x + padding,\n        y: exitPoint.y - padding\n      }, {\n        x: exitPoint.x + padding,\n        y: exitPoint.y + padding\n      });\n      break;\n\n    case \"right\":\n      paddedExitPoints.push({\n        x: exitPoint.x - padding,\n        y: exitPoint.y - padding\n      }, {\n        x: exitPoint.x - padding,\n        y: exitPoint.y + padding\n      });\n      break;\n  }\n\n  return paddedExitPoints;\n}\n\nfunction getPointsFromRect(rect) {\n  const {\n    top,\n    right,\n    bottom,\n    left\n  } = rect;\n  return [{\n    x: left,\n    y: top\n  }, {\n    x: right,\n    y: top\n  }, {\n    x: right,\n    y: bottom\n  }, {\n    x: left,\n    y: bottom\n  }];\n}\n\nfunction isPointInPolygon(point, polygon) {\n  const {\n    x,\n    y\n  } = point;\n  let inside = false;\n\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n    const intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\nfunction getHull(points) {\n  const newPoints = points.slice();\n  newPoints.sort((a, b) => {\n    if (a.x < b.x) return -1;else if (a.x > b.x) return 1;else if (a.y < b.y) return -1;else if (a.y > b.y) return 1;else return 0;\n  });\n  return getHullPresorted(newPoints);\n}\n\nfunction getHullPresorted(points) {\n  if (points.length <= 1) return points.slice();\n  const upperHull = [];\n\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n\n    while (upperHull.length >= 2) {\n      const q = upperHull[upperHull.length - 1];\n      const r = upperHull[upperHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) upperHull.pop();else break;\n    }\n\n    upperHull.push(p);\n  }\n\n  upperHull.pop();\n  const lowerHull = [];\n\n  for (let i = points.length - 1; i >= 0; i--) {\n    const p = points[i];\n\n    while (lowerHull.length >= 2) {\n      const q = lowerHull[lowerHull.length - 1];\n      const r = lowerHull[lowerHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) lowerHull.pop();else break;\n    }\n\n    lowerHull.push(p);\n  }\n\n  lowerHull.pop();\n\n  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {\n    return upperHull;\n  } else {\n    return upperHull.concat(lowerHull);\n  }\n}\n\nvar Provider = TooltipProvider;\nvar Root3 = Tooltip;\nvar Trigger = TooltipTrigger;\nvar Portal = TooltipPortal;\nvar Content2 = TooltipContent;\nvar Arrow2 = TooltipArrow;\nexport { Arrow2 as Arrow, Content2 as Content, Portal, Provider, Root3 as Root, Tooltip, TooltipArrow, TooltipContent, TooltipPortal, TooltipProvider, TooltipTrigger, Trigger, createTooltipScope };","map":{"version":3,"mappings":";;AAAA,YAAYA,KAAZ,MAAuB,OAAvB;AACA,SAASC,oBAAT,QAAqC,qBAArC;AACA,SAASC,eAAT,QAAgC,8BAAhC;AACA,SAASC,kBAAT,QAAmC,yBAAnC;AACA,SAASC,gBAAT,QAAiC,mCAAjC;AACA,SAASC,KAAT,QAAsB,oBAAtB;AACA,YAAYC,eAAZ,MAAiC,wBAAjC;AACA,SAASC,iBAAT,QAAkC,wBAAlC;AACA,SAASC,UAAUC,eAAnB,QAA0C,wBAA1C;AACA,SAASC,QAAT,QAAyB,0BAAzB;AACA,SAASC,SAAT,QAA0B,2BAA1B;AACA,SAASC,SAAT,QAA0B,sBAA1B;AACA,SAASC,oBAAT,QAAqC,wCAArC;AACA,YAAYC,uBAAZ,MAAyC,iCAAzC;AAsEI,cA0cIC,IA1cJ;AAjEJ,IAAM,CAACC,oBAAD,EAAuBC,kBAAvB,IAA6Cd,mBAAmB,SAAnB,EAA8B,CAC/EI,iBAD+E,CAA9B,CAAnD;AAGA,IAAMW,iBAAiBX,mBAAvB;AAMA,IAAMY,gBAAgB,iBAAtB;AACA,IAAMC,yBAAyB,GAA/B;AACA,IAAMC,eAAe,cAArB;AAYA,IAAM,CAACC,8BAAD,EAAiCC,yBAAjC,IACJP,qBAAkDG,aAAlD,CADF;;AAsBA,IAAMK,kBACJC,KADsD,IAEnD;AACH,QAAM;AACJC,kBADI;AAEJC,oBAAgBP,sBAFZ;AAGJQ,wBAAoB,GAHhB;AAIJC,8BAA0B,KAJtB;AAKJC;AALI,MAMFL,KANJ;AAOA,QAAM,CAACM,aAAD,EAAgBC,gBAAhB,IAA0ChC,eAAS,IAAT,CAAhD;AACA,QAAMiC,wBAA8BjC,aAAO,KAAP,CAApC;AACA,QAAMkC,oBAA0BlC,aAAO,CAAP,CAAhC;AAEMA,kBAAU,MAAM;AACpB,UAAMmC,iBAAiBD,kBAAkBE,OAAzC;AACA,WAAO,MAAMC,OAAOC,YAAP,CAAoBH,cAApB,CAAb;AACF,GAHM,EAGH,EAHG;AAKN,SACE,mBAACb,8BAAD,EAAC;AACCiB,WAAOb,cADR;AAECK,iBAFD;AAGCJ,iBAHD;AAICa,YAAcxC,kBAAY,MAAM;AAC9BqC,aAAOC,YAAP,CAAoBJ,kBAAkBE,OAAtC;AACAJ,uBAAiB,KAAjB;AACF,KAHc,EAGX,EAHW,CAJf;AAQCS,aAAezC,kBAAY,MAAM;AAC/BqC,aAAOC,YAAP,CAAoBJ,kBAAkBE,OAAtC;AACAF,wBAAkBE,OAAlB,GAA4BC,OAAOK,UAAP,CAC1B,MAAMV,iBAAiB,IAAjB,CADoB,EAE1BJ,iBAF0B,CAA5B;AAIF,KANe,EAMZ,CAACA,iBAAD,CANY,CARhB;AAeCK,yBAfD;AAgBCU,8BAAgC3C,kBAAa4C,SAAD,IAAwB;AAClEX,4BAAsBG,OAAtB,GAAgCQ,SAAhC;AACF,KAFgC,EAE7B,EAF6B,CAhBjC;AAmBCf,2BAnBD;AAqBEC;AArBF,GAAD,CADF;AAyBF,CA5CA;;AA8CAN,gBAAgBqB,WAAhB,GAA8B1B,aAA9B;AAMA,IAAM2B,eAAe,SAArB;AAeA,IAAM,CAACC,sBAAD,EAAyBC,iBAAzB,IACJhC,qBAA0C8B,YAA1C,CADF;;AAqBA,IAAMG,UAAmCxB,KAAD,IAAsC;AAC5E,QAAM;AACJC,kBADI;AAEJI,YAFI;AAGJoB,UAAMC,QAHF;AAIJC,kBAAc,KAJV;AAKJC,gBALI;AAMJxB,6BAAyByB,2BANrB;AAOJ3B,mBAAe4B;AAPX,MAQF9B,KARJ;AASA,QAAM+B,kBAAkBjC,0BAA0BuB,YAA1B,EAAwCrB,MAAMC,cAA9C,CAAxB;AACA,QAAM+B,cAAcvC,eAAeQ,cAAf,CAApB;AACA,QAAM,CAACgC,OAAD,EAAUC,UAAV,IAA8B3D,eAAmC,IAAnC,CAApC;AACA,QAAM4D,YAAYvD,OAAlB;AACA,QAAMwD,eAAqB7D,aAAO,CAAP,CAA3B;AACA,QAAM6B,0BACJyB,+BAA+BE,gBAAgB3B,uBADjD;AAEA,QAAMF,gBAAgB4B,qBAAqBC,gBAAgB7B,aAA3D;AACA,QAAMmC,oBAA0B9D,aAAO,KAAP,CAAhC;AACA,QAAM,CAACkD,OAAO,KAAR,EAAea,OAAf,IAA0BlD,qBAAqB;AACnDmD,UAAMb,QAD6C;AAEnDc,iBAAab,WAFsC;AAGnDc,cAAWhB,KAAD,IAAU;AAClB,UAAIA,KAAJ,EAAU;AACRM,wBAAgBhB,MAAhB;AAIA2B,iBAASC,aAAT,CAAuB,IAAIC,WAAJ,CAAgBhD,YAAhB,CAAvB;AACF,OANA,MAMO;AACLmC,wBAAgBf,OAAhB;AACF;;AACAY,qBAAeH,KAAf;AACF;AAdmD,GAArB,CAAhC;AAgBA,QAAMoB,iBAAuBtE,cAAQ,MAAM;AACzC,WAAOkD,OAAQY,kBAAkB1B,OAAlB,GAA4B,cAA5B,GAA6C,cAArD,GAAuE,QAA9E;AACF,GAF6B,EAE1B,CAACc,IAAD,CAF0B,CAA7B;AAIA,QAAMqB,aAAmBvE,kBAAY,MAAM;AACzCqC,WAAOC,YAAP,CAAoBuB,aAAazB,OAAjC;AACAyB,iBAAazB,OAAb,GAAuB,CAAvB;AACA0B,sBAAkB1B,OAAlB,GAA4B,KAA5B;AACA2B,YAAQ,IAAR;AACF,GALyB,EAKtB,CAACA,OAAD,CALsB,CAAzB;AAOA,QAAMS,cAAoBxE,kBAAY,MAAM;AAC1CqC,WAAOC,YAAP,CAAoBuB,aAAazB,OAAjC;AACAyB,iBAAazB,OAAb,GAAuB,CAAvB;AACA2B,YAAQ,KAAR;AACF,GAJ0B,EAIvB,CAACA,OAAD,CAJuB,CAA1B;AAMA,QAAMU,oBAA0BzE,kBAAY,MAAM;AAChDqC,WAAOC,YAAP,CAAoBuB,aAAazB,OAAjC;AACAyB,iBAAazB,OAAb,GAAuBC,OAAOK,UAAP,CAAkB,MAAM;AAC7CoB,wBAAkB1B,OAAlB,GAA4B,IAA5B;AACA2B,cAAQ,IAAR;AACAF,mBAAazB,OAAb,GAAuB,CAAvB;AACF,KAJuB,EAIpBT,aAJoB,CAAvB;AAKF,GAPgC,EAO7B,CAACA,aAAD,EAAgBoC,OAAhB,CAP6B,CAAhC;AASM/D,kBAAU,MAAM;AACpB,WAAO,MAAM;AACX,UAAI6D,aAAazB,OAAjB,EAA0B;AACxBC,eAAOC,YAAP,CAAoBuB,aAAazB,OAAjC;AACAyB,qBAAazB,OAAb,GAAuB,CAAvB;AACF;AACF,KALA;AAMF,GAPM,EAOH,EAPG;AASN,SACE,mBAAiB9B,oBAAjB,EAAC,EAAsB,GAAGmD,WAAzB;AACC3B,iCAACiB,sBAAD,EAAC;AACCR,aAAOb,cADR;AAECkC,eAFD;AAGCV,UAHD;AAICoB,oBAJD;AAKCZ,aALD;AAMCgB,uBAAiBf,UANlB;AAOCgB,sBAAsB3E,kBAAY,MAAM;AACtC,YAAIwD,gBAAgBzB,aAApB,EAAmC0C,oBAAnC,KACKF;AACP,OAHsB,EAGnB,CAACf,gBAAgBzB,aAAjB,EAAgC0C,iBAAhC,EAAmDF,UAAnD,CAHmB,CAPvB;AAWCK,sBAAsB5E,kBAAY,MAAM;AACtC,YAAI6B,uBAAJ,EAA6B;AAC3B2C;AACF,SAFA,MAEO;AAELnC,iBAAOC,YAAP,CAAoBuB,aAAazB,OAAjC;AACAyB,uBAAazB,OAAb,GAAuB,CAAvB;AACF;AACF,OARsB,EAQnB,CAACoC,WAAD,EAAc3C,uBAAd,CARmB,CAXvB;AAoBCW,cAAQ+B,UApBT;AAqBC9B,eAAS+B,WArBV;AAsBC3C,6BAtBD;AAwBEC;AAxBF,KAAD;AADD,GAAD,CADF;AA8BF,CApGA;;AAsGAmB,QAAQJ,WAAR,GAAsBC,YAAtB;AAMA,IAAM+B,eAAe,gBAArB;AAMA,IAAMC,iBAAuB9E,iBAC3B,CAACyB,KAAD,EAA0CsD,YAA1C,KAA2D;AACzD,QAAM;AAAErD,kBAAF;AAAkB,OAAGsD;AAArB,MAAsCvD,KAA5C;AACA,QAAMwD,UAAUjC,kBAAkB6B,YAAlB,EAAgCnD,cAAhC,CAAhB;AACA,QAAM8B,kBAAkBjC,0BAA0BsD,YAA1B,EAAwCnD,cAAxC,CAAxB;AACA,QAAM+B,cAAcvC,eAAeQ,cAAf,CAApB;AACA,QAAMwD,MAAYlF,aAA8B,IAA9B,CAAlB;AACA,QAAMmF,eAAejF,gBAAgB6E,YAAhB,EAA8BG,GAA9B,EAAmCD,QAAQP,eAA3C,CAArB;AACA,QAAMU,mBAAyBpF,aAAO,KAAP,CAA/B;AACA,QAAMqF,0BAAgCrF,aAAO,KAAP,CAAtC;AACA,QAAMsF,kBAAwBtF,kBAAY,MAAOoF,iBAAiBhD,OAAjB,GAA2B,KAA9C,EAAsD,EAAtD,CAA9B;AAEMpC,kBAAU,MAAM;AACpB,WAAO,MAAMmE,SAASoB,mBAAT,CAA6B,WAA7B,EAA0CD,eAA1C,CAAb;AACF,GAFM,EAEH,CAACA,eAAD,CAFG;AAIN,SACE,mBAAiBhF,sBAAjB,EAAC;AAAuBkF,aAAO,IAA9B;AAAgC,OAAG/B,WAAnC;AACC3B,iCAACnB,UAAU8E,MAAX,EAAC;AAGC,0BAAkBR,QAAQ/B,IAAR,GAAe+B,QAAQrB,SAAvB,GAAmC,MAHtD;AAIC,oBAAYqB,QAAQX,cAJrB;AAKE,SAAGU,YALL;AAMCE,WAAKC,YANN;AAOCO,qBAAezF,qBAAqBwB,MAAMiE,aAA3B,EAA2CC,KAAD,IAAW;AAClE,YAAIA,MAAMC,WAAN,KAAsB,OAA1B,EAAmC;;AACnC,YACE,CAACP,wBAAwBjD,OAAzB,IACA,CAACoB,gBAAgBvB,qBAAhB,CAAsCG,OAFzC,EAGE;AACA6C,kBAAQN,cAAR;AACAU,kCAAwBjD,OAAxB,GAAkC,IAAlC;AACF;AACD,OATc,CAPhB;AAiBCyD,sBAAgB5F,qBAAqBwB,MAAMoE,cAA3B,EAA2C,MAAM;AAC/DZ,gBAAQL,cAAR;AACAS,gCAAwBjD,OAAxB,GAAkC,KAAlC;AACD,OAHe,CAjBjB;AAqBC0D,qBAAe7F,qBAAqBwB,MAAMqE,aAA3B,EAA0C,MAAM;AAC7DV,yBAAiBhD,OAAjB,GAA2B,IAA3B;AACA+B,iBAAS4B,gBAAT,CAA0B,WAA1B,EAAuCT,eAAvC,EAAwD;AAAEU,gBAAM;AAAR,SAAxD;AACD,OAHc,CArBhB;AAyBCC,eAAShG,qBAAqBwB,MAAMwE,OAA3B,EAAoC,MAAM;AACjD,YAAI,CAACb,iBAAiBhD,OAAtB,EAA+B6C,QAAQzC,MAAR;AAChC,OAFQ,CAzBV;AA4BC0D,cAAQjG,qBAAqBwB,MAAMyE,MAA3B,EAAmCjB,QAAQxC,OAA3C,CA5BT;AA6BC0D,eAASlG,qBAAqBwB,MAAM0E,OAA3B,EAAoClB,QAAQxC,OAA5C;AA7BV,KAAD;AADD,GAAD,CADF;AAmCF,CAnD2B,CAA7B;AAsDAqC,eAAejC,WAAf,GAA6BgC,YAA7B;AAMA,IAAMuB,cAAc,eAApB;AAGA,IAAM,CAACC,cAAD,EAAiBC,gBAAjB,IAAqCtF,qBAAyCoF,WAAzC,EAAsD;AAC/FG,cAAY;AADmF,CAAtD,CAA3C;;AAkBA,IAAMC,gBAA+C/E,KAAD,IAA4C;AAC9F,QAAM;AAAEC,kBAAF;AAAkB6E,cAAlB;AAA8BzE,YAA9B;AAAwC2E;AAAxC,MAAsDhF,KAA5D;AACA,QAAMwD,UAAUjC,kBAAkBoD,WAAlB,EAA+B1E,cAA/B,CAAhB;AACA,SACE,mBAAC2E,cAAD,EAAC;AAAe9D,WAAOb,cAAtB;AAAsC6E,cAAtC;AACCzE,iCAACpB,QAAD,EAAC;AAASgG,eAASH,cAActB,QAAQ/B,IAAxC;AACCpB,mCAACrB,eAAD,EAAC;AAAgB+E,iBAAO,IAAvB;AAAwBiB,iBAAxB;AACE3E;AADF,OAAD;AADD,KAAD;AADD,GAAD,CADF;AASF,CAZA;;AAcA0E,cAAc3D,WAAd,GAA4BuD,WAA5B;AAMA,IAAMO,eAAe,gBAArB;AAWA,IAAMC,iBAAuB5G,iBAC3B,CAACyB,KAAD,EAA0CsD,YAA1C,KAA2D;AACzD,QAAM8B,gBAAgBP,iBAAiBK,YAAjB,EAA+BlF,MAAMC,cAArC,CAAtB;AACA,QAAM;AAAE6E,iBAAaM,cAAcN,UAA7B;AAAyCO,WAAO,KAAhD;AAAuD,OAAGC;AAA1D,MAA2EtF,KAAjF;AACA,QAAMwD,UAAUjC,kBAAkB2D,YAAlB,EAAgClF,MAAMC,cAAtC,CAAhB;AAEA,SACE,mBAAChB,QAAD,EAAC;AAASgG,aAASH,cAActB,QAAQ/B,IAAxC;AACEpB,sBAAQD,uBAAR,GACC,mBAACmF,kBAAD,EAAC;AAAmBF,UAAnB;AAAgC,SAAGC,YAAnC;AAAiD7B,WAAKH;AAAtD,KAAD,CADD,GAGC,mBAACkC,uBAAD,EAAC;AAAwBH,UAAxB;AAAqC,SAAGC,YAAxC;AAAsD7B,WAAKH;AAA3D,KAAD;AAJH,GAAD,CADF;AASF,CAf2B,CAA7B;AAwBA,IAAMkC,0BAAgCjH,iBAGpC,CAACyB,KAAD,EAAmDsD,YAAnD,KAAoE;AACpE,QAAME,UAAUjC,kBAAkB2D,YAAlB,EAAgClF,MAAMC,cAAtC,CAAhB;AACA,QAAM8B,kBAAkBjC,0BAA0BoF,YAA1B,EAAwClF,MAAMC,cAA9C,CAAxB;AACA,QAAMwD,MAAYlF,aAAuC,IAAvC,CAAlB;AACA,QAAMmF,eAAejF,gBAAgB6E,YAAhB,EAA8BG,GAA9B,CAArB;AACA,QAAM,CAACgC,gBAAD,EAAmBC,mBAAnB,IAAgDnH,eAAyB,IAAzB,CAAtD;AAEA,QAAM;AAAE0D,WAAF;AAAWjB;AAAX,MAAuBwC,OAA7B;AACA,QAAMmC,UAAUlC,IAAI9C,OAApB;AAEA,QAAM;AAAEO;AAAF,MAA+Ba,eAArC;AAEA,QAAM6D,wBAA8BrH,kBAAY,MAAM;AACpDmH,wBAAoB,IAApB;AACAxE,6BAAyB,KAAzB;AACF,GAHoC,EAGjC,CAACA,wBAAD,CAHiC,CAApC;AAKA,QAAM2E,wBAA8BtH,kBAClC,CAAC2F,KAAD,EAAsB4B,WAAtB,KAAmD;AACjD,UAAMC,gBAAgB7B,MAAM6B,aAA5B;AACA,UAAMC,YAAY;AAAEC,SAAG/B,MAAMgC,OAAX;AAAoBC,SAAGjC,MAAMkC;AAA7B,KAAlB;AACA,UAAMC,WAAWC,oBAAoBN,SAApB,EAA+BD,cAAcQ,qBAAd,EAA/B,CAAjB;AACA,UAAMC,mBAAmBC,oBAAoBT,SAApB,EAA+BK,QAA/B,CAAzB;AACA,UAAMK,oBAAoBC,kBAAkBb,YAAYS,qBAAZ,EAAlB,CAA1B;AACA,UAAMK,YAAYC,QAAQ,CAAC,GAAGL,gBAAJ,EAAsB,GAAGE,iBAAzB,CAAR,CAAlB;AACAhB,wBAAoBkB,SAApB;AACA1F,6BAAyB,IAAzB;AACF,GAVkC,EAWlC,CAACA,wBAAD,CAXkC,CAApC;AAcM3C,kBAAU,MAAM;AACpB,WAAO,MAAMqH,uBAAb;AACF,GAFM,EAEH,CAACA,qBAAD,CAFG;AAIArH,kBAAU,MAAM;AACpB,QAAI0D,WAAW0D,OAAf,EAAwB;AACtB,YAAMmB,qBAAsB5C,KAAD,IAAyB2B,sBAAsB3B,KAAtB,EAA6ByB,OAA7B,CAApD;;AACA,YAAMoB,qBAAsB7C,KAAD,IAAyB2B,sBAAsB3B,KAAtB,EAA6BjC,OAA7B,CAApD;;AAEAA,cAAQqC,gBAAR,CAAyB,cAAzB,EAAyCwC,kBAAzC;AACAnB,cAAQrB,gBAAR,CAAyB,cAAzB,EAAyCyC,kBAAzC;AACA,aAAO,MAAM;AACX9E,gBAAQ6B,mBAAR,CAA4B,cAA5B,EAA4CgD,kBAA5C;AACAnB,gBAAQ7B,mBAAR,CAA4B,cAA5B,EAA4CiD,kBAA5C;AACF,OAHA;AAIF;AACF,GAZM,EAYH,CAAC9E,OAAD,EAAU0D,OAAV,EAAmBE,qBAAnB,EAA0CD,qBAA1C,CAZG;AAcArH,kBAAU,MAAM;AACpB,QAAIkH,gBAAJ,EAAsB;AACpB,YAAMuB,0BAA2B9C,KAAD,IAAyB;AACvD,cAAM+C,SAAS/C,MAAM+C,MAArB;AACA,cAAMC,kBAAkB;AAAEjB,aAAG/B,MAAMgC,OAAX;AAAoBC,aAAGjC,MAAMkC;AAA7B,SAAxB;AACA,cAAMe,mBAAmBlF,SAASmF,QAAT,CAAkBH,MAAlB,KAA6BtB,SAASyB,QAAT,CAAkBH,MAAlB,CAAtD;AACA,cAAMI,4BAA4B,CAACC,iBAAiBJ,eAAjB,EAAkCzB,gBAAlC,CAAnC;;AAEA,YAAI0B,gBAAJ,EAAsB;AACpBvB;AACF,SAFA,MAEA,IAAWyB,yBAAX,EAAsC;AACpCzB;AACA5E;AACF;AACF,OAZA;;AAaA0B,eAAS4B,gBAAT,CAA0B,aAA1B,EAAyC0C,uBAAzC;AACA,aAAO,MAAMtE,SAASoB,mBAAT,CAA6B,aAA7B,EAA4CkD,uBAA5C,CAAb;AACF;AACF,GAlBM,EAkBH,CAAC/E,OAAD,EAAU0D,OAAV,EAAmBF,gBAAnB,EAAqCzE,OAArC,EAA8C4E,qBAA9C,CAlBG;AAoBN,SAAO,mBAACL,kBAAD,EAAC,EAAoB,GAAGvF,KAAvB;AAA8ByD,SAAKC;AAAnC,GAAD,CAAP;AACD,CAzEqC,CAAtC;AA2EA,IAAM,CAAC6D,oCAAD,EAAuCC,+BAAvC,IACJjI,qBAAqB8B,YAArB,EAAmC;AAAEoG,YAAU;AAAZ,CAAnC,CADF;AAwBA,IAAMlC,qBAA2BhH,iBAC/B,CAACyB,KAAD,EAA8CsD,YAA9C,KAA+D;AAC7D,QAAM;AACJrD,kBADI;AAEJI,YAFI;AAGJ,kBAAcqH,SAHV;AAIJC,mBAJI;AAKJC,wBALI;AAMJ,OAAGtC;AANC,MAOFtF,KAPJ;AAQA,QAAMwD,UAAUjC,kBAAkB2D,YAAlB,EAAgCjF,cAAhC,CAAhB;AACA,QAAM+B,cAAcvC,eAAeQ,cAAf,CAApB;AACA,QAAM;AAAEe;AAAF,MAAcwC,OAApB;AAGMjF,kBAAU,MAAM;AACpBmE,aAAS4B,gBAAT,CAA0B1E,YAA1B,EAAwCoB,OAAxC;AACA,WAAO,MAAM0B,SAASoB,mBAAT,CAA6BlE,YAA7B,EAA2CoB,OAA3C,CAAb;AACF,GAHM,EAGH,CAACA,OAAD,CAHG;AAMAzC,kBAAU,MAAM;AACpB,QAAIiF,QAAQvB,OAAZ,EAAqB;AACnB,YAAM4F,eAAgB3D,KAAD,IAAkB;AACrC,cAAM+C,SAAS/C,MAAM+C,MAArB;AACA,YAAIA,QAAQG,QAAR,CAAiB5D,QAAQvB,OAAzB,CAAJ,EAAuCjB;AACzC,OAHA;;AAIAJ,aAAO0D,gBAAP,CAAwB,QAAxB,EAAkCuD,YAAlC,EAAgD;AAAEC,iBAAS;AAAX,OAAhD;AACA,aAAO,MAAMlH,OAAOkD,mBAAP,CAA2B,QAA3B,EAAqC+D,YAArC,EAAmD;AAAEC,iBAAS;AAAX,OAAnD,CAAb;AACF;AACF,GATM,EASH,CAACtE,QAAQvB,OAAT,EAAkBjB,OAAlB,CATG;AAWN,SACE,mBAACrC,gBAAD,EAAC;AACCoF,aAAO,IADR;AAECgE,iCAA6B,KAF9B;AAGCJ,mBAHD;AAICC,wBAJD;AAKCI,oBAAiB9D,KAAD,IAAWA,MAAM+D,cAAN,EAL5B;AAMCC,eAAWlH,OANZ;AAQCX,kCAAiBxB,uBAAjB,EAAC;AACC,oBAAY2E,QAAQX,cADrB;AAEE,SAAGb,WAFL;AAGE,SAAGsD,YAHL;AAIC7B,WAAKH,YAJN;AAKC6E,aAAO,EACL,GAAG7C,aAAa6C,KADX;AACW;AAEhB,WAAG;AACD,sDAA4C,sCAD3C;AAED,qDAA2C,qCAF1C;AAGD,sDAA4C,sCAH3C;AAID,2CAAiC,kCAJhC;AAKD,4CAAkC;AALjC;AAHE,OALR;AAiBC9H,oCAAClB,SAAD,EAAC;AAAWkB;AAAX,OAAD,GACA,mBAACkH,oCAAD,EAAC;AAAqCzG,eAAOb,cAA5C;AAA4DwH,kBAAU,IAAtE;AACCpH,qCAAyBhB,4BAAzB,EAAC;AAA6B+I,cAAI5E,QAAQrB,SAAzC;AAAoDkG,gBAAK,SAAzD;AACEhI,iCAAaA;AADf,SAAD;AADD,OAAD,CADA;AAjBD,KAAD;AARD,GAAD,CADF;AAmCF,CAnE+B,CAAjC;AAsEA8E,eAAe/D,WAAf,GAA6B8D,YAA7B;AAMA,IAAMoD,aAAa,cAAnB;AAMA,IAAMC,eAAqBhK,iBACzB,CAACyB,KAAD,EAAwCsD,YAAxC,KAAyD;AACvD,QAAM;AAAErD,kBAAF;AAAkB,OAAGuI;AAArB,MAAoCxI,KAA1C;AACA,QAAMgC,cAAcvC,eAAeQ,cAAf,CAApB;AACA,QAAMwI,+BAA+BjB,gCACnCc,UADmC,EAEnCrI,cAFmC,CAArC;AAMA,SAAOwI,6BAA6BhB,QAA7B,GAAwC,IAAxC,GACL,mBAAiB5I,qBAAjB,EAAC,EAAuB,GAAGmD,WAA1B;AAAwC,OAAGwG,UAA3C;AAAuD/E,SAAKH;AAA5D,GAAD,CADF;AAGF,CAbyB,CAA3B;AAgBAiF,aAAanH,WAAb,GAA2BkH,UAA3B;;AAMA,SAAShC,mBAAT,CAA6BoC,KAA7B,EAA2CC,IAA3C,EAAgE;AAC9D,QAAMC,MAAMC,KAAKC,GAAL,CAASH,KAAKC,GAAL,GAAWF,MAAMvC,CAA1B,CAAZ;AACA,QAAM4C,SAASF,KAAKC,GAAL,CAASH,KAAKI,MAAL,GAAcL,MAAMvC,CAA7B,CAAf;AACA,QAAM6C,QAAQH,KAAKC,GAAL,CAASH,KAAKK,KAAL,GAAaN,MAAMzC,CAA5B,CAAd;AACA,QAAMgD,OAAOJ,KAAKC,GAAL,CAASH,KAAKM,IAAL,GAAYP,MAAMzC,CAA3B,CAAb;;AAEA,UAAQ4C,KAAKK,GAAL,CAASN,GAAT,EAAcG,MAAd,EAAsBC,KAAtB,EAA6BC,IAA7B,CAAR;AACE,SAAKA,IAAL;AACE,aAAO,MAAP;;AACF,SAAKD,KAAL;AACE,aAAO,OAAP;;AACF,SAAKJ,GAAL;AACE,aAAO,KAAP;;AACF,SAAKG,MAAL;AACE,aAAO,QAAP;;AACF;AACE,YAAM,IAAII,KAAJ,CAAU,aAAV,CAAN;AAVJ;AAYF;;AAEA,SAAS1C,mBAAT,CAA6BT,SAA7B,EAA+CK,QAA/C,EAA4E;AAAA,MAAb+C,OAAa,uEAAH,CAAG;AAC1E,QAAM5C,mBAA4B,EAAlC;;AACA,UAAQH,QAAR;AACE,SAAK,KAAL;AACEG,uBAAiB6C,IAAjB,CACE;AAAEpD,WAAGD,UAAUC,CAAV,GAAcmD,OAAnB;AAA4BjD,WAAGH,UAAUG,CAAV,GAAciD;AAA7C,OADF,EAEE;AAAEnD,WAAGD,UAAUC,CAAV,GAAcmD,OAAnB;AAA4BjD,WAAGH,UAAUG,CAAV,GAAciD;AAA7C,OAFF;AAIA;;AACF,SAAK,QAAL;AACE5C,uBAAiB6C,IAAjB,CACE;AAAEpD,WAAGD,UAAUC,CAAV,GAAcmD,OAAnB;AAA4BjD,WAAGH,UAAUG,CAAV,GAAciD;AAA7C,OADF,EAEE;AAAEnD,WAAGD,UAAUC,CAAV,GAAcmD,OAAnB;AAA4BjD,WAAGH,UAAUG,CAAV,GAAciD;AAA7C,OAFF;AAIA;;AACF,SAAK,MAAL;AACE5C,uBAAiB6C,IAAjB,CACE;AAAEpD,WAAGD,UAAUC,CAAV,GAAcmD,OAAnB;AAA4BjD,WAAGH,UAAUG,CAAV,GAAciD;AAA7C,OADF,EAEE;AAAEnD,WAAGD,UAAUC,CAAV,GAAcmD,OAAnB;AAA4BjD,WAAGH,UAAUG,CAAV,GAAciD;AAA7C,OAFF;AAIA;;AACF,SAAK,OAAL;AACE5C,uBAAiB6C,IAAjB,CACE;AAAEpD,WAAGD,UAAUC,CAAV,GAAcmD,OAAnB;AAA4BjD,WAAGH,UAAUG,CAAV,GAAciD;AAA7C,OADF,EAEE;AAAEnD,WAAGD,UAAUC,CAAV,GAAcmD,OAAnB;AAA4BjD,WAAGH,UAAUG,CAAV,GAAciD;AAA7C,OAFF;AAIA;AAxBJ;;AA0BA,SAAO5C,gBAAP;AACF;;AAEA,SAASG,iBAAT,CAA2BgC,IAA3B,EAA0C;AACxC,QAAM;AAAEC,OAAF;AAAOI,SAAP;AAAcD,UAAd;AAAsBE;AAAtB,MAA+BN,IAArC;AACA,SAAO,CACL;AAAE1C,OAAGgD,IAAL;AAAW9C,OAAGyC;AAAd,GADK,EAEL;AAAE3C,OAAG+C,KAAL;AAAY7C,OAAGyC;AAAf,GAFK,EAGL;AAAE3C,OAAG+C,KAAL;AAAY7C,OAAG4C;AAAf,GAHK,EAIL;AAAE9C,OAAGgD,IAAL;AAAW9C,OAAG4C;AAAd,GAJK,CAAP;AAMF;;AAIA,SAASzB,gBAAT,CAA0BoB,KAA1B,EAAwCY,OAAxC,EAA0D;AACxD,QAAM;AAAErD,KAAF;AAAKE;AAAL,MAAWuC,KAAjB;AACA,MAAIa,SAAS,KAAb;;AACA,WAASC,IAAI,CAAb,EAAgBC,IAAIH,QAAQI,MAAR,GAAiB,CAArC,EAAwCF,IAAIF,QAAQI,MAApD,EAA4DD,IAAID,GAAhE,EAAqE;AACnE,UAAMG,KAAKL,QAAQE,CAAR,EAAWvD,CAAtB;AACA,UAAM2D,KAAKN,QAAQE,CAAR,EAAWrD,CAAtB;AACA,UAAM0D,KAAKP,QAAQG,CAAR,EAAWxD,CAAtB;AACA,UAAM6D,KAAKR,QAAQG,CAAR,EAAWtD,CAAtB;AAGA,UAAM4D,YAAcH,KAAKzD,CAAL,KAAa2D,KAAK3D,CAAlB,IAA0BF,KAAK4D,KAAKF,EAAV,KAAiBxD,IAAIyD,EAArB,KAA4BE,KAAKF,EAAjC,IAAuCD,EAArF;AACA,QAAII,SAAJ,EAAeR,SAAS,CAACA,MAAV;AACjB;;AAEA,SAAOA,MAAP;AACF;;AAIA,SAAS1C,OAAT,CAAkCmD,MAAlC,EAAwE;AACtE,QAAMC,YAAsBD,OAAOE,KAAP,EAA5B;AACAD,YAAUE,IAAV,CAAe,CAACC,CAAD,EAAWC,CAAX,KAAwB;AACrC,QAAID,EAAEnE,CAAF,GAAMoE,EAAEpE,CAAZ,EAAe,OAAO,EAAP,CAAf,KAAsB,IACbmE,EAAEnE,CAAF,GAAMoE,EAAEpE,CADK,EACF,OAAO,CAAP,CADE,KACK,IAClBmE,EAAEjE,CAAF,GAAMkE,EAAElE,CADU,EACP,OAAO,EAAP,CADO,KACA,IAClBiE,EAAEjE,CAAF,GAAMkE,EAAElE,CADU,EACP,OAAO,CAAP,CADO,KAEtB,OAAO,CAAP;AACN,GAND;AAOA,SAAOmE,iBAAiBL,SAAjB,CAAP;AACF;;AAGA,SAASK,gBAAT,CAA2CN,MAA3C,EAAiF;AAC/E,MAAIA,OAAON,MAAP,IAAiB,CAArB,EAAwB,OAAOM,OAAOE,KAAP,EAAP;AAExB,QAAMK,YAAsB,EAA5B;;AACA,WAASf,IAAI,CAAb,EAAgBA,IAAIQ,OAAON,MAA3B,EAAmCF,GAAnC,EAAwC;AACtC,UAAMgB,IAAIR,OAAOR,CAAP,CAAV;;AACA,WAAOe,UAAUb,MAAV,IAAoB,CAA3B,EAA8B;AAC5B,YAAMe,IAAIF,UAAUA,UAAUb,MAAV,GAAmB,CAA7B,CAAV;AACA,YAAMgB,IAAIH,UAAUA,UAAUb,MAAV,GAAmB,CAA7B,CAAV;AACA,WAAKe,EAAExE,CAAF,GAAMyE,EAAEzE,CAAb,KAAmBuE,EAAErE,CAAF,GAAMuE,EAAEvE,CAA3B,KAA2B,CAAOsE,EAAEtE,CAAF,GAAMuE,EAAEvE,CAAf,KAAqBqE,EAAEvE,CAAF,GAAMyE,EAAEzE,CAA7B,CAA3B,EAA4DsE,UAAUI,GAAV,GAA5D,KACK;AACP;;AACAJ,cAAUlB,IAAV,CAAemB,CAAf;AACF;;AACAD,YAAUI,GAAV;AAEA,QAAMC,YAAsB,EAA5B;;AACA,WAASpB,IAAIQ,OAAON,MAAP,GAAgB,CAA7B,EAAgCF,KAAK,CAArC,EAAwCA,GAAxC,EAA6C;AAC3C,UAAMgB,IAAIR,OAAOR,CAAP,CAAV;;AACA,WAAOoB,UAAUlB,MAAV,IAAoB,CAA3B,EAA8B;AAC5B,YAAMe,IAAIG,UAAUA,UAAUlB,MAAV,GAAmB,CAA7B,CAAV;AACA,YAAMgB,IAAIE,UAAUA,UAAUlB,MAAV,GAAmB,CAA7B,CAAV;AACA,WAAKe,EAAExE,CAAF,GAAMyE,EAAEzE,CAAb,KAAmBuE,EAAErE,CAAF,GAAMuE,EAAEvE,CAA3B,KAA2B,CAAOsE,EAAEtE,CAAF,GAAMuE,EAAEvE,CAAf,KAAqBqE,EAAEvE,CAAF,GAAMyE,EAAEzE,CAA7B,CAA3B,EAA4D2E,UAAUD,GAAV,GAA5D,KACK;AACP;;AACAC,cAAUvB,IAAV,CAAemB,CAAf;AACF;;AACAI,YAAUD,GAAV;;AAEA,MACEJ,UAAUb,MAAV,KAAqB,CAArB,IACAkB,UAAUlB,MAAV,KAAqB,CADrB,IAEAa,UAAU,CAAV,EAAatE,CAAb,KAAmB2E,UAAU,CAAV,EAAa3E,CAFhC,IAGAsE,UAAU,CAAV,EAAapE,CAAb,KAAmByE,UAAU,CAAV,EAAazE,CAJlC,EAKE;AACA,WAAOoE,SAAP;AACF,GAPA,MAOO;AACL,WAAOA,UAAUM,MAAV,CAAiBD,SAAjB,CAAP;AACF;AACF;;AAEA,IAAME,WAAW/K,eAAjB;AACA,IAAMgL,QAAOvJ,OAAb;AACA,IAAMwJ,UAAU3H,cAAhB;AACA,IAAMtE,SAASgG,aAAf;AACA,IAAMkG,WAAU9F,cAAhB;AACA,IAAM+F,SAAQ3C,YAAd","names":["React","composeEventHandlers","useComposedRefs","createContextScope","DismissableLayer","useId","PopperPrimitive","createPopperScope","Portal","PortalPrimitive","Presence","Primitive","Slottable","useControllableState","VisuallyHiddenPrimitive","jsxs","createTooltipContext","createTooltipScope","usePopperScope","PROVIDER_NAME","DEFAULT_DELAY_DURATION","TOOLTIP_OPEN","TooltipProviderContextProvider","useTooltipProviderContext","TooltipProvider","props","__scopeTooltip","delayDuration","skipDelayDuration","disableHoverableContent","children","isOpenDelayed","setIsOpenDelayed","isPointerInTransitRef","skipDelayTimerRef","skipDelayTimer","current","window","clearTimeout","scope","onOpen","onClose","setTimeout","onPointerInTransitChange","inTransit","displayName","TOOLTIP_NAME","TooltipContextProvider","useTooltipContext","Tooltip","open","openProp","defaultOpen","onOpenChange","disableHoverableContentProp","delayDurationProp","providerContext","popperScope","trigger","setTrigger","contentId","openTimerRef","wasOpenDelayedRef","setOpen","prop","defaultProp","onChange","document","dispatchEvent","CustomEvent","stateAttribute","handleOpen","handleClose","handleDelayedOpen","onTriggerChange","onTriggerEnter","onTriggerLeave","TRIGGER_NAME","TooltipTrigger","forwardedRef","triggerProps","context","ref","composedRefs","isPointerDownRef","hasPointerMoveOpenedRef","handlePointerUp","removeEventListener","asChild","button","onPointerMove","event","pointerType","onPointerLeave","onPointerDown","addEventListener","once","onFocus","onBlur","onClick","PORTAL_NAME","PortalProvider","usePortalContext","forceMount","TooltipPortal","container","present","CONTENT_NAME","TooltipContent","portalContext","side","contentProps","TooltipContentImpl","TooltipContentHoverable","pointerGraceArea","setPointerGraceArea","content","handleRemoveGraceArea","handleCreateGraceArea","hoverTarget","currentTarget","exitPoint","x","clientX","y","clientY","exitSide","getExitSideFromRect","getBoundingClientRect","paddedExitPoints","getPaddedExitPoints","hoverTargetPoints","getPointsFromRect","graceArea","getHull","handleTriggerLeave","handleContentLeave","handleTrackPointerGrace","target","pointerPosition","hasEnteredTarget","contains","isPointerOutsideGraceArea","isPointInPolygon","VisuallyHiddenContentContextProvider","useVisuallyHiddenContentContext","isInside","ariaLabel","onEscapeKeyDown","onPointerDownOutside","handleScroll","capture","disableOutsidePointerEvents","onFocusOutside","preventDefault","onDismiss","style","id","role","ARROW_NAME","TooltipArrow","arrowProps","visuallyHiddenContentContext","point","rect","top","Math","abs","bottom","right","left","min","Error","padding","push","polygon","inside","i","j","length","xi","yi","xj","yj","intersect","points","newPoints","slice","sort","a","b","getHullPresorted","upperHull","p","q","r","pop","lowerHull","concat","Provider","Root","Trigger","Content","Arrow"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-tooltip/src/Tooltip.tsx"],"sourcesContent":["import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { useId } from '@radix-ui/react-id';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { Slottable } from '@radix-ui/react-slot';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport * as VisuallyHiddenPrimitive from '@radix-ui/react-visually-hidden';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype ScopedProps<P = {}> = P & { __scopeTooltip?: Scope };\nconst [createTooltipContext, createTooltipScope] = createContextScope('Tooltip', [\n  createPopperScope,\n]);\nconst usePopperScope = createPopperScope();\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipProvider\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROVIDER_NAME = 'TooltipProvider';\nconst DEFAULT_DELAY_DURATION = 700;\nconst TOOLTIP_OPEN = 'tooltip.open';\n\ntype TooltipProviderContextValue = {\n  isOpenDelayed: boolean;\n  delayDuration: number;\n  onOpen(): void;\n  onClose(): void;\n  onPointerInTransitChange(inTransit: boolean): void;\n  isPointerInTransitRef: React.MutableRefObject<boolean>;\n  disableHoverableContent: boolean;\n};\n\nconst [TooltipProviderContextProvider, useTooltipProviderContext] =\n  createTooltipContext<TooltipProviderContextValue>(PROVIDER_NAME);\n\ninterface TooltipProviderProps {\n  children: React.ReactNode;\n  /**\n   * The duration from when the pointer enters the trigger until the tooltip gets opened.\n   * @defaultValue 700\n   */\n  delayDuration?: number;\n  /**\n   * How much time a user has to enter another trigger without incurring a delay again.\n   * @defaultValue 300\n   */\n  skipDelayDuration?: number;\n  /**\n   * When `true`, trying to hover the content will result in the tooltip closing as the pointer leaves the trigger.\n   * @defaultValue false\n   */\n  disableHoverableContent?: boolean;\n}\n\nconst TooltipProvider: React.FC<TooltipProviderProps> = (\n  props: ScopedProps<TooltipProviderProps>\n) => {\n  const {\n    __scopeTooltip,\n    delayDuration = DEFAULT_DELAY_DURATION,\n    skipDelayDuration = 300,\n    disableHoverableContent = false,\n    children,\n  } = props;\n  const [isOpenDelayed, setIsOpenDelayed] = React.useState(true);\n  const isPointerInTransitRef = React.useRef(false);\n  const skipDelayTimerRef = React.useRef(0);\n\n  React.useEffect(() => {\n    const skipDelayTimer = skipDelayTimerRef.current;\n    return () => window.clearTimeout(skipDelayTimer);\n  }, []);\n\n  return (\n    <TooltipProviderContextProvider\n      scope={__scopeTooltip}\n      isOpenDelayed={isOpenDelayed}\n      delayDuration={delayDuration}\n      onOpen={React.useCallback(() => {\n        window.clearTimeout(skipDelayTimerRef.current);\n        setIsOpenDelayed(false);\n      }, [])}\n      onClose={React.useCallback(() => {\n        window.clearTimeout(skipDelayTimerRef.current);\n        skipDelayTimerRef.current = window.setTimeout(\n          () => setIsOpenDelayed(true),\n          skipDelayDuration\n        );\n      }, [skipDelayDuration])}\n      isPointerInTransitRef={isPointerInTransitRef}\n      onPointerInTransitChange={React.useCallback((inTransit: boolean) => {\n        isPointerInTransitRef.current = inTransit;\n      }, [])}\n      disableHoverableContent={disableHoverableContent}\n    >\n      {children}\n    </TooltipProviderContextProvider>\n  );\n};\n\nTooltipProvider.displayName = PROVIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Tooltip\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOOLTIP_NAME = 'Tooltip';\n\ntype TooltipContextValue = {\n  contentId: string;\n  open: boolean;\n  stateAttribute: 'closed' | 'delayed-open' | 'instant-open';\n  trigger: TooltipTriggerElement | null;\n  onTriggerChange(trigger: TooltipTriggerElement | null): void;\n  onTriggerEnter(): void;\n  onTriggerLeave(): void;\n  onOpen(): void;\n  onClose(): void;\n  disableHoverableContent: boolean;\n};\n\nconst [TooltipContextProvider, useTooltipContext] =\n  createTooltipContext<TooltipContextValue>(TOOLTIP_NAME);\n\ninterface TooltipProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?: (open: boolean) => void;\n  /**\n   * The duration from when the pointer enters the trigger until the tooltip gets opened. This will\n   * override the prop with the same name passed to Provider.\n   * @defaultValue 700\n   */\n  delayDuration?: number;\n  /**\n   * When `true`, trying to hover the content will result in the tooltip closing as the pointer leaves the trigger.\n   * @defaultValue false\n   */\n  disableHoverableContent?: boolean;\n}\n\nconst Tooltip: React.FC<TooltipProps> = (props: ScopedProps<TooltipProps>) => {\n  const {\n    __scopeTooltip,\n    children,\n    open: openProp,\n    defaultOpen = false,\n    onOpenChange,\n    disableHoverableContent: disableHoverableContentProp,\n    delayDuration: delayDurationProp,\n  } = props;\n  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);\n  const popperScope = usePopperScope(__scopeTooltip);\n  const [trigger, setTrigger] = React.useState<HTMLButtonElement | null>(null);\n  const contentId = useId();\n  const openTimerRef = React.useRef(0);\n  const disableHoverableContent =\n    disableHoverableContentProp ?? providerContext.disableHoverableContent;\n  const delayDuration = delayDurationProp ?? providerContext.delayDuration;\n  const wasOpenDelayedRef = React.useRef(false);\n  const [open = false, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen,\n    onChange: (open) => {\n      if (open) {\n        providerContext.onOpen();\n\n        // as `onChange` is called within a lifecycle method we\n        // avoid dispatching via `dispatchDiscreteCustomEvent`.\n        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));\n      } else {\n        providerContext.onClose();\n      }\n      onOpenChange?.(open);\n    },\n  });\n  const stateAttribute = React.useMemo(() => {\n    return open ? (wasOpenDelayedRef.current ? 'delayed-open' : 'instant-open') : 'closed';\n  }, [open]);\n\n  const handleOpen = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = 0;\n    wasOpenDelayedRef.current = false;\n    setOpen(true);\n  }, [setOpen]);\n\n  const handleClose = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = 0;\n    setOpen(false);\n  }, [setOpen]);\n\n  const handleDelayedOpen = React.useCallback(() => {\n    window.clearTimeout(openTimerRef.current);\n    openTimerRef.current = window.setTimeout(() => {\n      wasOpenDelayedRef.current = true;\n      setOpen(true);\n      openTimerRef.current = 0;\n    }, delayDuration);\n  }, [delayDuration, setOpen]);\n\n  React.useEffect(() => {\n    return () => {\n      if (openTimerRef.current) {\n        window.clearTimeout(openTimerRef.current);\n        openTimerRef.current = 0;\n      }\n    };\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <TooltipContextProvider\n        scope={__scopeTooltip}\n        contentId={contentId}\n        open={open}\n        stateAttribute={stateAttribute}\n        trigger={trigger}\n        onTriggerChange={setTrigger}\n        onTriggerEnter={React.useCallback(() => {\n          if (providerContext.isOpenDelayed) handleDelayedOpen();\n          else handleOpen();\n        }, [providerContext.isOpenDelayed, handleDelayedOpen, handleOpen])}\n        onTriggerLeave={React.useCallback(() => {\n          if (disableHoverableContent) {\n            handleClose();\n          } else {\n            // Clear the timer in case the pointer leaves the trigger before the tooltip is opened.\n            window.clearTimeout(openTimerRef.current);\n            openTimerRef.current = 0;\n          }\n        }, [handleClose, disableHoverableContent])}\n        onOpen={handleOpen}\n        onClose={handleClose}\n        disableHoverableContent={disableHoverableContent}\n      >\n        {children}\n      </TooltipContextProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nTooltip.displayName = TOOLTIP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'TooltipTrigger';\n\ntype TooltipTriggerElement = React.ElementRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface TooltipTriggerProps extends PrimitiveButtonProps {}\n\nconst TooltipTrigger = React.forwardRef<TooltipTriggerElement, TooltipTriggerProps>(\n  (props: ScopedProps<TooltipTriggerProps>, forwardedRef) => {\n    const { __scopeTooltip, ...triggerProps } = props;\n    const context = useTooltipContext(TRIGGER_NAME, __scopeTooltip);\n    const providerContext = useTooltipProviderContext(TRIGGER_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const ref = React.useRef<TooltipTriggerElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);\n    const isPointerDownRef = React.useRef(false);\n    const hasPointerMoveOpenedRef = React.useRef(false);\n    const handlePointerUp = React.useCallback(() => (isPointerDownRef.current = false), []);\n\n    React.useEffect(() => {\n      return () => document.removeEventListener('pointerup', handlePointerUp);\n    }, [handlePointerUp]);\n\n    return (\n      <PopperPrimitive.Anchor asChild {...popperScope}>\n        <Primitive.button\n          // We purposefully avoid adding `type=button` here because tooltip triggers are also\n          // commonly anchors and the anchor `type` attribute signifies MIME type.\n          aria-describedby={context.open ? context.contentId : undefined}\n          data-state={context.stateAttribute}\n          {...triggerProps}\n          ref={composedRefs}\n          onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n            if (event.pointerType === 'touch') return;\n            if (\n              !hasPointerMoveOpenedRef.current &&\n              !providerContext.isPointerInTransitRef.current\n            ) {\n              context.onTriggerEnter();\n              hasPointerMoveOpenedRef.current = true;\n            }\n          })}\n          onPointerLeave={composeEventHandlers(props.onPointerLeave, () => {\n            context.onTriggerLeave();\n            hasPointerMoveOpenedRef.current = false;\n          })}\n          onPointerDown={composeEventHandlers(props.onPointerDown, () => {\n            isPointerDownRef.current = true;\n            document.addEventListener('pointerup', handlePointerUp, { once: true });\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => {\n            if (!isPointerDownRef.current) context.onOpen();\n          })}\n          onBlur={composeEventHandlers(props.onBlur, context.onClose)}\n          onClick={composeEventHandlers(props.onClick, context.onClose)}\n        />\n      </PopperPrimitive.Anchor>\n    );\n  }\n);\n\nTooltipTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'TooltipPortal';\n\ntype PortalContextValue = { forceMount?: true };\nconst [PortalProvider, usePortalContext] = createTooltipContext<PortalContextValue>(PORTAL_NAME, {\n  forceMount: undefined,\n});\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface TooltipPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst TooltipPortal: React.FC<TooltipPortalProps> = (props: ScopedProps<TooltipPortalProps>) => {\n  const { __scopeTooltip, forceMount, children, container } = props;\n  const context = useTooltipContext(PORTAL_NAME, __scopeTooltip);\n  return (\n    <PortalProvider scope={__scopeTooltip} forceMount={forceMount}>\n      <Presence present={forceMount || context.open}>\n        <PortalPrimitive asChild container={container}>\n          {children}\n        </PortalPrimitive>\n      </Presence>\n    </PortalProvider>\n  );\n};\n\nTooltipPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'TooltipContent';\n\ntype TooltipContentElement = TooltipContentImplElement;\ninterface TooltipContentProps extends TooltipContentImplProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst TooltipContent = React.forwardRef<TooltipContentElement, TooltipContentProps>(\n  (props: ScopedProps<TooltipContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeTooltip);\n    const { forceMount = portalContext.forceMount, side = 'top', ...contentProps } = props;\n    const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n\n    return (\n      <Presence present={forceMount || context.open}>\n        {context.disableHoverableContent ? (\n          <TooltipContentImpl side={side} {...contentProps} ref={forwardedRef} />\n        ) : (\n          <TooltipContentHoverable side={side} {...contentProps} ref={forwardedRef} />\n        )}\n      </Presence>\n    );\n  }\n);\n\ntype Point = { x: number; y: number };\ntype Polygon = Point[];\n\ntype TooltipContentHoverableElement = TooltipContentImplElement;\ninterface TooltipContentHoverableProps extends TooltipContentImplProps {}\n\nconst TooltipContentHoverable = React.forwardRef<\n  TooltipContentHoverableElement,\n  TooltipContentHoverableProps\n>((props: ScopedProps<TooltipContentHoverableProps>, forwardedRef) => {\n  const context = useTooltipContext(CONTENT_NAME, props.__scopeTooltip);\n  const providerContext = useTooltipProviderContext(CONTENT_NAME, props.__scopeTooltip);\n  const ref = React.useRef<TooltipContentHoverableElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const [pointerGraceArea, setPointerGraceArea] = React.useState<Polygon | null>(null);\n\n  const { trigger, onClose } = context;\n  const content = ref.current;\n\n  const { onPointerInTransitChange } = providerContext;\n\n  const handleRemoveGraceArea = React.useCallback(() => {\n    setPointerGraceArea(null);\n    onPointerInTransitChange(false);\n  }, [onPointerInTransitChange]);\n\n  const handleCreateGraceArea = React.useCallback(\n    (event: PointerEvent, hoverTarget: HTMLElement) => {\n      const currentTarget = event.currentTarget as HTMLElement;\n      const exitPoint = { x: event.clientX, y: event.clientY };\n      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());\n      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);\n      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());\n      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);\n      setPointerGraceArea(graceArea);\n      onPointerInTransitChange(true);\n    },\n    [onPointerInTransitChange]\n  );\n\n  React.useEffect(() => {\n    return () => handleRemoveGraceArea();\n  }, [handleRemoveGraceArea]);\n\n  React.useEffect(() => {\n    if (trigger && content) {\n      const handleTriggerLeave = (event: PointerEvent) => handleCreateGraceArea(event, content);\n      const handleContentLeave = (event: PointerEvent) => handleCreateGraceArea(event, trigger);\n\n      trigger.addEventListener('pointerleave', handleTriggerLeave);\n      content.addEventListener('pointerleave', handleContentLeave);\n      return () => {\n        trigger.removeEventListener('pointerleave', handleTriggerLeave);\n        content.removeEventListener('pointerleave', handleContentLeave);\n      };\n    }\n  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);\n\n  React.useEffect(() => {\n    if (pointerGraceArea) {\n      const handleTrackPointerGrace = (event: PointerEvent) => {\n        const target = event.target as HTMLElement;\n        const pointerPosition = { x: event.clientX, y: event.clientY };\n        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);\n        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);\n\n        if (hasEnteredTarget) {\n          handleRemoveGraceArea();\n        } else if (isPointerOutsideGraceArea) {\n          handleRemoveGraceArea();\n          onClose();\n        }\n      };\n      document.addEventListener('pointermove', handleTrackPointerGrace);\n      return () => document.removeEventListener('pointermove', handleTrackPointerGrace);\n    }\n  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);\n\n  return <TooltipContentImpl {...props} ref={composedRefs} />;\n});\n\nconst [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] =\n  createTooltipContext(TOOLTIP_NAME, { isInside: false });\n\ntype TooltipContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype PopperContentProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ninterface TooltipContentImplProps extends Omit<PopperContentProps, 'onPlaced'> {\n  /**\n   * A more descriptive label for accessibility purpose\n   */\n  'aria-label'?: string;\n\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `Tooltip`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n}\n\nconst TooltipContentImpl = React.forwardRef<TooltipContentImplElement, TooltipContentImplProps>(\n  (props: ScopedProps<TooltipContentImplProps>, forwardedRef) => {\n    const {\n      __scopeTooltip,\n      children,\n      'aria-label': ariaLabel,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      ...contentProps\n    } = props;\n    const context = useTooltipContext(CONTENT_NAME, __scopeTooltip);\n    const popperScope = usePopperScope(__scopeTooltip);\n    const { onClose } = context;\n\n    // Close this tooltip if another one opens\n    React.useEffect(() => {\n      document.addEventListener(TOOLTIP_OPEN, onClose);\n      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);\n    }, [onClose]);\n\n    // Close the tooltip if the trigger is scrolled\n    React.useEffect(() => {\n      if (context.trigger) {\n        const handleScroll = (event: Event) => {\n          const target = event.target as HTMLElement;\n          if (target?.contains(context.trigger)) onClose();\n        };\n        window.addEventListener('scroll', handleScroll, { capture: true });\n        return () => window.removeEventListener('scroll', handleScroll, { capture: true });\n      }\n    }, [context.trigger, onClose]);\n\n    return (\n      <DismissableLayer\n        asChild\n        disableOutsidePointerEvents={false}\n        onEscapeKeyDown={onEscapeKeyDown}\n        onPointerDownOutside={onPointerDownOutside}\n        onFocusOutside={(event) => event.preventDefault()}\n        onDismiss={onClose}\n      >\n        <PopperPrimitive.Content\n          data-state={context.stateAttribute}\n          {...popperScope}\n          {...contentProps}\n          ref={forwardedRef}\n          style={{\n            ...contentProps.style,\n            // re-namespace exposed content custom properties\n            ...{\n              '--radix-tooltip-content-transform-origin': 'var(--radix-popper-transform-origin)',\n              '--radix-tooltip-content-available-width': 'var(--radix-popper-available-width)',\n              '--radix-tooltip-content-available-height': 'var(--radix-popper-available-height)',\n              '--radix-tooltip-trigger-width': 'var(--radix-popper-anchor-width)',\n              '--radix-tooltip-trigger-height': 'var(--radix-popper-anchor-height)',\n            },\n          }}\n        >\n          <Slottable>{children}</Slottable>\n          <VisuallyHiddenContentContextProvider scope={__scopeTooltip} isInside={true}>\n            <VisuallyHiddenPrimitive.Root id={context.contentId} role=\"tooltip\">\n              {ariaLabel || children}\n            </VisuallyHiddenPrimitive.Root>\n          </VisuallyHiddenContentContextProvider>\n        </PopperPrimitive.Content>\n      </DismissableLayer>\n    );\n  }\n);\n\nTooltipContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * TooltipArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'TooltipArrow';\n\ntype TooltipArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface TooltipArrowProps extends PopperArrowProps {}\n\nconst TooltipArrow = React.forwardRef<TooltipArrowElement, TooltipArrowProps>(\n  (props: ScopedProps<TooltipArrowProps>, forwardedRef) => {\n    const { __scopeTooltip, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeTooltip);\n    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(\n      ARROW_NAME,\n      __scopeTooltip\n    );\n    // if the arrow is inside the `VisuallyHidden`, we don't want to render it all to\n    // prevent issues in positioning the arrow due to the duplicate\n    return visuallyHiddenContentContext.isInside ? null : (\n      <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />\n    );\n  }\n);\n\nTooltipArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype Side = NonNullable<TooltipContentProps['side']>;\n\nfunction getExitSideFromRect(point: Point, rect: DOMRect): Side {\n  const top = Math.abs(rect.top - point.y);\n  const bottom = Math.abs(rect.bottom - point.y);\n  const right = Math.abs(rect.right - point.x);\n  const left = Math.abs(rect.left - point.x);\n\n  switch (Math.min(top, bottom, right, left)) {\n    case left:\n      return 'left';\n    case right:\n      return 'right';\n    case top:\n      return 'top';\n    case bottom:\n      return 'bottom';\n    default:\n      throw new Error('unreachable');\n  }\n}\n\nfunction getPaddedExitPoints(exitPoint: Point, exitSide: Side, padding = 5) {\n  const paddedExitPoints: Point[] = [];\n  switch (exitSide) {\n    case 'top':\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y + padding },\n        { x: exitPoint.x + padding, y: exitPoint.y + padding }\n      );\n      break;\n    case 'bottom':\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y - padding },\n        { x: exitPoint.x + padding, y: exitPoint.y - padding }\n      );\n      break;\n    case 'left':\n      paddedExitPoints.push(\n        { x: exitPoint.x + padding, y: exitPoint.y - padding },\n        { x: exitPoint.x + padding, y: exitPoint.y + padding }\n      );\n      break;\n    case 'right':\n      paddedExitPoints.push(\n        { x: exitPoint.x - padding, y: exitPoint.y - padding },\n        { x: exitPoint.x - padding, y: exitPoint.y + padding }\n      );\n      break;\n  }\n  return paddedExitPoints;\n}\n\nfunction getPointsFromRect(rect: DOMRect) {\n  const { top, right, bottom, left } = rect;\n  return [\n    { x: left, y: top },\n    { x: right, y: top },\n    { x: right, y: bottom },\n    { x: left, y: bottom },\n  ];\n}\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\n// Returns a new array of points representing the convex hull of the given set of points.\n// https://www.nayuki.io/page/convex-hull-algorithm\nfunction getHull<P extends Point>(points: Readonly<Array<P>>): Array<P> {\n  const newPoints: Array<P> = points.slice();\n  newPoints.sort((a: Point, b: Point) => {\n    if (a.x < b.x) return -1;\n    else if (a.x > b.x) return +1;\n    else if (a.y < b.y) return -1;\n    else if (a.y > b.y) return +1;\n    else return 0;\n  });\n  return getHullPresorted(newPoints);\n}\n\n// Returns the convex hull, assuming that each points[i] <= points[i + 1]. Runs in O(n) time.\nfunction getHullPresorted<P extends Point>(points: Readonly<Array<P>>): Array<P> {\n  if (points.length <= 1) return points.slice();\n\n  const upperHull: Array<P> = [];\n  for (let i = 0; i < points.length; i++) {\n    const p = points[i];\n    while (upperHull.length >= 2) {\n      const q = upperHull[upperHull.length - 1];\n      const r = upperHull[upperHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) upperHull.pop();\n      else break;\n    }\n    upperHull.push(p);\n  }\n  upperHull.pop();\n\n  const lowerHull: Array<P> = [];\n  for (let i = points.length - 1; i >= 0; i--) {\n    const p = points[i];\n    while (lowerHull.length >= 2) {\n      const q = lowerHull[lowerHull.length - 1];\n      const r = lowerHull[lowerHull.length - 2];\n      if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) lowerHull.pop();\n      else break;\n    }\n    lowerHull.push(p);\n  }\n  lowerHull.pop();\n\n  if (\n    upperHull.length === 1 &&\n    lowerHull.length === 1 &&\n    upperHull[0].x === lowerHull[0].x &&\n    upperHull[0].y === lowerHull[0].y\n  ) {\n    return upperHull;\n  } else {\n    return upperHull.concat(lowerHull);\n  }\n}\n\nconst Provider = TooltipProvider;\nconst Root = Tooltip;\nconst Trigger = TooltipTrigger;\nconst Portal = TooltipPortal;\nconst Content = TooltipContent;\nconst Arrow = TooltipArrow;\n\nexport {\n  createTooltipScope,\n  //\n  TooltipProvider,\n  Tooltip,\n  TooltipTrigger,\n  TooltipPortal,\n  TooltipContent,\n  TooltipArrow,\n  //\n  Provider,\n  Root,\n  Trigger,\n  Portal,\n  Content,\n  Arrow,\n};\nexport type {\n  TooltipProviderProps,\n  TooltipProps,\n  TooltipTriggerProps,\n  TooltipPortalProps,\n  TooltipContentProps,\n  TooltipArrowProps,\n};\n"]},"metadata":{},"sourceType":"module"}