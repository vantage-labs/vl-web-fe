{"ast":null,"code":"\"use client\"; // packages/react/focus-scope/src/FocusScope.tsx\n\nimport * as React from \"react\";\nimport { useComposedRefs } from \"@radix-ui/react-compose-refs\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nimport { jsx } from \"react/jsx-runtime\";\nvar AUTOFOCUS_ON_MOUNT = \"focusScope.autoFocusOnMount\";\nvar AUTOFOCUS_ON_UNMOUNT = \"focusScope.autoFocusOnUnmount\";\nvar EVENT_OPTIONS = {\n  bubbles: false,\n  cancelable: true\n};\nvar FOCUS_SCOPE_NAME = \"FocusScope\";\nvar FocusScope = React.forwardRef((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef(null);\n  const composedRefs = useComposedRefs(forwardedRef, node => setContainer(node));\n  const focusScope = React.useRef({\n    paused: false,\n\n    pause() {\n      this.paused = true;\n    },\n\n    resume() {\n      this.paused = false;\n    }\n\n  }).current;\n  React.useEffect(() => {\n    if (trapped) {\n      let handleFocusIn2 = function (event) {\n        if (focusScope.paused || !container) return;\n        const target = event.target;\n\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, {\n            select: true\n          });\n        }\n      },\n          handleFocusOut2 = function (event) {\n        if (focusScope.paused || !container) return;\n        const relatedTarget = event.relatedTarget;\n        if (relatedTarget === null) return;\n\n        if (!container.contains(relatedTarget)) {\n          focus(lastFocusedElementRef.current, {\n            select: true\n          });\n        }\n      },\n          handleMutations2 = function (mutations) {\n        const focusedElement = document.activeElement;\n        if (focusedElement !== document.body) return;\n\n        for (const mutation of mutations) {\n          if (mutation.removedNodes.length > 0) focus(container);\n        }\n      };\n\n      var handleFocusIn = handleFocusIn2,\n          handleFocusOut = handleFocusOut2,\n          handleMutations = handleMutations2;\n      document.addEventListener(\"focusin\", handleFocusIn2);\n      document.addEventListener(\"focusout\", handleFocusOut2);\n      const mutationObserver = new MutationObserver(handleMutations2);\n      if (container) mutationObserver.observe(container, {\n        childList: true,\n        subtree: true\n      });\n      return () => {\n        document.removeEventListener(\"focusin\", handleFocusIn2);\n        document.removeEventListener(\"focusout\", handleFocusOut2);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), {\n            select: true\n          });\n\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, {\n              select: true\n            });\n          }\n\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n  const handleKeyDown = React.useCallback(event => {\n    if (!loop && !trapped) return;\n    if (focusScope.paused) return;\n    const isTabKey = event.key === \"Tab\" && !event.altKey && !event.ctrlKey && !event.metaKey;\n    const focusedElement = document.activeElement;\n\n    if (isTabKey && focusedElement) {\n      const container2 = event.currentTarget;\n      const [first, last] = getTabbableEdges(container2);\n      const hasTabbableElementsInside = first && last;\n\n      if (!hasTabbableElementsInside) {\n        if (focusedElement === container2) event.preventDefault();\n      } else {\n        if (!event.shiftKey && focusedElement === last) {\n          event.preventDefault();\n          if (loop) focus(first, {\n            select: true\n          });\n        } else if (event.shiftKey && focusedElement === first) {\n          event.preventDefault();\n          if (loop) focus(last, {\n            select: true\n          });\n        }\n      }\n    }\n  }, [loop, trapped, focusScope.paused]);\n  return /* @__PURE__ */jsx(Primitive.div, {\n    tabIndex: -1,\n    ...scopeProps,\n    ref: composedRefs,\n    onKeyDown: handleKeyDown\n  });\n});\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\nfunction focusFirst(candidates) {\n  let {\n    select = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const previouslyFocusedElement = document.activeElement;\n\n  for (const candidate of candidates) {\n    focus(candidate, {\n      select\n    });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\nfunction getTabbableEdges(container) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last];\n}\n\nfunction getTabbableCandidates(container) {\n  const nodes = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: node => {\n      const isHiddenInput = node.tagName === \"INPUT\" && node.type === \"hidden\";\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    }\n  });\n\n  while (walker.nextNode()) nodes.push(walker.currentNode);\n\n  return nodes;\n}\n\nfunction findVisible(elements, container) {\n  for (const element of elements) {\n    if (!isHidden(element, {\n      upTo: container\n    })) return element;\n  }\n}\n\nfunction isHidden(node, _ref) {\n  let {\n    upTo\n  } = _ref;\n  if (getComputedStyle(node).visibility === \"hidden\") return true;\n\n  while (node) {\n    if (upTo !== void 0 && node === upTo) return false;\n    if (getComputedStyle(node).display === \"none\") return true;\n    node = node.parentElement;\n  }\n\n  return false;\n}\n\nfunction isSelectableInput(element) {\n  return element instanceof HTMLInputElement && \"select\" in element;\n}\n\nfunction focus(element) {\n  let {\n    select = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    element.focus({\n      preventScroll: true\n    });\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select) element.select();\n  }\n}\n\nvar focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  let stack = [];\n  return {\n    add(focusScope) {\n      const activeFocusScope = stack[0];\n\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    }\n\n  };\n}\n\nfunction arrayRemove(array, item) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n\n  return updatedArray;\n}\n\nfunction removeLinks(items) {\n  return items.filter(item => item.tagName !== \"A\");\n}\n\nvar Root = FocusScope;\nexport { FocusScope, Root };","map":{"version":3,"mappings":"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","names":["React","useComposedRefs","Primitive","useCallbackRef","AUTOFOCUS_ON_MOUNT","AUTOFOCUS_ON_UNMOUNT","EVENT_OPTIONS","bubbles","cancelable","FOCUS_SCOPE_NAME","FocusScope","props","forwardedRef","loop","trapped","onMountAutoFocus","onMountAutoFocusProp","onUnmountAutoFocus","onUnmountAutoFocusProp","scopeProps","container","setContainer","lastFocusedElementRef","composedRefs","node","focusScope","paused","pause","resume","current","handleFocusIn","event","target","contains","focus","select","handleFocusOut","relatedTarget","handleMutations","mutations","focusedElement","document","activeElement","body","mutation","removedNodes","length","addEventListener","mutationObserver","MutationObserver","observe","childList","subtree","removeEventListener","disconnect","focusScopesStack","add","previouslyFocusedElement","hasFocusedCandidate","mountEvent","CustomEvent","dispatchEvent","defaultPrevented","focusFirst","removeLinks","getTabbableCandidates","setTimeout","unmountEvent","remove","handleKeyDown","isTabKey","key","altKey","ctrlKey","metaKey","currentTarget","first","last","getTabbableEdges","hasTabbableElementsInside","preventDefault","shiftKey","div","tabIndex","ref","onKeyDown","displayName","candidates","candidate","findVisible","reverse","nodes","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","isHiddenInput","tagName","type","disabled","hidden","FILTER_SKIP","FILTER_ACCEPT","nextNode","push","currentNode","elements","element","isHidden","upTo","getComputedStyle","visibility","display","parentElement","isSelectableInput","HTMLInputElement","preventScroll","createFocusScopesStack","stack","activeFocusScope","arrayRemove","unshift","array","item","updatedArray","index","indexOf","splice","items","filter","Root"],"sources":["/home/bahari/vl-web-fe/node_modules/@radix-ui/react-focus-scope/src/FocusScope.tsx"],"sourcesContent":["import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\n\nconst AUTOFOCUS_ON_MOUNT = 'focusScope.autoFocusOnMount';\nconst AUTOFOCUS_ON_UNMOUNT = 'focusScope.autoFocusOnUnmount';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\ntype FocusableTarget = HTMLElement | { focus(): void };\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope\n * -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_SCOPE_NAME = 'FocusScope';\n\ntype FocusScopeElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface FocusScopeProps extends PrimitiveDivProps {\n  /**\n   * When `true`, tabbing from last item will focus first tabbable\n   * and shift+tab from first item will focus last tababble.\n   * @defaultValue false\n   */\n  loop?: boolean;\n\n  /**\n   * When `true`, focus cannot escape the focus scope via keyboard,\n   * pointer, or a programmatic focus.\n   * @defaultValue false\n   */\n  trapped?: boolean;\n\n  /**\n   * Event handler called when auto-focusing on mount.\n   * Can be prevented.\n   */\n  onMountAutoFocus?: (event: Event) => void;\n\n  /**\n   * Event handler called when auto-focusing on unmount.\n   * Can be prevented.\n   */\n  onUnmountAutoFocus?: (event: Event) => void;\n}\n\nconst FocusScope = React.forwardRef<FocusScopeElement, FocusScopeProps>((props, forwardedRef) => {\n  const {\n    loop = false,\n    trapped = false,\n    onMountAutoFocus: onMountAutoFocusProp,\n    onUnmountAutoFocus: onUnmountAutoFocusProp,\n    ...scopeProps\n  } = props;\n  const [container, setContainer] = React.useState<HTMLElement | null>(null);\n  const onMountAutoFocus = useCallbackRef(onMountAutoFocusProp);\n  const onUnmountAutoFocus = useCallbackRef(onUnmountAutoFocusProp);\n  const lastFocusedElementRef = React.useRef<HTMLElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));\n\n  const focusScope = React.useRef({\n    paused: false,\n    pause() {\n      this.paused = true;\n    },\n    resume() {\n      this.paused = false;\n    },\n  }).current;\n\n  // Takes care of trapping focus if focus is moved outside programmatically for example\n  React.useEffect(() => {\n    if (trapped) {\n      function handleFocusIn(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const target = event.target as HTMLElement | null;\n        if (container.contains(target)) {\n          lastFocusedElementRef.current = target;\n        } else {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      function handleFocusOut(event: FocusEvent) {\n        if (focusScope.paused || !container) return;\n        const relatedTarget = event.relatedTarget as HTMLElement | null;\n\n        // A `focusout` event with a `null` `relatedTarget` will happen in at least two cases:\n        //\n        // 1. When the user switches app/tabs/windows/the browser itself loses focus.\n        // 2. In Google Chrome, when the focused element is removed from the DOM.\n        //\n        // We let the browser do its thing here because:\n        //\n        // 1. The browser already keeps a memory of what's focused for when the page gets refocused.\n        // 2. In Google Chrome, if we try to focus the deleted focused element (as per below), it\n        //    throws the CPU to 100%, so we avoid doing anything for this reason here too.\n        if (relatedTarget === null) return;\n\n        // If the focus has moved to an actual legitimate element (`relatedTarget !== null`)\n        // that is outside the container, we move focus to the last valid focused element inside.\n        if (!container.contains(relatedTarget)) {\n          focus(lastFocusedElementRef.current, { select: true });\n        }\n      }\n\n      // When the focused element gets removed from the DOM, browsers move focus\n      // back to the document.body. In this case, we move focus to the container\n      // to keep focus trapped correctly.\n      function handleMutations(mutations: MutationRecord[]) {\n        const focusedElement = document.activeElement as HTMLElement | null;\n        if (focusedElement !== document.body) return;\n        for (const mutation of mutations) {\n          if (mutation.removedNodes.length > 0) focus(container);\n        }\n      }\n\n      document.addEventListener('focusin', handleFocusIn);\n      document.addEventListener('focusout', handleFocusOut);\n      const mutationObserver = new MutationObserver(handleMutations);\n      if (container) mutationObserver.observe(container, { childList: true, subtree: true });\n\n      return () => {\n        document.removeEventListener('focusin', handleFocusIn);\n        document.removeEventListener('focusout', handleFocusOut);\n        mutationObserver.disconnect();\n      };\n    }\n  }, [trapped, container, focusScope.paused]);\n\n  React.useEffect(() => {\n    if (container) {\n      focusScopesStack.add(focusScope);\n      const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n      const hasFocusedCandidate = container.contains(previouslyFocusedElement);\n\n      if (!hasFocusedCandidate) {\n        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);\n        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n        container.dispatchEvent(mountEvent);\n        if (!mountEvent.defaultPrevented) {\n          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });\n          if (document.activeElement === previouslyFocusedElement) {\n            focus(container);\n          }\n        }\n      }\n\n      return () => {\n        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);\n\n        // We hit a react bug (fixed in v17) with focusing in unmount.\n        // We need to delay the focus a little to get around it for now.\n        // See: https://github.com/facebook/react/issues/17894\n        setTimeout(() => {\n          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);\n          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n          container.dispatchEvent(unmountEvent);\n          if (!unmountEvent.defaultPrevented) {\n            focus(previouslyFocusedElement ?? document.body, { select: true });\n          }\n          // we need to remove the listener after we `dispatchEvent`\n          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);\n\n          focusScopesStack.remove(focusScope);\n        }, 0);\n      };\n    }\n  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);\n\n  // Takes care of looping focus (when tabbing whilst at the edges)\n  const handleKeyDown = React.useCallback(\n    (event: React.KeyboardEvent) => {\n      if (!loop && !trapped) return;\n      if (focusScope.paused) return;\n\n      const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n      const focusedElement = document.activeElement as HTMLElement | null;\n\n      if (isTabKey && focusedElement) {\n        const container = event.currentTarget as HTMLElement;\n        const [first, last] = getTabbableEdges(container);\n        const hasTabbableElementsInside = first && last;\n\n        // we can only wrap focus if we have tabbable edges\n        if (!hasTabbableElementsInside) {\n          if (focusedElement === container) event.preventDefault();\n        } else {\n          if (!event.shiftKey && focusedElement === last) {\n            event.preventDefault();\n            if (loop) focus(first, { select: true });\n          } else if (event.shiftKey && focusedElement === first) {\n            event.preventDefault();\n            if (loop) focus(last, { select: true });\n          }\n        }\n      }\n    },\n    [loop, trapped, focusScope.paused]\n  );\n\n  return (\n    <Primitive.div tabIndex={-1} {...scopeProps} ref={composedRefs} onKeyDown={handleKeyDown} />\n  );\n});\n\nFocusScope.displayName = FOCUS_SCOPE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Utils\n * -----------------------------------------------------------------------------------------------*/\n\n/**\n * Attempts focusing the first element in a list of candidates.\n * Stops when focus has actually moved.\n */\nfunction focusFirst(candidates: HTMLElement[], { select = false } = {}) {\n  const previouslyFocusedElement = document.activeElement;\n  for (const candidate of candidates) {\n    focus(candidate, { select });\n    if (document.activeElement !== previouslyFocusedElement) return;\n  }\n}\n\n/**\n * Returns the first and last tabbable elements inside a container.\n */\nfunction getTabbableEdges(container: HTMLElement) {\n  const candidates = getTabbableCandidates(container);\n  const first = findVisible(candidates, container);\n  const last = findVisible(candidates.reverse(), container);\n  return [first, last] as const;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\n/**\n * Returns the first visible element in a list.\n * NOTE: Only checks visibility up to the `container`.\n */\nfunction findVisible(elements: HTMLElement[], container: HTMLElement) {\n  for (const element of elements) {\n    // we stop checking if it's hidden at the `container` level (excluding)\n    if (!isHidden(element, { upTo: container })) return element;\n  }\n}\n\nfunction isHidden(node: HTMLElement, { upTo }: { upTo?: HTMLElement }) {\n  if (getComputedStyle(node).visibility === 'hidden') return true;\n  while (node) {\n    // we stop at `upTo` (excluding it)\n    if (upTo !== undefined && node === upTo) return false;\n    if (getComputedStyle(node).display === 'none') return true;\n    node = node.parentElement as HTMLElement;\n  }\n  return false;\n}\n\nfunction isSelectableInput(element: any): element is FocusableTarget & { select: () => void } {\n  return element instanceof HTMLInputElement && 'select' in element;\n}\n\nfunction focus(element?: FocusableTarget | null, { select = false } = {}) {\n  // only focus if that element is focusable\n  if (element && element.focus) {\n    const previouslyFocusedElement = document.activeElement;\n    // NOTE: we prevent scrolling on focus, to minimize jarring transitions for users\n    element.focus({ preventScroll: true });\n    // only select if its not the same element, it supports selection and we need to select\n    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)\n      element.select();\n  }\n}\n\n/* -------------------------------------------------------------------------------------------------\n * FocusScope stack\n * -----------------------------------------------------------------------------------------------*/\n\ntype FocusScopeAPI = { paused: boolean; pause(): void; resume(): void };\nconst focusScopesStack = createFocusScopesStack();\n\nfunction createFocusScopesStack() {\n  /** A stack of focus scopes, with the active one at the top */\n  let stack: FocusScopeAPI[] = [];\n\n  return {\n    add(focusScope: FocusScopeAPI) {\n      // pause the currently active focus scope (at the top of the stack)\n      const activeFocusScope = stack[0];\n      if (focusScope !== activeFocusScope) {\n        activeFocusScope?.pause();\n      }\n      // remove in case it already exists (because we'll re-add it at the top of the stack)\n      stack = arrayRemove(stack, focusScope);\n      stack.unshift(focusScope);\n    },\n\n    remove(focusScope: FocusScopeAPI) {\n      stack = arrayRemove(stack, focusScope);\n      stack[0]?.resume();\n    },\n  };\n}\n\nfunction arrayRemove<T>(array: T[], item: T) {\n  const updatedArray = [...array];\n  const index = updatedArray.indexOf(item);\n  if (index !== -1) {\n    updatedArray.splice(index, 1);\n  }\n  return updatedArray;\n}\n\nfunction removeLinks(items: HTMLElement[]) {\n  return items.filter((item) => item.tagName !== 'A');\n}\n\nconst Root = FocusScope;\n\nexport {\n  FocusScope,\n  //\n  Root,\n};\nexport type { FocusScopeProps };\n"]},"metadata":{},"sourceType":"module"}